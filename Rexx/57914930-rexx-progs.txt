/*REXX*/
"ISREDIT MACRO (STRING)"
/* STRING IS THE PARAMETER */
"ISREDIT X ALL"
/* EXCLUDE ALL LINES
*/
"ISREDIT F ALL " STRING
/* FIND ONLY PARM PASSED */
EXIT
/*REXX*/
/* used to zoom a copybook in a cobol program */
/* TEST COPY USWNOTE1. */
ADDRESS ISREDIT
'MACRO'
'(lnum) = LINENUM' .ZCSR
'(lndata) = LINE' lnum
lndata = strip(lndata)
say lndata
/*
------------> */
dspos = pos('COPY',lndata)
/* checks for copy in line extracted */
if dspos = 0 then SIGNAL error_msg
lastpos = pos('.',substr(lndata,dspos+5))
member = substr(lndata,dspos+5,lastpos-1)
member = strip(member)
/* removes trailing and leading
/* ---------------- */
blanks*/
dsname = 'PARASD.REXX.SRC('||member||')'
address ispexec
"browse dataset('"dsname"')" ;
exit
error_msg:
say 'Place the cursor over the COPY verb'
exit
ADDRESS ISPEXEC
'VGET (ZSCREENI,ZSCREENC,ZENVIR)'
/* EXTRACT SCREEN IMAGE,
CURSOR POS AND ISPF LEVEL */
IF SUBSTR(ZENVIR,5,4) <4.5 THEN
CALL GET_ZSCREEN_VALUES
TRTABLE='ABCDEFGHIJKLMNOPQRSTUVWXYZ' /* SETUP VALID DSNAME CHARS */
TRTABLE=TRTABLE||TRANSLATE(TRTABLE)||'$#@0123456789.''-{()'
TRTABLE=TRANSLATE(XRANGE('00'X,'FF'X),,TRTABLE,' ')
ZSCREENI=TRANSLATE(ZSCREENI,,TRTABLE,' ') /* REMOVE NON-DSN CHARS
*/
IF SUBSTR(ZSCREENI,ZSCREENC+1,1) <> ' ' THEN /* MAYBE CSR ON DSN
*/
DO
/* EXTRACT DSN FROM SCREEN IMAGE
AND VIEW DATASET
*/
NAME=WORD(SUBSTR(ZSCREENI,1+LASTPOS(' ',ZSCREENI,ZSCREENC)),1)
SAY NAME
NAME=TRANSLATE(STRIP(SUBSTR(NAME,1,56))) /* MAX OF 56 CHAR NAME */
IF SUBSTR(NAME,1,1)='(' THEN
PARSE VAR NAME '('NAME')'.
PARSE VAR NAME DSN '('MEM')'
/* IS THERE A MEMBER NAME?
*/
OMEM=MEM
IF MEM<>'' THEN
/* IF SO, REFORMAT FOR VIEW
CMD
*/
DO
GDG=0
NAME=DSN
/* GET DSN
*/
IF SUBSTR(NAME,1,1)='''' THEN /* IF ORIGINAL NAME STARTED WITH
QUOTES
*/
NAME=NAME''''
/* FIX QUOTES
*/
END
END
SAY NAME
RETURN

00010000
00020000
00030000
00040000
00050000
00010000
00020000
00030000
00040000
00050000
00060000
00070000
00080000
00081000
00082001
00090000
00100000
00110000
00120000
00130000
00131001
00140000
00150000
00160000
00170000
00180000
00190000
00200000
00210000
00010000
00020000
00030000
00040000
00050000
00060000
00070000
00080000
00090000
00100000
00110000
00120000
00130000
00131000
00140000
00150000
00160000
00170000
00180000
00190000
00200000
00210000
00220000
00230000
00240000
00250000
00260000
00270000
00280000
00290000
00291000

GET_ZSCREEN_VALUES:
/* OBTAIN THE SCREEN IMAGE
*/00300000
ADDRESS ISPEXEC 'VGET (ZSCREENW,ZSCREEND)'
00310000
P = PTR(96+PTR(PTR(24+PTR(112+PTR(132+PTR(540))))))
00320000
ZSCREENI=TRANSLATE(STORAGE(D2X(P),,
00330000
ZSCREENW*ZSCREEND),,XRANGE('00'X,'3F'X))
00340000
ZSCREENC = C2D(STORAGE(,
00350000
D2X(164+PTR(PTR(24+PTR(112+PTR(132+PTR(540)))))),4))
00360000
RETURN
00370000
PTR: RETURN C2D(BITAND(STORAGE(D2X(ARG(1)),4),'7FFFFFFF'X))
00380000
/* REXX
*/
00001007
/* This Macro will create the compile jcl, submit the jcl and
00001107
will show the result of the compilation on the ISPF Screen.
00001209
00001309
Pre-Requisites : 2 EXEC SCOMP and SCOMP1 must be saved in a PDS.
00001409
This PDS must be allocated to ISPEXEC or SYSEXEC. 00001509
Skeleton of the Compile JCL must be saved in a PDS. 00001609
This skeleton must contain a variable &SRCNAME
00001709
to refer to the Source Program file.
00001809
00001909
Modifications : Change UTLTPDS to the PDS where Compile JCL is saved00002009
Change TEMPL to the Compile JCL member name.
00002109
00002209
How to start : Open the Source file in the ISPF Editor in Edit mode00002309
Type SCOMP on the Command bar.
00002409
The compile JCL will be created, submitted and the 00002509
output listing will be shown on a separate screen. 00002609
*/ 00002709
00002809
'ISREDIT MACRO'
00003002
'ISREDIT (pgmlib) = dataset'
00030009
'ISREDIT (pgmname) = member'
00040009
00050009
/* Tailor the JCL */
00060009
00060109
utltpds = 'PARASD.REXX.SRC' /* CHANGE TO THE CORRECT COMPILE PDS */ 00061009
00062009
ADDRESS ISPEXEC
00070003
"LIBDEF ISPPLIB DATASET ID('"utltpds"')"
00080009
"LIBDEF ISPSLIB DATASET ID('"utltpds"')"
00090009
ADDRESS TSO
00100003
"ALLOC FI(ISPFILE) DA('"utltpds"') SHR REUSE"
00110009
00110109
srcname=pgmlib'('pgmname')'
00110209
ADDRESS ISPEXEC
00111003
"FTOPEN TEMP"
00120007
"FTINCL TEMPL"
/* CHANGE TO THE CORRECT COMPILE MEMBER */ 00130009
"FTCLOSE"
00140007
"VGET (ZTEMPF)"
00150003
TRACE "OFF"
00180007
ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
00200007
CALL OUTTRAP "LINE."
00210007
arg = "SUB ('"ZTEMPF"')"
00220009
00230007
/* Submit the Compile Job */
00240009
00250007
ADDRESS TSO arg
00260009
CALL OUTTRAP "OFF"
00270007
00271009
IF LINE.0 > 0
00280007
THEN DO
00290007

/* Get the JOB name and number */
line1 =
posjob
jobname
jobid

LINE.1
= POS("(",line1)
= SUBSTR(line1,5,posjob-5)
= SUBSTR(line1,posjob+1,8)

/* Process SDSF

*/

ADDRESS TSO
maxrc = ""
/* WRITE SDSF COMMANDS TO QUEUE */
QUEUE "SET CONFIRM OFF"
QUEUE "OWNER *"
QUEUE "PREFIX *"
QUEUE "H"
QUEUE "SELECT "jobname jobid
QUEUE "AFD REFRESH"
QUEUE "FIND "jobname
QUEUE "END"
QUEUE ""
/* ALLOCATE IN-/OUT-DATASET */
"ALLOC DD(ISFIN) NEW REUSE UNIT(SYSDA)",
"RECFM(F,B) LRECL(80) BLKSIZE(27920) SPACE(1) TRACKS"
"ALLOC DD(ISFOUT) NEW REUSE UNIT(SYSDA)",
"RECFM(F,B,A) LRECL(301) BLKSIZE(27993) SPACE(1) CYL"
"EXECIO * DISKW ISFIN (FINIS"
DO WHILE maxrc = ""
/* Call SDSF */
PARM = "/ ++20,400"
ADDRESS LINKPGM "SDSF PARM"
/* READ ISFOUT IN OUT. */
"EXECIO * DISKR ISFOUT (STEM OUT. FINIS"
DO i=1 TO OUT.0 BY 1
IF(POS(jobname,OUT.I) <> 0 & POS(jobid,OUT.I) <> 0)
THEN DO
maxrc = SUBSTR(OUT.I,276)
LEAVE
END
END
END
"FREE DD(ISFIN,ISFOUT)"
/* Save Output to a File */
ADDRESS TSO
"OUTPUT "JOBNAME"("JOBID") PRINT("SDFOUT") KEEP HOLD"
ADDRESS ISPEXEC
"SELECT PGM(ISPSTRT) PARM("TSO SCOMP1")"
END

00330007
00340009
00350007
00360009
00370009
00380009
00390009
00400007
00410009
00420007
00430009
00440009
00441009
00450009
00460009
00470009
00480009
00490009
00500009
00510009
00520009
00530009
00540009
00550007
00560009
00561009
00570009
00580009
00590009
00600009
00620009
00630007
00640009
00641009
00650009
00660009
00670009
00680009
00690009
00700009
00710009
00720009
00730009
00740009
00750009
00760009
00770009
00780009
00790007
00800009
00810009
00820009
00830009
00840009
00850009
00860009
00861009
00862009
00862109
00863009

RETURN /*maxrc */

00980009
00020000
00030000
00050003
00010001
00030001
00040001
00050002

ADDRESS ISPEXEC
"SELECT PGM(ISPSTRT) PARM("TSO MAC4")"
DSN = "PARASD.SDFOUT.OUTLIST"
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"BROWSE DATASET('"DSN"') "
)ATTR
$ TYPE(INPUT) INTENS(LOW) PAD(_)
/* INPUT FIELD PADDED WITH '_' */
! TYPE(INPUT) INTENS(LOW) PAD(' ') /* INPUT FIELD PADDED WITH ' ' */
# TYPE(OUTPUT) INTENS(LOW) PAD(' ') /* OUTPUT */
)BODY
%-------------------- General Pattern Search Tool
+
+
+
Source PDS Name : $Z
+
+
Source Member
: _Z
+
+
Application Name : _Z
+
+
+
Valid Column Position
+
+
Left
: _Z+
+
Right
: _Z +
+
+
Comment Position : _Z+
+
Comment Pattern : _Z
+
+
+
Pattern List Dataset : _Z
+
+
+
New Pattern Exclusion PS : _Z
+
+
+
Submit/Edit
: _Z+
+
% #MSG
)INIT
.ZVARS = '(SRCPDS SRCMEM APPL LDATA RDATA COMNPOS COMNPAT +
PATNDS ADDPPS ED)'
&CUR = ED
.CURSOR = &CUR
)END
/* REXX */
00010000
DO i = 1 TO 2
00020000
SAY 'Enter an employee name.'
00030000
PARSE PULL employee.i
00040000
END
00050000
SAY EMPLOYEE.0
00051000
DO i = 1 TO 2
00060000
SAY EMPLOYEE.I
00070000
END
00090000
EMPLOYEE. = 'EMPLOYEE'
00091000
SAY EMPLOYEE.3
00100000
SAY EMPLOYEE.2
00110000
SAY EMPLOYEE.4
00120000
/* REXX */
00010000
arg a b d
00030000
c = a + b
00040000
00050000
say' The sum is 'c
say d
00060000
exit
00070000

/* REXX */
ADDRESS TSO
DSN1 = "PARASD.TEMP"
DSN2 = "PARASD.TEMP1"
"ALLOC FI(ISFIN) DA('"DSN1"') SHR REUSE"
"EXECIO * DISKR ISFIN (STEM INFILE. FINIS"
DO I = 1 TO INFILE.0
SAY INFILE.I
OUTFILE.I = INFILE.I
END
"ALLOC FI(ISFOUT) DA('"DSN2"') SHR REUSE"
"EXECIO * DISKW ISFOUT (STEM OUTFILE. FINIS"
RETURN
/* REXX */
utltpds = 'PARASD.REXX.SRC' /* CHANGE TO THE CORRECT COMPILE PDS */
templ = 'TEMPL'
/* CHANGE TO THE CORRECT COMPILE MEMBER */
ADDRESS ISPEXEC
"LIBDEF ISPPLIB DATASET ID('"utltpds"')"
"LIBDEF ISPSLIB DATASET ID('"utltpds"')"
ADDRESS TSO
"ALLOC FI(ISPFILE) DA('"utltpds"') SHR REUSE"
srcname ='ABCD'
progname=pgmlib'('pgmname')'
ADDRESS ISPEXEC
"FTOPEN TEMP"
"FTINCL "templ
"FTCLOSE"
"VGET (ZTEMPF)"
"CONTROL ERRORS RETURN"
"BROWSE DATASET('"ztempf"') "
/* REXX */
ADDRESS TSO
PREFIX = SYSVAR("SYSPREF")
UTLTPDS = 'PARASD.ISP.SYSEXEC'
UID
= USERID()
ADDRESS ISPEXEC
"LIBDEF ISPPLIB DATASET ID('"UTLTPDS"')"
"LIBDEF ISPSLIB DATASET ID('"UTLTPDS"')"
ADDRESS TSO
"ALLOC FI(ISPFILE) DA('"UTLTPDS"') SHR REUSE"
ADDRESS TSO
DO WHILE RC = 0
"ISPEXEC DISPLAY PANEL(PANEL01)"
IF RC = 8 THEN LEAVE
IF SRCMEM = '' THEN
LEAVE
ELSE
MSG = SRCMEM
END
EXIT
/*REXX*/
trace i
address ispexec
"libdef isptabl dataset id('PARASD.TABLES.SRC')"
"tbcreate rexxerr keys(ecode) names(etext) write"
trace off
do i = 1 to 49
ecode=i

00010000
00020000
00021000
00021100
00021200
00021300
00021400
00021501
00021600
00021700
00022000
00070001
00080000
00010000
00040000
00050000
00060000
00070000
00080000
00090000
00100000
00110000
00120000
00130000
00140000
00150001
00160001
00170000
00180000
00190000
00210000
00220000
00010000
00020000
00030000
00040000
00110000
00120000
00130000
00140000
00150000
00160000
00180000
00190000
00200001
00210000
00211002
00212002
00213002
00214002
00220000
00230000
00010000
00011001
00020000
00030000
00040000
00041001
00050000
00060000

etext= errortext(i)
"tbadd rexxerr order"
end
trace on
/* "tbopen rexxerr nowrite"
*/
say 'enter the error code (1-49) :'
pull ecode
"tbscan rexxerr arglist(ecode)"
if rc = 0 then say 'The error mesg is ' etext
else say 'row does not exist'
"tbclose rexxerr"
say 'Error mesg using function-' errortext(ecode)
exit
/* REXX
/* This Macro will create the compile jcl, submit the jcl and
will show the result of the compilation on the ISPF Screen.

00070000
00080000
00090000
00100001
00101001
00102000
00103000
00104000
00105000
00106000
00107000
00108000
00110000
*/
00001000
00001100
00001200
00001300
Pre-Requisites : 2 EXEC SCOMP and SCOMP1 must be saved in a PDS.
00001400
This PDS must be allocated to ISPEXEC or SYSEXEC. 00001500
Skeleton of the Compile JCL must be saved in a PDS. 00001600
This skeleton must contain a variable &SRCNAME
00001700
to refer to the Source Program file.
00001800
00001900
Modifications : Change UTLTPDS to the PDS where Compile JCL is saved00002000
Change TEMPL to the Compile JCL member name.
00002100
00002200
How to start : Open the Source file in the ISPF Editor in Edit mode00002300
Type SCOMP on the Command bar.
00002400
The compile JCL will be created, submitted and the 00002500
output listing will be shown on a separate screen. 00002600
*/ 00002700
00002800
'ISREDIT MACRO'
00003000
'ISREDIT (pgmlib) = dataset'
00030000
'ISREDIT (pgmname) = member'
00040000
00050000
/* Tailor the JCL */
00060000
00060100
utltpds = 'PARASD.REXX.SRC' /* CHANGE TO THE CORRECT COMPILE PDS */ 00061000
templ = 'TEMPL'
/* CHANGE TO THE CORRECT COMPILE MEMBER */ 00061101
00062000
ADDRESS ISPEXEC
00070000
"LIBDEF ISPPLIB DATASET ID('"utltpds"')"
00080000
"LIBDEF ISPSLIB DATASET ID('"utltpds"')"
00090000
ADDRESS TSO
00100000
"ALLOC FI(ISPFILE) DA('"utltpds"') SHR REUSE"
00110000
00110100
srcname =pgmlib'('pgmname')'
00110203
progname=pgmlib'('pgmname')'
00110303
say srcname progname
00110405
exit
00110505
ADDRESS ISPEXEC
00111000
"FTOPEN TEMP"
00120000
"FTINCL "templ
00130001
"FTCLOSE"
00140000
"VGET (ZTEMPF)"
00150000
ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
00200000
TRACE "OFF"
00201101
CALL OUTTRAP "LINE."
00210000
arg = "SUB ('"ZTEMPF"')"
00220006

exit
/* Submit the Compile Job */
ADDRESS TSO arg
CALL OUTTRAP "OFF"
IF LINE.0 > 0
THEN DO
/* Get the JOB name and number */
line1 = LINE.1
posjob = POS("(",line1)
jobname = SUBSTR(line1,5,posjob-5)
jobid = SUBSTR(line1,posjob+1,8)
SAY ' Job 'jobname jobid' is Submitted '
/* Process SDSF

*/

ADDRESS TSO
maxrc = ""
/* WRITE SDSF COMMANDS TO QUEUE */
QUEUE "SET CONFIRM OFF"
QUEUE "OWNER *"
QUEUE "PREFIX *"
QUEUE "H"
QUEUE "SELECT "jobname jobid
QUEUE "AFD REFRESH"
QUEUE "FIND "jobname
QUEUE "END"
QUEUE ""
/* ALLOCATE IN-/OUT-DATASET */
"ALLOC DD(ISFIN) NEW REUSE UNIT(SYSDA)",
"RECFM(F,B) LRECL(80) BLKSIZE(27920) SPACE(1) TRACKS"
"ALLOC DD(ISFOUT) NEW REUSE UNIT(SYSDA)",
"RECFM(F,B,A) LRECL(301) BLKSIZE(27993) SPACE(1) CYL"
"EXECIO * DISKW ISFIN (FINIS"
DO WHILE maxrc = ""
/* Call SDSF */
PARM = "/ ++20,400"
ADDRESS LINKPGM "SDSF PARM"
/* READ ISFOUT IN OUT. */
"EXECIO * DISKR ISFOUT (STEM OUT. FINIS"
DO i=1 TO OUT.0 BY 1
IF(POS(jobname,OUT.I) <> 0 & POS(jobid,OUT.I) <> 0)
THEN DO
maxrc = SUBSTR(OUT.I,276)
LEAVE
END
END
END
"FREE DD(ISFIN,ISFOUT)"

00221005
00230000
00240000
00250000
00260000
00270000
00271000
00280000
00290000
00330000
00340000
00350000
00360000
00370000
00380000
00390000
00391004
00400000
00410000
00420000
00430000
00440000
00441000
00450000
00460000
00470000
00480000
00490000
00500000
00510000
00520000
00530000
00540000
00550000
00560000
00561000
00570000
00580000
00590000
00600000
00620000
00630000
00640000
00641000
00650000
00660000
00670000
00680000
00690000
00700000
00710000
00720000
00730000
00740000
00750000
00760000
00770000
00780000
00790000
00800000

/* Save Output to a File */
ADDRESS TSO
"OUTPUT "JOBNAME"("JOBID") PRINT("SDFOUT") KEEP HOLD"
ADDRESS ISPEXEC
"SELECT PGM(ISPSTRT) PARM("TSO SCOMP1")"
/* "SELECT PGM(ISPSTRT)",
"PARM(CMD(%B '"SDFOUT"')"

*/

END
RETURN
UID = USERID()
DSN = UID'.SDFOUT.OUTLIST'
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"BROWSE DATASET('"DSN"') "
//PARASDB JOB (,42RJ,PARASD),'ORDER REPORT',
//
MSGCLASS=O,NOTIFY=PARASD
//REPORTS2 EXEC PGM=IKJEFT1B,
// PARM='PROG005'
//SYSTSPRT DD SYSOUT=*
//SYSTSIN DD DUMMY
//SYSEXEC DD DSN=PARASD.ISP.SYSEXEC,DISP=SHR
//*
//* INPUTS
//*
//ISFIN
DD DISP=SHR,DSN=PARASD.TEMP
//PARASDB JOB (,42RJ,PARASD),'ORDER REPORT',
//
MSGCLASS=O,NOTIFY=PARASD
//SCAN EXEC PGM=ISRLEMX,COND=(12,LE),
// PARM=('COB,SCOMP,B,N, ,4, ,00,ENU,4,7',
//
'1,/,SYSDA')
//*
//* INSERT A STEPLIB DD HERE IF ISRLEMX IS NOT IN YOUR SYSTEM LIBRARY
//*
//ISRLCODE DD DSN=PARASD.REXX.SRC,
// DISP=SHR
//ISRLEXPD DD UNIT=SYSDA,DISP=(NEW,PASS),SPACE=(CYL,(2,2)),
//
DSN=&&TEMP1
//ISRLMSG DD SYSOUT=(*)
//COBOL EXEC PGM=IGYCRCTL,REGION=640K,COND=(12,LE),
// PARM=(NOTERM,
// '')
//SYSPRINT DD SYSOUT=(*)
//SYSIN
DD DSN=&&TEMP1,DISP=(OLD,DELETE)
//SYSPUNCH DD DUMMY
//SYSUT1 DD UNIT=SYSDA,SPACE=(CYL,(2,2))
//SYSUT2 DD UNIT=SYSDA,SPACE=(CYL,(2,2))
//SYSUT3 DD UNIT=SYSDA,SPACE=(CYL,(2,2))
//SYSUT4 DD UNIT=SYSDA,SPACE=(CYL,(2,2))
//SYSUT5 DD UNIT=SYSDA,SPACE=(CYL,(2,2))
//SYSUT6 DD UNIT=SYSDA,SPACE=(CYL,(2,2))
//SYSUT7 DD UNIT=SYSDA,SPACE=(CYL,(2,2))
//SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR
//
DD DSN=PARASD.REXX.SRC,
// DISP=SHR
//SYSLIN DD DSN=PARASD.REXX.OBJ(SCOMP),

00810000
00820000
00830000
00840000
00850000
00860000
00861002
00862002
00862102
00862202
00862302
00862400
00863000
00980001
00001001
00002001
00030000
00040000
00050000
00000100
00000200

JOB04355

// DISP=OLD
//COMPILEA AAAAAAAAAAAAA
// NOTIFY=,
//PGMNAME=&SRCNAME
/*
REXX
*/
/* THIS IS AN INTERACTIVE REXX EXEC THAT ASKS A USER HIS NAME*/
/* AND THEN REPLIES HIM WITH A MESSAGE.
*/
SAY 'HELLO ?WHAT IS YOUR USERNAME? '
PULL USERNAME
IF USERNAME = '' THEN
/* IF USER DIDN'T ENTER A NAME */
SAY 'PLEASE ENTER YOUR USERNAME
'
ELSE
SAY WELCOME USERNAME
EXIT
/* REXX */
SIGNAL ON ERROR
CALL ALLOC
SAY "THE RESULT IS RETURN CODE" RESULT;
EXIT
ALLOC:
"ALLOC DA('"PARASD.EXEC1.SRC"') LIKE('"PARASD.REXX.SRC"')"
SAY 'DATASET ALLOCATED'
RETURN 0;
ERROR:
SAY 'THE RETURN CODE FROM THE COMMAND ON LINE' SIGL 'IS' RC
RETURN 'ABC';
//PARASDB JOB (,42RJ,PARASD),'ORDER REPORT',
00000100
//
MSGCLASS=O,NOTIFY=PARASD
00000200
//*ABCD
00000200
//COMPPDS DD DSN=&PDSNAME(&MEMNAME),DISP=SHR
00000200
//DELS1 EXEC PGM=IDCAMS
//SYSPRINT DD SYSOUT=*
//SYSIN DD *
DELETE 'PARASD.CPU.U1805264.BNCHMV51.CSV'
SET MAXCC = 0
/*
//XBNCH
EXEC PGM=IKJEFT1B
//SYSTSPRT DD SYSOUT=*
//SYSTSIN DD *
XBNCHDAT D46RD.U1805264.BNCHMV51
//SYSEXEC DD DSN=PARASD.DESIGN.SRC,DISP=SHR
//CPUDATA DD DSN=PARASD.CPU.U1805264.BNCHMV51.CSV,
// DISP=(,CATLG,DELETE),
// RECFM=VB,LRECL=99,BLKSIZE=0,STORCLAS=STANDARD,
// SPACE=(TRK,(10,5),RLSE)
/*********************************REXX**********************************
* EXECUTE A TSO COMMAND AND BROWSE THE OUTPUT
***********************************************************************/
TRACE "OFF"
CALL ON ERROR
ADDRESS ISPEXEC "CONTROL ERRORS RETURN"
CALL OUTTRAP "LINE."
ARG1 = "SUB ('PARASD.DESIGN.SRC(XXBNCH)')"
/* SUBMIT THE COMPILE JOB */
ADDRESS TSO ARG1
CALL OUTTRAP "OFF"
IF LINE.0 > 0
THEN DO

CMD_DD = "C"RANDOM()
"ALLOCATE FILE("CMD_DD") REUSE UNIT(SYSDA) SPACE(1 1)
CYLINDER DSORG(PS) RECFM(V B) LRECL(255)"
/* GET THE JOB NUMBER */
SAY LINE.0
POSJOB = POS("(",LINE.1)
JOBNMR = SUBSTR(LINE.1,5,POSJOB-5)
SAY JOBNMR
JOBID = SUBSTR(LINE.1,POSJOB+1,8)
SAY JOBID
/* "EXECIO" LINE.0 "DISKW" CMD_DD "(STEM LINE. FINIS)"



ADDRESS ISPEXEC "LMINIT DATAID(DATAID) DDNAME("CMD_DD")"
ADDRESS ISPEXEC "BROWSE DATAID("DATAID")"
ADDRESS ISPEXEC "LMFREE DATAID("DATAID")"
"FREE FILE("CMD_DD")"
*/
END
EXIT
ERROR:
ZERRSM = "RETURN CODE" RC
ZERRLM = "RETURN CODE FROM COMMAND IS" RC
ZERRALRM = "YES"
ZERRHM = "*"
ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
RETURN

