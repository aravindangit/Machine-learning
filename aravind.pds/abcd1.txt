VMEMBER NAME  ACF2TRAP
V/* REXX exec to trap ACFs 2 command responses */                        0001000
V8
V/* E.g. tso acf2trap L(IST) LIKE(JB-) IF(PROJ='BSP')                    0002000
V8
V        tso acf2trap L(IST) LIKE(-) IF(PROJ='BSP') name=yes             0003000
V8
V        tso acf2trap L(IST) LIKE(-) name=yes edit=yes                   0004000
V8
V    Specify name=<something> if you only want the name records          0005000
V8
V*/                                                                      0006000
V8
V                                                                        0007000
V8
Vparse arg parms                                                         0008000
V8
Vcmd = parmParse(parms)                                                  0009000
V8
Vif (args.edit = 'ARGS.EDIT') then args.edit = 'Y' /* Default */         0010000
V8
V                                                                        0011000
V8
VsearchString = args.search /* Set the search argument */                0012000
V8
Vif searchString = 'ARGS.SEARCH' then searchString = ''                  0013000
V8
VresultCount = 0 /* No lines found yet */                                0014000
V8
V                                                                        0015000
V8
V/* Push commands onto stack to be executed after we invoke acf2. */     0016000
V8
Vqueue cmd                                                               0017000
V8
Vqueue 'quit'                                                            0018000
V8
V                                                                        0019000
V8
VDontCare = Outtrap("CmdOut.")                                           0020000
V8
V   acf                                                                  0021000
V8
VDontCare = Outtrap("OFF") /* done now. */                               0022000
V8
V                                                                        0023000
V8
Vif CmdOut.0 < 1 then say "No lines captured"                            0024000
V8
V                                                                        0025000
V8
VresultCount = resultcount +1 /* Increment count of lines found.*/       0026000
V8
Vresult.resultCount = 'Results of command' cmd                           0027000
V8
V                                                                        0028000
V8
V/* Add message about SEARCH= if not specified. */                       0029000
V8
Vif (args.search = 'ARGS.SEARCH') then                                   0030000
V8
V   do                                                                   0031000
V8
V   resultCount = resultcount +1 /* Increment count of lines found.*/    0032000
V8
V   result.resultCount = 'Add SEARCH=<string> to filter results'         0033000
V8
V   end                                                                  0034000
V8
V                                                                        0035000
V8
V/* Add message about NAME= if not specified. */                         0036000
V8
Vif (args.name = 'ARGS.NAME') then                                       0037000
V8
V   do                                                                   0038000
V8
V   resultCount = resultcount +1 /* Increment count of lines found.*/    0039000
V8
V   result.resultCount = 'Add NAME=YES for name records only'            0040000
V8
V   end                                                                  0041000
V8
V                                                                        0042000
V8
V/* Add message about EDIT= if not specified. */                         0043000
V8
Vif (args.edit = 'ARGS.EDIT') then                                       0044000
V8
V   do                                                                   0045000
V8
V   resultCount = resultcount +1 /* Increment count of lines found.*/    0046000
V8
V   result.resultCount = 'Add EDIT=YES for editable results.'            0047000
V8
V   end                                                                  0048000
V8
V                                                                        0049000
V8
V/* Step through all trapped output line-by-line. If the line contains   0050000
V8
V   our seach string, add it to the result stem variable.                0051000
V8
V   If the name= parm was specified, then only list the 1 line of each   0052000
V8
V   user. We do this by seeing if the 1st word = the 6 chars at pos 31.  0053000
V8
V*/                                                                      0054000
V8
V                                                                        0055000
V8
Vdo i = 1 to cmdout.0                                                    0056000
V8
V                                                                        0057000
V8
V   /* Keep the 'invalid' or 'ambiguous command' message if issued */    0058000
V8
V   if (pos('ACF67001',cmdout.i) <> 0 ) then                             0059000
V8
V      do                                                                0060000
V8
V      resultCount = resultcount +1 /* Increment count of lines found.*/ 0061000
V8
V      result.resultCount = cmdout.i /* Add this line to result stem */  0062000
V8
V      end                                                               0063000
V8
V                                                                        0064000
V8
V   /* If we specified a value for the name=, (we only want the name     0065000
V8
V      records) and the 1st word doesn't match the chars at pos 31       0066000
V8
V      (this is a name record) then iterate. */                          0067000
V8
V   if (args.name <> 'ARGS.NAME') then                                   0068000
V8
V      do                                                                0069000
V8
V      fWord = word(cmdout.i,1) /* Might be a TSO ID */                  0070000
V8
V      sWord = word(cmdout.i,2) /* Might be acct. info */                0071000
V8
V                                                                        0072000
V8
V      if pos(substr(fWord,1,1),sWord) = 0 | ,                           0073000
V8
V           pos(substr(fWord,2,3),sWord) = 0 | ,                         0074000
V8
V             pos(substr(fWord,5,3),sWord) = 0 then iterate              0075000
V8
V      end                                                               0076000
V8
V  /*  word(cmdout.i,1) <>,                                              0077000
V8
V         substr(cmdout.i,31,length(word(cmdout.i,1))) then iterate */   0078000
V8
V                                                                        0079000
V8
V /* f isblank(cmdout.i) then iterate /* Ignore blank lines */ */        0080000
V8
V   if cmdout.i = '' then iterate /* Ignore blank lines */               0081000
V8
V                                                                        0082000
V8
V   /* If line contains search string/search string is blank, save it */ 0083000
V8
V   if (pos(searchString,cmdout.i) <> 0 ) |,                             0084000
V8
V          (searchString = '') then                                      0085000
V8
V      do                                                                0086000
V8
V      resultCount = resultcount +1 /* Increment count of lines found.*/ 0087000
V8
V      result.resultCount = cmdout.i /* Add this line to result stem */  0088000
V8
V      end                                                               0089000
V8
Vend                                                                     0090000
V8
V                                                                        0091000
V8
Vresult.0 = resultCount  /* Set count of lines found */                  0092000
V8
V                                                                        0093000
V8
V/* If we have result records, then edit or just print them */           0094000
V8
Vif result.0 > 0 then                                                    0095000
V8
V   do                                                                   0096000
V8
V   if args.edit <> 'ARGS.EDIT' then /* EDIT was specified */            0097000
V8
V      do                                                                0098000
V8
V      /* Put all ines found into a temporary data set and edit it. */   0099000
V8
V      ddnm = 'DD'||random(1,99999)    /* choose random ddname  */       0100000
V8
V      junk = msg(off)                                                   0101000
V8
V      "ALLOC FILE("||ddnm||") UNIT(VIO) NEW TRACKS SPACE(5,5) DELETE",  0102000
V8
V      " REUSE LRECL(140) RECFM(F B) BLKSIZE(8960)"                      0103000
V8
V      "EXECIO" result.0  "DISKW" ddnm "(STEM result. FINIS"             0104000
V8
V      address ISPEXEC "LMINIT DATAID(TEMP) DDNAME("||ddnm||")"          0105000
V8
V      address ISPEXEC "VIEW   DATAID("||temp")"                         0106000
V8
V      address ISPEXEC "LMFREE DATAID("||temp")"                         0107000
V8
V      junk = msg(off)                                                   0108000
V8
V      "FREE FI("||ddnm||")"                                             0109000
V8
V      end                                                               0110000
V8
V   else                                                                 0111000
V8
V      do i = 1 to result.0                                              0112000
V8
V      say result.i                                                      0113000
V8
V      end                                                               0114000
V8
V   end                                                                  0115000
V8
Velse say 'No lines to show'                                             0116000
V8
V                                                                        0117000
V8
Vexit(0)                                                                 0118000
V8
V                                                                        0119000
V8
V/* Parse a string, stripping any potential vriable assignments and      0120000
V8
V   assigning them.                                                      0121000
V8
V   e.g. parmParse('parm1 colour=red parm2 name=fred action=jumps parm5')0122000
V8
V   will return 'parm1 parm2 parm5' and set args.colour to 'red',        0123000
V8
V   args.name to 'fred' and args.action to 'jump'. It will also set      0124000
V8
V   args.stems to 'colour name action'                                   0125000
V8
V*/                                                                      0126000
V8
VparmParse:                                                              0127000
V8
V  parse arg args                                                        0128000
V8
V  args.stems = ''                                                       0129000
V8
V  do i = 1 to words(args)                                               0130000
V8
V     word = word(args,i)                                                0131000
V8
V     x = pos('=',word)                                                  0132000
V8
V/* If this parm contains '=' then assign the variable to the value */   0133000
V8
V     if x > 0 then                                                      0134000
V8
V        if datatype(left(word,x-1),'S') then                            0135000
V8
V           do                                                           0136000
V8
V           interpret 'args.'word(args,i)                                0137000
V8
V           /* Add this var to the list of vars we've created */         0138000
V8
V           args.stems = args.stems||' '||left(word(args,i),x-1)         0139000
V8
V           /* strip this word from the argument string */               0140000
V8
V           args = delword(args,i,1)                                     0141000
V8
V           i = i-1 /* Back up as we've deleted the current word */      0142000
V8
V           if i > words(args) then leave /* Gone off the end? */        0143000
V8
V           end                                                          0144000
V8
V  end                                                                   0145000
V8
V  return args                                                           0146000
V8
VMEMBER NAME  BGDG
V/* Language           : Rexx
V
V * Program Name       : BGDG
V
V * Description        : Build GDG bases, based on (+1) & (0) characters found
V
V *                    : in member being edited.
V
V * Input Parameters   : lim opt extra
V
V * Output Parameters  : on screen displayed
V
V * Panel Names        : none
V
V * Table Names        : none
V
V * Skeleton Names     : none
V
V * Macro Names        : none
V
V * Rexx Names         : none
V
V * Program Names      : none
V
V * Message Names      : Internal ZEDxMSG's
V
V * Execution Mode     : Macro
V
V * Procedure          : none
V
V * Batch Job Name     : none
V
V * Restrictions       : none
V
V * User               : all_users
V
V * Author             : Ken Balnave
V
V * Department         : JCL Management
V
V * Owner              : Ken Balnave - JCL Management
V
V * Created            : 6th December 2004
V
V * Status             : Test/Live
V
V * Modified as below  : Latest modification on top.
V
V *-----------------------------------------------------------------------------
V
V * Ken Balnave - 6th December 2004
V
V * 1: Initial coding.
V
V *-----------------------------------------------------------------------------
V
V ******************************************************************************
V/
V
V
VInitialise:
V
V  Address isredit "MACRO (lim opt extra)"
V
V  If lim = '' | opt = '' then Do
V
V    Say 'the parms are lim (for limit) and opt (TEST or NOTEST or TESTNO)'
V
V    Say 'eg : BGDG 3 NOTEST or BGDG 6 TEST'
V
V    Exit 4
V
V  End
V
V  opt = Translate(opt)
V
V  P1gdg_count = 0 ; Z0gdg_count = 0
V
V  dsn_list = ' '
V
V  zero_start = n
V
V  dup_count = 0
V
V
V
VExclude_And_Find_Plus1_Gens:
V
V  type = '(+1)'
V
V  "isredit exclude all"
V
V  "isredit CURSOR = 1 1"
V
V  "isredit find '(+' all"
V
V  "isredit x all '//*'"
V
V  Do until rc > 0
V
V    "isredit (line,col) = CURSOR"
V
V    "isredit (lineval) = LINE "line
V
V
V
V    dsn_pos     = Pos('DSN=',lineval) + 4
V
V    If dsn_pos  = 4 then Do
V
V      "isredit find '(+' nx"
V
V      Iterate
V
V    End
V
V    plus_one    = Pos('(+',lineval,dsn_pos)
V
V    If plus_one = -1 then Leave
V
V
V
V    dsn = Substr(lineval,dsn_pos,(plus_one-dsn_pos))
V
V    Call Check_Possible_Errors
V
V    If Pos(dsn,dsn_list) > 0 then Do
V
V      dup_count = dup_count + 1
V
V      "isredit find next nx 'DSN='"
V
V      If rc > 0 then Signal Exit
V
V      "isredit find next nx '(+'"
V
V      If rc > 0 then Signal Exit
V
V      Iterate
V
V    End
V
V    dsn_list = dsn_list' 'dsn
V
V    Call Check_Valid_File
V
V
V
V    "isredit find '(+' nx"
V
V  End
V
V
V
VExclude_And_Find_Zero_Gens:
V
V  If extra = '0' then Do
V
V    type = '(0)'
V
V    zero_start = y
V
V    "isredit FIND '//' FIRST"
V
V    "isredit reset"
V
V    "isredit exclude all"
V
V    "isredit CURSOR = 1 1"
V
V    "isredit find (0) all"
V
V    "isredit x all '//*'"
V
V    Do until rc > 0
V
V      "isredit (line,col) = CURSOR"
V
V      "isredit (lineval) = LINE "line
V
V
V
V      dsn_pos     = Pos('DSN=',lineval) + 4
V
V      If dsn_pos  = 4 then Do
V
V        "isredit find (0) nx"
V
V        Iterate
V
V      End
V
V      zero_pos    = Pos('(0)',lineval,dsn_pos)
V
V      If zero_pos = -1 then Leave
V
V
V
V      dsn = Substr(lineval,dsn_pos,(zero_pos-dsn_pos))
V
V      Call Check_Possible_Errors
V
V      If Pos(dsn,dsn_list) > 0 then Do
V
V        dup_count = dup_count + 1
V
V        "isredit find next nx 'DSN='"
V
V        If rc > 0 then Signal Exit
V
V        "isredit find next nx '(0)'"
V
V        If rc > 0 then Signal Exit
V
V        Iterate
V
V      End
V
V      dsn_list = dsn_list' 'dsn
V
V      Call Check_Valid_File
V
V
V
V      "isredit find (0) nx"
V
V    End
V
V  End
V
V
V
VExit:
V
V  Say Copies('=',75)
V
V  Say 'Summary of events'
V
V  If opt = 'NOTEST' | opt = 'TESTNO' then,
V
V     Say P1gdg_count "GDG bases",
V
V     "("P1gdg_count-Z0gdg_count" Plus1 & "Z0gdg_count" Zero) created"
V
V  If opt = 'TEST' then,
V
V     Say P1gdg_count "GDG bases",
V
V     "("P1gdg_count-Z0gdg_count" Plus1 & "Z0gdg_count" Zero)",
V
V     "will be created when you re-do with NOTEST"
V
V  If dup_count > 0 then Say dup_count' duplicates found and ignored'
V
V
V
V  "isredit FIND '//' FIRST"
V
V  "isredit reset"
V
V  exit 1
V
V
V
VCheck_Valid_File:
V
V  cdsn = "'"dsn"'"
V
V  listc_trap = Outtrap(listc.)
V
V  "listc ent("cdsn") gdg"
V
V  lc_rc = rc
V
V  listc_trap = Outtrap(off)
V
V
V
V  If lc_rc /= 0 then Do
V
V    P1gdg_count = P1gdg_count + 1
V
V    If zero_start = y then Z0gdg_count = Z0gdg_count +1
V
V    If opt = 'NOTEST' | opt = 'TESTNO' then Do
V
V      say_msg ='Building GDG base for 'dsn
V
V      say_msg = Overlay(type,say_msg,70)
V
V      Say say_msg
V
V      Address TSO "DEF GDG (NAME("cdsn") LIMIT("lim") SCRATCH)"
V
V      If rc /= 0 then Do
V
V        Say 'Error creating GDG base for 'dsn
V
V        Exit 16
V
V      End
V
V    End
V
V    If opt = 'TEST' then Do
V
V      say_msg = 'Simulating GDG base build for 'dsn
V
V      say_msg = Overlay(type,say_msg,70)
V
V      Say say_msg
V
V    End
V
V  End
V
V
V
V  Return
V
V
V
VCheck_Possible_Errors:
V
V  If Pos(',',dsn) > 0 | Pos('&',dsn) > 0 then Do
V
V    zedsmsg = 'Invalid chars  - line' Strip(line,L,'0')
V
V    zedlmsg = dsn' contains invalid characters. Please correct and re-try'
V
V    "ispexec setmsg msg (isrz001)"
V
V    Exit 4
V
V  End
V
V  If Length(dsn) > 35 then Do
V
V    zedsmsg = 'DSN tooooo long'
V
V    zedlmsg = dsn' is 'Length(dsn) - 35' characters too long'
V
V    "ispexec setmsg msg (isrz001)"
V
V    Exit 4
V
V  End
V
V
V
V  Return
V
V
V
VMEMBER NAME  CCI
V/* REXX */                                                              0001000
V0
VISPEXEC VGET (ZUSER)                                                    0002000
V0
V"ISREDIT MACRO"                                                         0003000
V0
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                  0004000
V0
V"'//SYSIN    DD *'"                                                     0005000
V0
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                  0006000
V0
V"'//OUTDD    DD SYSOUT=*'"                                              0007000
V0
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                  0008000
V0
V"'//ERRORS   DD SYSOUT=*'"                                              0009000
V0
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                  0010000
V0
V"'//SYSPRINT DD SYSOUT=*'"                                              0011000
V0
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                  0012000
V0
V"'//         PARM='CCIIND2,CA71,,,OUTDD''"                              0013000
V2
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                  0014000
V0
V"'//STEP01   EXEC PGM=CAL2X2WB,'"                                       0015000
V0
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                  0016000
V0
V"'//*'"                                                                 0017000
V0
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                  0018000
V0
V"'//&ZUSER.B JOB (0000,OPER),ANYJOB,MSGCLASS=0,CLASS=I'"                0019000
V1
V"ISREDIT LINE_AFTER .ZL = DATALINE ",                                   0020000
V0
V"'/*'"                                                                  0021000
V0
VMEMBER NAME  CICDAILY
V/* Rexx - CICDAILY edit macro.                                  */      0001000
V0
V/* Filter a CICS log down to short of storage & stress messages */      0002000
V0
V/*--------------------------------------------------------------*/      0003000
V0
V                                                                        0004000
V0
VAddress isredit                                                         0005000
V0
V"MACRO"                                                                 0006000
V0
V/* Hide everything */                                                   0007000
V0
V"x all"                                                                 0008000
V0
V"hide x"                                                                0009000
V0
V                                                                        0010000
V0
V/* Find relevant messages */                                            0011000
V0
V"f 'under stress' all"                                                  0012000
V0
V"f 'short on storage' all"                                              0013000
V0
V/* "f ' ABEND ' all"   */                                               0014000
V0
V"f DFHSR0001 all"                                                       0015000
V0
V"f DFHAC2236 all"                                                       0016000
V0
V                                                                        0017000
V0
V"x 0C7 all"   /* Hide app abends */                                     0018000
V0
V"x all r'ABEND.+0C4.+FALC040'"                                          0019000
V0
V                                                                        0020000
V0
V/* Go to the end of the log */                                          0021000
V0
V"down m"                                                                0022000
V0
V                                                                        0023000
V0
V/* Find the start of the current day */                                 0024000
V0
V"f ' ---- ' 18 last"                                                    0025000
V0
Vexit 1                       /* Reset cursor to command line   */       0026000
V0
VMEMBER NAME  DELDUPE
V/* Rexx - DELDUPE edit macro.                                  */       0001000
V1
V/* Remove duplicates from columns i-j (i,j are parameters)     */       0002000
V1
V/* if i and j are not specified, they default to 1 and width.  */       0003000
V1
V/* If only i is specified, j defaults to width.                */       0004000
V1
V/*-------------------------------------------------------------*/       0005000
V1
V/* Lines containing duplicates will end up excluded. Uee the   */       0006000
V1
V/* 'flip' command to show them or 'delete all x' to remove them*/       0007000
V1
V/*-------------------------------------------------------------*/       0008000
V1
VAddress isredit                                                         0009000
V1
V"MACRO (LCOL,RCOL)"          /* Indicate macro with 2 parms    */       0010000
V1
V"(DW) = DATA_WIDTH"          /* Get maximum data width         */       0011000
V1
V"(LAST) = LINENUM .ZLAST"    /* Get number of last line        */       0012000
V1
V"RESET X"                    /* Un-Exclude all lines           */       0013000
V1
Vif datatype(lcol,'N')=0 then lcol=1  /* Set left column        */       0014000
V1
Vif datatype(rcol,'N')=0 then rcol = dw /* Right col  */                 0015000
V1
Vlen=abs(rcol-lcol)+1         /* Get length of compare area     */       0016000
V1
Vlcol=min(lcol,rcol)          /* Get left col                   */       0017000
V1
Vdo linenum = 1 to last       /* Loop through all lines         */       0018000
V1
V  "(LINE) = LINE "linenum    /* Place line data in 'line'      */       0019000
V1
V  test=substr(line,lcol,len) /* Take just columns to compare   */       0020000
V1
V  if test = testold then     /* Compare against previous line  */       0021000
V1
V    "XSTATUS "linenum" = X"          /* If match, exclude line */       0022000
V1
V  testold = test             /* Save current line compare area */       0023000
V1
Vend                          /*                                */       0024000
V1
Vexit 1                       /* Reset cursor to command line   */       0025000
V1
VMEMBER NAME  EGDG
V/* Language           : Rexx
V
V * Program Name       : EGDG
V
V * Description        : Build GDG bases, based on list of file names
V
V *                    : in member being edited.
V
V * Input Parameters   : lim opt extra
V
V * Output Parameters  : on screen displayed
V
V * Panel Names        : none
V
V * Table Names        : none
V
V * Skeleton Names     : none
V
V * Macro Names        : none
V
V * Rexx Names         : none
V
V * Program Names      : none
V
V * Message Names      : Internal ZEDxMSG's
V
V * Execution Mode     : Macro
V
V * Procedure          : none
V
V * Batch Job Name     : none
V
V * Restrictions       : none
V
V * User               : all_users
V
V * Author             : Stuart Dolman
V
V * Department         : JCL Management
V
V * Owner              : Stuart Dolman - JCL Management
V
V * Created            : November 2015
V
V * Status             : Test/Live
V
V * Modified as below  : Latest modification on top.
V
V *-----------------------------------------------------------------------------
V
V * Stuart Dolman - November 2015 (bodged from Mr Balnave BGDG)
V
V * 1: Initial coding.
V
V *-----------------------------------------------------------------------------
V
V ******************************************************************************
V/
V
V
VInitialise:
V
V  Address isredit "MACRO (lim opt extra)"
V
V  If lim = '' | opt = '' then Do
V
V    Say 'the parms are lim (for limit) and opt (TEST or NOTEST or TESTNO)'
V
V    Say 'eg : EGDG 3 NOTEST or EGDG 6 TEST'
V
V    Exit 4
V
V  End
V
V  opt = Translate(opt)
V
V  P1gdg_count = 0 ; Z0gdg_count = 0
V
V  dsn_list = ' '
V
V  zero_start = n
V
V  dup_count = 0
V
V  type = '(+1)'
V
V
V
VExclude_And_Find_Plus1_Gens:
V
V  "isredit CURSOR = 1 1"
V
V  Do until rc > 0
V
V    "isredit (line,col) = CURSOR"
V
V    "isredit (lineval) = LINE "line
V
V    dsn = strip(lineval)
V
V    Call Check_Possible_Errors
V
V    If Pos(dsn,dsn_list) > 0 then Do
V
V      dup_count = dup_count + 1
V
V      "isredit find next '@'p 1 1"
V
V      If rc > 0 then Signal Exit
V
V/*    "isredit find next nx '(+'"
V
V      If rc > 0 then Signal Exit */
V
V      Iterate
V
V    End
V
V    dsn_list = dsn_list' 'dsn
V
V    Call Check_Valid_File
V
V
V
V    "isredit find '@'p 1 1"
V
V  End
V
V
V
V
V
VExit:
V
V  Say Copies('=',75)
V
V  Say 'Summary of events'
V
V  If opt = 'NOTEST' | opt = 'TESTNO' then,
V
V     Say P1gdg_count "GDG bases",
V
V     "("P1gdg_count-Z0gdg_count" Plus1 & "Z0gdg_count" Zero) created"
V
V  If opt = 'TEST' then,
V
V     Say P1gdg_count "GDG bases",
V
V     "("P1gdg_count-Z0gdg_count" Plus1 & "Z0gdg_count" Zero)",
V
V     "will be created when you re-do with NOTEST"
V
V  If dup_count > 0 then Say dup_count' duplicates found and ignored'
V
V
V
V  "isredit FIND '//' FIRST"
V
V  "isredit reset"
V
V  exit 1
V
V
V
VCheck_Valid_File:
V
V  cdsn = "'"dsn"'"
V
V  listc_trap = Outtrap(listc.)
V
V  "listc ent("cdsn") gdg"
V
V  lc_rc = rc
V
V  listc_trap = Outtrap(off)
V
V
V
V  If lc_rc /= 0 then Do
V
V    P1gdg_count = P1gdg_count + 1
V
V    If zero_start = y then Z0gdg_count = Z0gdg_count +1
V
V    If opt = 'NOTEST' | opt = 'TESTNO' then Do
V
V      say_msg ='Building GDG base for 'dsn
V
V      say_msg = Overlay(type,say_msg,70)
V
V      Say say_msg
V
V      Address TSO "DEF GDG (NAME("cdsn") LIMIT("lim") SCRATCH)"
V
V      If rc /= 0 then Do
V
V        Say 'Error creating GDG base for 'dsn
V
V        Exit 16
V
V      End
V
V    End
V
V    If opt = 'TEST' then Do
V
V      say_msg = 'Simulating GDG base build for 'dsn
V
V      say_msg = Overlay(type,say_msg,70)
V
V      Say say_msg
V
V    End
V
V  End
V
V
V
V  Return
V
V
V
VCheck_Possible_Errors:
V
V  If Pos(',',dsn) > 0 | Pos('&',dsn) > 0 then Do
V
V    zedsmsg = 'Invalid chars  - line' Strip(line,L,'0')
V
V    zedlmsg = dsn' contains invalid characters. Please correct and re-try'
V
V    "ispexec setmsg msg (isrz001)"
V
V    Exit 4
V
V  End
V
V  If Length(dsn) > 35 then Do
V
V    zedsmsg = 'DSN tooooo long'
V
V    zedlmsg = dsn' is 'Length(dsn) - 35' characters too long'
V
V    "ispexec setmsg msg (isrz001)"
V
V    Exit 4
V
V  End
V
V
V
V  Return
V
V
V
VMEMBER NAME  ISPFHTML
V/* REXX */                                                              0001000
V2
Vcaption = "This is an ISPF screen capture"                              0002000
V2
Vaddress ispexec                                                         0003000
V2
V"vput (caption) shared"                                                 0004000
V2
V"libdef ispllib dataset id('jocs065.ispfhtml.load')"                    0005000
V2
V"select pgm(ispfhtml) parm(download)"                                   0006000
V2
V"libdef ispllib"                                                        0007000
V2
V"vget (zwscon zuser)"                                                   0008000
V2
Vif zwscon = '' then /* if no wkstn connection */                        0009000
V2
V  "browse dataset(ispfcap.htm)" /* Browse output */                     0010000
V2
VMEMBER NAME  JDATE
V/* REXX */                                                              0001000
V0
V    zedlmsg = 'Today''s Julian date is' DATE('J')                       0002000
V0
V  address ispexec                                                       0003000
V0
V  "setmsg msg(isrz001)"                                                 0004000
V0
VMEMBER NAME  RAPIT
V/* REXX */
V
VISPEXEC VGET (ZUSER)
V
V"ISREDIT MACRO"
V
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",
V
V"'//SYSUT1   DD DATA,DLM=ZZ'"
V
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",
V
V"'//SYSIN    DD DUMMY'"
V
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",
V
V"'//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6400)'"
V
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",
V
V"'//SYSUT2   DD DSN=&&&&&&&&ACF2,DISP=(,CATLG),SPACE=(TRK,2),UNIT=SYSDA,'"
V
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",
V
V"'//SYSPRINT DD SYSOUT=Z'"
V
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",
V
V"'//COPY1  EXEC PGM=IEBGENER'"
V
V"ISREDIT LINE_BEFORE .ZF = DATALINE ",
V
V"'//&ZUSER.Z JOB (7248,SPR1),MSGCLASS=Z,PRTY=7,CLASS=I'"
V
V"ISREDIT LINE_AFTER .ZL = DATALINE ",
V
V"'ZZ'"
V
V"ISREDIT LINE_AFTER .ZL = DATALINE ",
V
V"'//*'"
V
V"ISREDIT LINE_AFTER .ZL = DATALINE ",
V
V"'//SUBMIT   EXEC PGM=JOBCOPY'"
V
V"ISREDIT LINE_AFTER .ZL = DATALINE ",
V
V"'//STEPLIB  DD  DSN=ACF2.JOBCOPY,DISP=SHR'"
V
V"ISREDIT LINE_AFTER .ZL = DATALINE ",
V
V"'//SYSUT1   DD  DSN=&&&&&&&&ACF2,DISP=(OLD,DELETE)'"
V
V"ISREDIT LINE_AFTER .ZL = DATALINE ",
V
V"'//SYSUT2   DD  SYSOUT=(A,INTRDR),DCB=(BLKSIZE=80,LRECL=80,RECFM=F)'"
V
VMEMBER NAME  SITEST
V/* REXX */                                                              0000100
V0
V    msg.jobname = T$SYS10Z                                              0000110
V4
V    msg.userid = 'JOCS065'                                              0000120
V4
V                                                                        0000200
V0
V    ROOTSYS = 'Z580'        /* system where the RDF table lives */      0003000
V0
V                                                                        0004000
V0
V    /* Jobnames and users treated as generic i.e. with * on end. ''     0005001
V5
V       matches all */                                                   0005101
V5
V    MONITORED_USERS = 'FR'                                              0006001
V7
V    MONITORED_JOBS = 'T$S'                                              0007000
V8
V                                                                        0018000
V0
V/* End of INIT */                                                       0019000
V0
V                                                                        0020001
V3
Vsay 'Blank check = ' pos('','fred')                                     0021001
V3
V                                                                        0021500
V7
V if MONITORED_USERS <> '' & pos(MONITORED_USERS, msg.userid) <> 1,      0023201
V4
V         then say 'No user match'                                       0023401
V8
V if MONITORED_JOBS <> '' & pos(MONITORED_JOBS, msg.jobname) <> 1,       0023501
V8
V      then say 'No job match'                                           0025101
V8
V                                                                        0025300
V9
Vsay "check if jobname contains mask :" pos(MONITORED_USERS, msg.userid) 0025400
V9
V                                                                        0026000
V0
VMEMBER NAME  SRCHFILT
V/* Rexx - SRCHFILT edit macro.                                 */       0001000
V0
VAddress isredit                                                         0009000
V0
V"MACRO"                                                                 0010000
V0
V"X ALL"                       /* Exclude all lines           */         0013100
V0
V"F FOUND 50 ALL"                                                        0013200
V0
V"F DSN: ALL"                                                            0013300
V0
V"HIDE X"                                                                0013400
V0
Vexit 1                       /* Reset cursor to command line   */       0025000
V0
VMEMBER NAME  SUFFIX
V/*************************  REXX  *************************************/
V
V/**     EDIT MACRO.     05/02/2002.                                  **/
V
V/**     SUFFIX EACH LINE IN A DATASET WITH A USER SUPPLIED STRING    **/
V
V/**********************************************************************/
V
V'ISREDIT MACRO (SUFFIX)'                  /* START THE MACRO          */
V
VIF SUFFIX = "" THEN DO                    /* IF NO PARM HAS BEEN      */
V
V   ZEDSMSG = ' NO SUFFIX ENTERED '        /* SUPPLIED THEN FINISH     */
V
V   ADDRESS ISPEXEC                        /* WITH A SHORT MESSAGE     */
V
V   'SETMSG MSG(ISRZ001)'
V
V   EXIT
V
VEND
V
V
V
V
V
VSUFFIX = STRIP(SUFFIX,B,'"')              /* IF THE SUFFIX STRING HAS */
V
V                                          /* SPACES IT SHOULD BE      */
V
V                                          /* WRAPPED IN DOUBLE QUOTES */
V
V                                          /* STRIP THEM OFF           */
V
V
V
V'ISREDIT (FIRST) = LINENUM .ZFIRST'       /* FIND THE LINE NUMBER OF  */
V
V'ISREDIT (LAST)  = LINENUM .ZLAST'        /* THE FIRST AND LAST LINES */
V
V'ISREDIT (RECLEN) = LRECL'                /* AND THE RECORD LENGTH    */
V
V
V
V
V
VDO I = FIRST TO LAST                      /* MAIN LOOP:               */
V
V   'ISREDIT (LINEDATA ) = LINE ' I        /* THE SUFFIXED LINE IS     */
V
V   STRIPPED= STRIP(LINEDATA,T)            /* CREATED BY READING THE   */
V
V   NUM=LENGTH(STRIPPED)                   /* CURRENT LINE, REMOVING   */
V
V   NEWLINE=OVERLAY(SUFFIX,STRIPPED,NUM+1) /* TRAILING BLANKS AND THEN */
V
V   NEWLEN=LENGTH(NEWLINE)                 /* APPENDING THE SUFFIX     */
V
V   IF NEWLEN > RECLEN                     /* IF THE NEWLINE IS LONGER */
V
V   THEN ERRCODE=99                        /* THAN THE PHYSICAL        */
V
V   ELSE                                   /* SET ERRCODE TO 99        */
V
V   'ISREDIT LINE ' I '  =  (NEWLINE)'     /* IF LINE IS OK THEN WRITE */
V
V   END                                    /* NEW LINE                 */
V
V
V
V
V
V                                          /* CHECK TO SEE IF THE      */
V
V   IF ERRCODE=99 THEN DO                  /* RETURN CODE HAS BEEN SET */
V
V   ZEDSMSG = ' NOT ALL LINES SUFFIXED'    /* AND RETURN SOME MESSAGES */
V
V   ZEDLMSG = ' SUFFIX TOO LONG FOR SOME RECORDS '
V
V   ADDRESS ISPEXEC
V
V   'SETMSG MSG(ISRZ001)'
V
V   END
V
V
V
VEXIT
V
VMEMBER NAME  TSOE
V/* REXX */
V
V/*                           */
V
V/* AUTHOR: MARK ZELDEN       */
V
V/*                           */
V
V/* TRACE ?I */
V
VARG TSOCMD
V
VADDRESS ISPEXEC "CONTROL ERRORS RETURN"
V
VADDRESS TSO
V
VDDNM = 'DD'||RANDOM(1,99999)    /* CHOOSE RANDOM DDNAME  */
V
VJUNK = MSG(OFF)
V
V"ALLOC FILE("||DDNM||") UNIT(VIO) NEW TRACKS SPACE(5,5) DELETE",
V
V" REUSE LRECL(140) RECFM(F B) BLKSIZE(8960)"
V
VJUNK = MSG(ON)
V
V/*                                    */
V
V/*  ISSUE TSO COMMND AND TRAP OUTPUT  */
V
V/*                                    */
V
VJUNK=OUTTRAP(LINE.)
V
VTSOCMD
V
VJUNK=OUTTRAP('OFF')
V
V/*                                    */
V
V"EXECIO" LINE.0  "DISKW" DDNM "(STEM LINE. FINIS"
V
VADDRESS ISPEXEC "LMINIT DATAID(TEMP) DDNAME("||DDNM||")"
V
VADDRESS ISPEXEC "EDIT   DATAID("||TEMP")"
V
VADDRESS ISPEXEC "LMFREE DATAID("||TEMP")"
V
VJUNK = MSG(OFF)
V
V"FREE FI("||DDNM||")"
V
VMEMBER NAME  VCURSOR
V/* REXX exec to do cursor sensitive data extraction from an ISPF     */ 0038000
V0
V/*      Screen.                                                      */ 0039000
V0
V/*      Uses undocumented/Unsupported variables zscreeni & Zscreenc  */ 0040000
V0
V/*      available in ISPF for OS/390 R2.5 (ISPF4.5).                 */ 0041000
V0
V/*                                                                   */ 0042000
V0
V/*------------------------------------------------------------------ */ 0043000
V0
V/* ---> NOTE: ZSCREENI and ZSCREENC may give odd results in some     */ 0044000
V0
V/* --->       situations such as command line at the bottom!!!!      */ 0045000
V0
V/* --->       If this is a problem, force a call to subroutine       */ 0046000
V0
V/* --->       GET_ZSCREEN_VALUES instead of using ISPF's variables.  */ 0047000
V0
V/*------------------------------------------------------------------ */ 0048000
V0
V/*                                                                   */ 0049000
V0
V/*      Screen image may translate attr bytes to dsn chars causing   */ 0050000
V0
V/*      extra characters like '#' to be added to the dsname          */ 0051000
V0
V/*                                                                   */ 0052000
V0
V/*      Will not work in popups if invoked with the SUSPEND keyword. */ 0053000
V0
V/*      Note that the default command table entry for TSO does have  */ 0054000
V0
V/*      the SUSPEND keyword.                                         */ 0055000
V0
V/*                                                                   */ 0056000
V0
V/*      Usage:                                                       */ 0057000
V0
V/*        Name this VCURSOR, set a pfkey to VCURSOR and              */ 0058000
V0
V/*        create a command table entry:                              */ 0059000
V0
V/*            VCURSOR   0  SELECT CMD(%VCURSOR)                      */ 0060000
V0
V/*        (Or setting pfkey to TSO %VCURSOR will work in most cases) */ 0061000
V0
V/*        Then place cursor on dsname and press the pf key.          */ 0062000
V0
V/*        ZSCREENC may be wrong if initial command doesn't start     */ 0063000
V0
V/*        with a percent or have MODE(FSCR) on the SELECT statement. */ 0064000
V0
V/*                                                                   */ 0065000
V0
V/*      Author : Doug Nadel  April 24, 1999                          */ 0066000
V0
V/*      Updates: Apr 26, 1999 now views PDS members also.            */ 0067000
V0
V/*               Aug 18, Allow dsname in parentheses.                */ 0068000
V0
V/*                       Added additional information re MODE(FSCR). */ 0069000
V0
V/*                       Bypass ZSCREENI and ZSCREENC if needed.     */ 0070000
V0
V/*                       (ISPF version <4.5 but will work in 4.5+)   */ 0071000
V0
V/*               March 31, 2000 Added basic recognition of GDG names */ 0072000
V0
V/*                              and view/edit/browse customization   */ 0073000
V0
V/*               April 3, 2000  Added prompt panel.                  */ 0074000
V0
V/*------------------------------------------------------------------ */ 0075000
V0
V/*       Customization to set service to view edit or browse         */ 0076000
V0
V/*       or to use prompt panel.                                     */ 0077000
V0
V/*------------------------------------------------------------------ */ 0078000
V0
Vservice='PROMPT'                     /* set to VIEW, EDIT, or BROWSE */ 0079000
V0
V                                     /* or PROMPT.                   */ 0080000
V0
V/*------------------------------------------------------------------ */ 0081000
V0
VAddress ispexec                                                         0082000
V0
V'VGET (ZSCREENI,ZSCREENC,ZENVIR)'      /* Extract screen image,         0083000
V0
V                                          cursor pos and ISPF level  */ 0084000
V0
VIf substr(zenvir,5,4) <4.5 Then                                         0085000
V0
V  Call get_zscreen_values                                               0086000
V0
Vtrtable='abcdefghijklmnopqrstuvwxyz'   /* Setup valid dsname chars   */ 0087000
V0
Vtrtable=trtable||translate(trtable)||'¢#@0123456789.''-{()'             0088000
V0
Vtrtable=translate(xrange('00'x,'FF'x),,trtable,' ')                     0089000
V0
Vzscreeni=translate(zscreeni,,trtable,' ') /* Remove non-Dsn chars    */ 0090000
V0
VIf substr(zscreeni,zscreenc+1,1) <> ' ' Then /* Maybe csr on dsn     */ 0091000
V0
V  Do                                   /* Extract dsn from screen image 0092000
V0
V                                          and view dataset           */ 0093000
V0
V    name=word(substr(zscreeni,1+lastpos(' ',zscreeni,zscreenc)),1)      0094000
V0
V    name=translate(strip(substr(name,1,56))) /* Max of 56 char name  */ 0095000
V0
V    If substr(name,1,1)='(' Then                                        0096000
V0
V      Parse Var name '('name')'.                                        0097000
V0
V    Parse Var name dsn '('mem')'       /* Is there a member name?    */ 0098000
V0
V    omem=mem                                                            0099000
V0
V    If mem<>'' Then                    /* If so, reformat for view      0100000
V0
V                                          cmd                        */ 0101000
V0
V      Do                                                                0102000
V0
V        gdg=0                                                           0103000
V0
V        name=dsn                       /* Get dsn                    */ 0104000
V0
V        If substr(name,1,1)='''' Then  /* if original name started with 0105000
V0
V                                          quotes                     */ 0106000
V0
V          name=name''''                /* Fix quotes                 */ 0107000
V0
V        If datatype(mem,'N') = 1 Then  /* Gdg?                       */ 0108000
V0
V          Do                                                            0109000
V0
V            Drop otrap.                                                 0110000
V0
V            Call outtrap 'otrap.'                                       0111000
V0
V            Address tso 'LISTCAT ENT('name')' /* Get real gdg names  */ 0112000
V0
V            Call outtrap 'OFF'                                          0113000
V0
V            If otrap.0>(2-2*mem) Then  /* If enough lines returned   */ 0114000
V0
V              Do                                                        0115000
V0
V                a=otrap.0-1+2*mem      /* Parse listcat output       */ 0116000
V0
V                n="'"subword(otrap.a,3,1)"'" /* Get real dsname      */ 0117000
V0
V                If sysdsn(n)='OK' Then /* Verify that ds exists      */ 0118000
V0
V                  Do                   /* If real gdg name exists    */ 0119000
V0
V                    name=n             /* Use rea name as dsname     */ 0120000
V0
V                    mem=''             /* Forget the member name     */ 0121000
V0
V                    omem=''            /* Forget the member name     */ 0122000
V0
V                    gdg=1              /* Indicate we forgot member     0123000
V0
V                                          name                       */ 0124000
V0
V                  End                                                   0125000
V0
V              End                                                       0126000
V0
V          End                                                           0127000
V0
V        If gdg=0 Then                  /* If gdg check failed        */ 0128000
V0
V          mem='MEMBER('mem')'          /* Add member keyword for view*/ 0129000
V0
V      End                                                               0130000
V0
V    'CONTROL ERRORS RETURN'            /* Return errors to program   */ 0131000
V0
V    'LMINIT DATAID(VCURSOR) DATASET('name')' /* Alloc w/ Tso naming  */ 0132000
V0
V    If rc>0 & substr(name,1,1) <> "'" Then /* Alloc w/O tso name     */ 0133000
V0
V      'LMINIT DATAID(VCURSOR) DATASET('''name''')'                      0134000
V0
V    If rc=0 Then                                                        0135000
V0
V      Do                                                                0136000
V0
V        service=translate(service)                                      0137000
V0
V        If service='PROMPT' Then                                        0138000
V0
V          Call getservice                                               0139000
V0
V        If service<>"" Then                                             0140000
V0
V        service 'DATAID('vcursor')' mem    /* View the dataset     */   0141000
V0
V      End                                                               0142000
V0
V    Else                               /* Allocs failed: Set original   0143000
V0
V                                          message                    */ 0144000
V0
V      'LMINIT DATAID(VCURSOR) DATASET('name')'                          0145000
V0
V    If rc>7 Then                                                        0146000
V0
V      'SETMSG MSG(ISRZ002)'            /* If error, show messages    */ 0147000
V0
V    'LMFREE DATAID(&VCURSOR)'          /* Free ds if allocated       */ 0148000
V0
V  End                                                                   0149000
V0
VElse                                   /* Cursor was not on a dsname */ 0150000
V0
V  Do                                   /* Give user an error message */ 0151000
V0
V    zerrsm = 'Invalid cursor position'                                  0152000
V0
V    Parse Value '* YES The cursor was not on a data set name.',         0153000
V0
V      With zerrhm zerralrm zerrlm                                       0154000
V0
V    'SETMSG MSG(ISRZ002)'                                               0155000
V0
V  End                                                                   0156000
V0
VExit 0                                                                  0157000
V0
Vget_zscreen_values:                    /* obtain the screen image    */ 0158000
V0
VAddress ispexec 'VGET (ZSCREENW,ZSCREEND)'                              0159000
V0
Vp = ptr(96+ptr(ptr(24+ptr(112+ptr(132+ptr(540))))))                     0160000
V0
Vzscreeni=translate(storage(d2x(p),,                                     0161000
V0
V  zscreenw*zscreend),,xrange('00'x,'3f'x))                              0162000
V0
Vzscreenc = c2d(storage(,                                                0163000
V0
V  d2x(164+ptr(ptr(24+ptr(112+ptr(132+ptr(540)))))),4))                  0164000
V0
VReturn                                                                  0165000
V0
Vptr:  Return c2d(bitand(storage(d2x(Arg(1)),4),'7FFFFFFF'x))            0166000
V0
Vgetservice: Procedure Expose service name omem                          0167000
V0
V'VGET ZSCREEN'                                                          0168000
V0
Vservice='EDIT'                                                          0169000
V0
Vdsn=name                                                                0170000
V0
VParse Source  . . me .                                                  0171000
V0
VIf omem <> "" Then                                                      0172000
V0
V  Do                                                                    0173000
V0
V   If substr(dsn,1,1)='''' Then                                         0174000
V0
V     dsn=substr(dsn,1,length(dsn)-1)'('omem')'''                        0175000
V0
V   Else                                                                 0176000
V0
V     dsn=dsn'('omem')'                                                  0177000
V0
V  End                                                                   0178000
V0
VAddress tso                                                             0179000
V0
Vddname='¢VCSR¢'zscreen                                                  0180000
V0
V'alloc f('ddname') reuse new del dso(po) dir(1) sp(1)' ,                0181000
V0
V  'track recfm(f b) lrecl(80)'                                          0182000
V0
VAddress ispexec                                                         0183000
V0
V'LMINIT DATAID(DID) DDNAME('ddname') ENQ(EXCLU)'                        0184000
V0
V'LMOPEN DATAID(&DID) OPTION(OUTPUT)'                                    0185000
V0
VCall write ")ATTR"                                                      0186000
V0
VCall write "+ TYPE(NT)"                                                 0187000
V0
VCall write "@ TYPE(PT)"                                                 0188000
V0
VCall write "? TYPE(CH)"                                                 0189000
V0
VCall write "# TYPE(output) just(asis) caps(off)"                        0190000
V0
VCall write ")BODY WINDOW(60,14)"                                        0191000
V0
VCall write "                  @Cursor Sensitive Action+"                0192000
V0
VCall write "+%"                                                         0193000
V0
VCall write "+Dataset:+&DSN"                                             0194000
V0
VCall write "+"                                                          0195000
V0
VCall write "?  Select action:"                                          0196000
V0
VCall write "      _Z% 1. Edit"                                          0197000
V0
VCall write "     %#VCAXXY      +"                                       0198000
V0
VCall write "     %#VCAXXZ      +"                                       0199000
V0
VCall write " "                                                          0200000
V0
VCall write "? Press%END?to cancel this action."                         0201000
V0
VCall write " "                                                          0202000
V0
VCall write "? To avoid this panel, modify your "me" exec."              0203000
V0
VCall write ")INIT"                                                      0204000
V0
VCall write " VGET (VCACTNX) PROFILE"                                    0205000
V0
VCall write " .ZVARS = 'VCACTNX'"                                        0206000
V0
VCall write " &VCAXXY = '   2. View'"                                    0207000
V0
VCall write " &VCAXXZ = '   3. Browse'"                                  0208000
V0
VCall write ")REINIT"                                                    0209000
V0
VCall write " REFRESH(*)"                                                0210000
V0
VCall write ")PROC"                                                      0211000
V0
VCall write " IF (.CURSOR = VCAXXY) &VCACTNX = '2' /* allow csr selct*/" 0212000
V0
VCall write " IF (.CURSOR = VCAXXZ) &VCACTNX = '3'"                      0213000
V0
VCall write " VER (&VCACTNX, NB ,LIST,1,2,3)"                            0214000
V0
VCall write " IF (.MSG NE &Z) &VCACTNX=1"                                0215000
V0
VCall write " VPUT (VCACTNX) PROFILE"                                    0216000
V0
VCall write ")END"                                                       0217000
V0
V'LMMADD DATAID(&DID) MEMBER(FOO)'                                       0218000
V0
V'LMFREE DATAID(&DID)'                                                   0219000
V0
V'LIBDEF ISPPLIB LIBRARY ID('ddname')'                                   0220000
V0
V'ADDPOP'                                                                0221000
V0
V'DISPLAY PANEL(FOO)'                                                    0222000
V0
VIf rc>0 Then service=""                                                 0223000
V0
VElse If vcactnx=2 Then service='VIEW'                                   0224000
V0
VElse If vcactnx=3 Then service='BROWSE'                                 0225000
V0
V'REMPOP'                                                                0226000
V0
V'LIBDEF ISPPLIB'                                                        0227000
V0
VAddress tso                                                             0228000
V0
V'FREE F('ddname')'                                                      0229000
V0
VReturn                                                                  0230000
V0
Vwrite:                                                                  0231000
V0
VParse Arg p1                                                            0232000
V0
V"LMPUT DATAID(&DID) MODE(INVAR) DATALOC(P1) DATALEN(80)"                0233000
V0
VReturn                                                                  0234000
V0
VMEMBER NAME  ZOOME
V/* REXX */                                                              0001000
V0
Vaddress ispexec                                                         0002000
V0
V /*****************************************************************/    0003000
V0
V /* Type 'zoome' on the command line and then place your cursor on*/    0004000
V0
V /* a line of JCL contianing DSN= or PATH=. You will then be taken*/    0005000
V0
V /* into ISPF VIEW on that dataset or PATH.                       */    0006000
V0
V /*                                                               */    0007000
V0
V /* Even more useful if you assign ZOOME to a PF key, so you can  */    0008000
V0
V /* place your cursor and just hit the PF key.                    */    0009000
V0
V /*                                                               */    0010000
V0
V /* Extended from original 'ZOOM' macro to handle PATH=, ORDER=   */    0011000
V0
V /*****************************************************************/    0012000
V0
V    "ISREDIT MACRO"                   /* Required */                    0013000
V0
V    "isredit (row,col) = cursor"      /* Get row and column number */   0014000
V0
V    "isredit (lineData) = line" row   /* Get the line data */           0015000
V0
V                                                                        0016000
V0
V    /* find DSP=SYS1.&SYSNAME..PARMLIB or PATH= */                      0017000
V0
V    filePos = INDEX(lineData,'DSN=')     /* Find DSN= */                0018000
V0
V    if ( filePos = 0 ) then              /* No DSN=, */                 0019000
V0
V       do                                                               0020000
V0
V          filePos = INDEX(lineData,'ORDER=')  /* Look for PATH = */     0021000
V0
V          if ( filePos = 0 ) then              /* No ORDER=, */         0022000
V0
V             do                                                         0023000
V0
V                filePos = INDEX(lineData,'PATH=')  /* Look for PATH = */0024000
V0
V                if ( filePos <> 0 ) then /* PATH= was found */          0025000
V0
V                   do                                                   0026000
V0
V                   pathflag = 1                                         0027000
V0
V                   file = substr(lineData,filePos+5)                    0028000
V0
V                   end                                                  0029000
V0
V                else                                                    0030000
V0
V                   do /* Nothing found; use text under cursor as DSN */ 0031000
V0
V                   filePos = col                                        0032000
V0
V                   file = findDsn(filePos,lineData)                     0033000
V0
V                   end                                                  0034000
V0
V                end                                                     0035000
V0
V             else /* ORDER= was found */                                0036000
V0
V                file = substr(lineData,filePos+6)                       0037000
V0
V       end                                                              0038000
V0
V     else /* DSN= was found */                                          0039000
V0
V        file = substr(lineData,filePos+4) /* file = Pos to end line */  0040000
V0
V                                                                        0041000
V0
V    /* DSN= or PATH= not found. */                                      0042000
V0
V    /* this should never happen, as if these aren't found, we just take 0043000
V0
V       the data underthe cursor */                                      0044000
V0
V    if ( filePos = 0 ) then                                             0045000
V0
V       do                                                               0046000
V0
V       zedsmsg = 'No DSN= or PATH= found' /* Set short message */       0047000
V0
V       zedlmsg = 'In line data ' lineData /* Set long message */        0048000
V0
V       'ISPEXEC SETMSG MSG(ISRZ001)'      /* Set the message  */        0049000
V0
V       exit                                                             0050000
V0
V       end                                                              0051000
V0
V                                                                        0052000
V0
V    /* Look for a ')', ',' or ' ' to terminate the file name */         0053000
V0
V    /* If a PATH, then ' ' is the terminator */                         0054000
V0
V    member = index(file,')')                     /* Find ')' */         0055000
V0
V    if ( member > 0 ) then file = substr(file,1,member)                 0056000
V0
V    comma = index(file,',')                     /* Find ',' */          0057000
V0
V    if ( comma > 0 ) then file = substr(file,1,comma-1)                 0058000
V0
V    /* None of these - just return the string ending in ' ' */          0059000
V0
V    file = subword(file,1,1)                                            0060000
V0
V                                                                        0061000
V0
V    upper file /* Convert to upper case */                              0062000
V0
V    file = subVar(file) /* Replace any symbolic variables */            0063000
V0
V                                                                        0064000
V0
V    /* See if dataset exists */                                         0065000
V0
V    if ( pathflag <> 1 ) then  /* Not a PATH */                         0066000
V0
V       do                                                               0067000
V0
V       x = SYSDSN("'"file"'")                                           0068000
V0
V                                                                        0069000
V0
V       if ( x = 'OK' ) then /* Does the file exist? */                  0070000
V0
V          "ISPEXEC EDIT DATASET('"file"')" /* Yes - edit it */          0071000
V0
V       else                                /* No - issue message */     0072000
V0
V          do                                                            0073000
V0
V          zedsmsg = 'Dataset not Found'    /* Set short message */      0074000
V0
V          zedlmsg = x "'"file"'"           /* Set long message */       0075000
V0
V          'ISPEXEC SETMSG MSG(ISRZ001)'    /* Set the message  */       0076000
V0
V          end                                                           0077000
V0
V       end                                                              0078000
V0
V    else                      /* the file is PATH */                    0079000
V0
V       do                                                               0080000
V0
V       ADDRESS TSO "oedit " file                                        0081000
V0
V       end                                                              0082000
V0
V    exit                                                                0083000
V0
V                                                                        0084000
V0
V                                                                        0085000
V0
V /* See if a character is valid in a DSN */                             0086000
V0
V dsnChar: procedure                                                     0087000
V0
V    arg char                                                            0088000
V0
V    validChar = '. $#()&@' /* OK DSN chars + with alpha-nums */         0089000
V0
V    return (datatype(char,'A') | (index(validChar,char))>0)             0090000
V1
V    exit                                                                0091000
V0
V                                                                        0092000
V0
V findDsn: procedure                                                     0093000
V0
V    /* Return a substring deliminated by valid dsn-characters.          0094000
V0
V       The search location for the substr is given by posn.             0095000
V0
V       Start by tracking back through the string from the initial posn  0096000
V0
V       until we get to position 1 (start opf string) or we find a non-  0097000
V0
V       valid DSN char. Then track forward until we reach end of string  0098000
V0
V       or another non-valid DSN char. Then return the substring between 0099000
V0
V       these 2 positions.                                               0100000
V0
V       This isn't completely accurate, as it doesn't require the found  0101000
V0
V       string to meet the 8.8.8 etc pattern                             0102000
V0
V    */                                                                  0103000
V0
V    parse arg posn,str                                                  0104000
V0
V    if (dsnChar(substr(str,posn,1))=0) then return '' /* no DSN here */ 0105000
V0
V    /* loop until char is non-DSN */                                    0106000
V0
V    do until (dsnChar(substr(str,posn,1))=0)                            0107000
V0
V       posn=posn-1 /* Point to previous character */                    0108000
V0
V       if posn = 0 then leave /* Start of string reached */             0109000
V0
V       end                                                              0110000
V0
V    posn=posn+1 /* Went off end, so step forward */                     0111000
V0
V                                                                        0112000
V0
V    /* Now find the end of the string */                                0113000
V0
V    endPos=posn                                                         0114000
V0
V    do until (dsnChar(substr(str,endPos,1))=0)                          0115000
V0
V    /* Track forward to find end of possible DSN */                     0116000
V0
V       endPos=endPos+1                                                  0117000
V0
V       if (endPos>length(str)) then leave /* gone off end */            0118000
V0
V    end                                                                 0119000
V0
V    return substr(str,posn,endPos-posn)                                 0120000
V0
V    exit                                                                0121000
V0
V                                                                        0122000
V0
V subVar: procedure                                                      0123000
V0
V /* Replace symbolic vars in string with their values */                0124000
V0
V    parse arg string                                                    0125000
V0
V    i = index(string,'&SYSNAME.')                                       0126000
V0
V    if ( i <> 0 ) then                                                  0127000
V0
V       do                                                               0128000
V0
V       sysname = MVSVAR('SYSNAME')                                      0129000
V0
V       string = substr(string,1,i-1)||sysname||substr(string,i+9)       0130000
V2
V       end                                                              0131000
V0
V                                                                        0132000
V0
V    i = index(string,'&LOCATE.')                                        0133000
V0
V    if ( i <> 0 ) then                                                  0134000
V0
V       do                                                               0135000
V0
V       locate = MVSVAR('SYMDEF','LOCATE')                               0136000
V0
V       string = substr(string,1,i-1)||locate||substr(string,i+8)        0137000
V2
V       end                                                              0138000
V0
V                                                                        0139000
V0
V    return string                                                       0140000
V0
V                                                                        0141000
V0
VMEMBER NAME  RSAVE
V/* REXX */                                                              0001000
V1
V"ISREDIT MACRO (iMEMBER)"                                               0002000
V1
VADDRESS ISREDIT                                                         0003000
V1
V"(zlast) = LINENUM .ZLAST"                                              0004000
V1
V"(zfirst) = LINENUM .ZFIRST"                                            0005000
V1
V"(sSESS,sJUNK) = SESSION"                                               0006000
V1
Vif sSESS ¬= 'VIEW' then                                                 0007000
V1
V   do                                                                   0008000
V1
V   msg = 'VREP does not work within 'sSESS                              0009000
V1
V   x = setmsg(msg)                                                      0010000
V1
V   exit                                                                 0011000
V1
V   end                                                                  0012000
V1
V                                                                        0013000
V1
Vif zLast = 0 | zFirst = 0 then                                          0014000
V1
V   do                                                                   0015000
V1
V   msg = 'VREP does not Cater for empty files'                          0016000
V1
V   x = setmsg(msg)                                                      0017000
V1
V   exit                                                                 0018000
V1
V   end                                                                  0019000
V1
V                                                                        0020000
V1
V"(sLIB,sJUNK,sJUNK1) = DATASET"                                         0021000
V1
VsFILE = "'"||sLIB||"'"                                                  0022000
V1
Vx = listdsi(sFILE)                                                      0023000
V1
Vselect                                                                  0024000
V1
V  when sysdsorg = 'PO' then call pdsfile                                0025000
V1
V  when sysdsorg = 'PS' then call seqfile                                0026000
V1
V  otherwise                                                             0027000
V1
V    msg = 'invalid DSORG ' sysdsorg                                     0028000
V1
V    x = setmsg(msg)                                                     0029000
V1
V    exit                                                                0030000
V1
V  end                                                                   0031000
V1
Vexit                                                                    0032000
V1
V/*******/                                                               0033000
V1
VSEQFILE:                                                                0034000
V1
V/*******/                                                               0035000
V1
V"REPLACE " sFILE " .ZFIRST .ZLAST"                                      0036000
V1
Vif rc = 0 then                                                          0037000
V1
V   do                                                                   0038000
V1
V   msg = 'Dataset 'sfile' replaced'                                     0039000
V1
V   x = setmsg(msg)                                                      0040000
V1
V   end                                                                  0041000
V1
Velse do                                                                 0042000
V1
V   Address ispexec "GETMSG MSG("ZERRMSG") SHORTMSG(msg)"                0043000
V1
V   x = setmsg(msg)                                                      0044000
V1
V   end                                                                  0045000
V1
Vreturn                                                                  0046000
V1
V/*******/                                                               0047000
V1
VPDSFILE:                                                                0048000
V1
V/*******/                                                               0049000
V1
Vif iMEMBER = '' then                                                    0050000
V1
V   do                                                                   0051000
V1
V   "(iMEMBER) = MEMBER"                                                 0052000
V1
V   sSetStats = 'YES'                                                    0053000
V1
V   call GetStats                                                        0054000
V1
V   end                                                                  0055000
V1
Velse do                                                                 0056000
V1
V   upper iMEMBER                                                        0057000
V1
V   "(sLIB,sJUNK,sJUNK1) = DATASET"                                      0058000
V1
V   sSetStats = 'NO'                                                     0059000
V1
V   if SYSDSN("'"sLIB"("iMEMBER")'") = "OK" then                         0060000
V1
V     do                                                                 0061000
V1
V     msg = 'Member 'iMEMBER' already exists - not REPLACEd'             0062000
V1
V       x = setmsg(msg)                                                  0063000
V1
V       exit                                                             0064000
V1
V     end                                                                0065000
V1
V   end                                                                  0066000
V1
V"REPLACE " iMEMBER ".ZFIRST .ZLAST"                                     0067000
V1
Vif rc = 0 then                                                          0068000
V1
V   do                                                                   0069000
V1
V   msg = 'Member 'iMEMBER' replaced'                                    0070000
V1
V   x = setmsg(msg)                                                      0071000
V1
V   if sSetStats = 'YES' then call SetStats                              0072000
V1
V   end                                                                  0073000
V1
Velse do                                                                 0074000
V1
V   Address ispexec "GETMSG MSG("ZERRMSG") SHORTMSG(msg)"                0075000
V1
V   x = setmsg(msg)                                                      0076000
V1
V   end                                                                  0077000
V1
Vreturn                                                                  0078000
V1
V/**************************/                                            0079000
V1
VGetStats:                                                               0080000
V1
V/**************************/                                            0081000
V1
V                           address ispexec "lminit dataid(s1) dataset("s0082000
V1
Vaddress ispexec "lmopen  dataid("s1") OPTION(INPUT)"                    0083000
V1
Vaddress ispexec "lmmfind dataid("s1") MEMBER("iMember") STATS(YES)"     0084000
V1
Vaddress ispexec "lmclose dataid("s1")"                                  0085000
V1
V kMOD  = ZLMOD                                                          0086000
V1
V if DATATYPE(kMOD) ¬= 'NUM' then                                        0087000
V1
V    do                                                                  0088000
V1
V    sSetStats = 'NO'                                                    0089000
V1
V    return                                                              0090000
V1
V    end                                                                 0091000
V1
V if kMOD < 99 THEN kMOD  = kMOD + 1                                     0092000
V1
V kCDATE = ZLCDATE                                                       0093000
V1
V kINORC = ZLINORC                                                       0094000
V1
Vreturn                                                                  0095000
V1
V/********/                                                              0096000
V1
VSetStats:                                                               0097000
V1
V/********/                                                              0098000
V1
Vaddress ispexec "lmmstats dataid("s1") MEMBER("iMember") ,              0099000
V1
Vversion("kVERS") MODLEVEL("kMOD") CREATED("kCDATE") INITSIZE("kINORC")" 0100000
V1
Vaddress ispexec "lmfree  dataid("s1")"                                  0101000
V1
Vexit                                                                    0102000
V1
VMEMBER NAME  BATCHK##
V/* Rexx - BATCHK## ************************************************************
V
V * Batch Performance Rename Check Procedure
V
V * Purpose  1 - Check that the actual RENAME process worked
V
V * Parms  : n/a
V
V * Updates follow :
V
V * ver 0.1 - KB 20170126 - initial write
V
V *
V
V ******************************************************************************
V/
VClear
V
VGet_Source_Name:
V
V  Parse SOURCE . . exec_name .
V
V  Parse Upper Arg opt
V
V  ver = "0.1"
V
V
V
V  Say
V
V  Say "Starting "exec_name" version "ver" on "Date(W) Date()" at " Time()
V
V  Say
V
V
V
VInitialise:
V
V  erc = 0
V
V
V
VRead_REPORT:
V
V  "execio * diskR REPORT (stem rep. finis)"
V
V  "free fi(REPORT)"
V
V
V
VExtract:
V
V  Say " Errors extracted from REPORT are listed below"
V
V  Do a = 1 to rep.0
V
V    If Pos("DATA SET '",rep.a) > 0 Then Do
V
V      Say " "rep.a
V
V      erc = 8
V
V    End
V
V  End
V
V  If erc = 0 Then Say " No errors found"
V
V
V
VExit:
V
V  Say
V
V  Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at " Time()
V
V  Say
V
V  Exit erc
V
VMEMBER NAME  BATH
V/* REXX  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0001002
V5
V/*                                                                 */   0001102
V5
V/*    NAME       -   VSAM ANALYSIS                                 */   0001112
V5
V/*    WRITTEN    -   JULY 94                                       */   0001122
V5
V/*    AUTHOR     -   D. BUTT                                       */   0001132
V5
V/*    ENVIRON    -   BATCH REXX                                    */   0001142
V5
V/*    FUNCTION   -   ANALYZES INFO FROM LISTCATS AND REPORTS ON    */   0001152
V5
V/*                   CERTAIN CRITERIA.                             */   0001162
V5
V/*    INPUT      -   READS A FILE FROM DDNAME 'LISTCAT'. THIS      */   0001172
V5
V/*                   FILE MUST CONTAIN THE SYSPRINT OUTPUT FROM    */   0001182
V5
V/*                   AN IDCAMS 'LISTC LEVEL(...) RUN.              */   0001192
V5
V/*    OUTPUT     -   WRITES A FILE TO DDNAME 'SYSPUNCH'.           */   0001202
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0001342
V5
V                                                                        0001402
V5
V                                                                        0001502
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0001512
V5
V/* READ THE INPUT FILE INTO A STEM.                                */   0001602
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0001702
V5
V  'EXECIO * DISKR LISTCAT (STEM LISTC. FINIS'
V
V                                                                        0003002
V5
V                                                                        0003102
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0003202
V5
V/* INITIALISE THE LOGIC SWITCH.                                    */   0003302
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0003402
V5
V  Z = 0                                                                 0004000
V4
V  CISFOUND = 0
V
V  CASFOUND = 0
V
V  EXTFOUND = 0
V
V                                                                        0004102
V5
V                                                                        0004202
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0004302
V5
V/* PROCESS THE INPUT FILE IN STEM 'LISTC.'. SEARCH FOR THE DATA    */   0004402
V5
V/* LINE NAME FIRST. WHEN ONE IS FOUND THEN SEARCH FOR THE LINE     */   0004412
V5
V/* CONTAINING THE 'EXTENTS CI-SPLITS & CA-SPLITS.                  */   0004422
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0004502
V5
V                                                                        0004602
V5
V                                                                        0004702
V5
V  DO   N = 1  TO  LISTC.0                                               0005000
V2
V                                                                        0004702
V5
V                                                                        0005102
V5
V         LISTC.N = SUBSTR(LISTC.N,2)
V
V         TEMP    = SUBSTR(LISTC.N,1,4)
V
V                                                                        0005402
V8
V                                                                        0005502
V8
V          IF Z = 0 & TEMP ¬= 'DATA' THEN ITERATE
V
V          IF Z = 0 & TEMP = 'DATA' & POS('BATH',LISTC.N) <> 0 THEN DO
V
V          Z=1                                                           0008000
V4
V          BASE=WORD(LISTC.N,3)
V
V          ITERATE
V
V          END
V
V                                                                        0011202
V5
V/*  CHECK FOR CI-SPLITS                                              */
V
V
V
V        IF Z = 1 & POS('SPLITS-CI',LISTC.N)<>0 THEN DO
V
V             CIS = WORD(LISTC.N,2)
V
V             CIS = RIGHT(CIS,3)
V
V             CIS = STRIP(CIS,B,'-')
V
V          CISFOUND = '1'
V
V          END
V
V          ELSE NOP
V
V
V
V        IF CIS > '29' & CISFOUND = '1' THEN DO
V
V          CISVAR = BASE 'HAS' CIS 'CI-SPLITS'
V
V          CISFOUND = '0'
V
V          PUSH CISVAR
V
V          "EXECIO 1 DISKW DDCIS (FINIS"
V
V        END
V
V          ELSE NOP
V
V                                                                        0011202
V5
V/*  CHECK FOR CA-SPLITS                                              */
V
V
V
V        IF Z = 1 & POS('SPLITS-CA',LISTC.N)<>0 THEN DO
V
V          CAS = WORD(LISTC.N,2)
V
V          CAS = RIGHT(CAS,3)
V
V          CAS = STRIP(CAS,B,'-')
V
V          CASFOUND = '1'
V
V       END
V
V       ELSE NOP
V
V
V
V      IF   CAS > '1' & CASFOUND = '1' THEN DO
V
V          CASVAR = BASE 'HAS' CAS 'CA-SPLITS'
V
V          CASFOUND = '0'
V
V          PUSH CASVAR                                                   0017101
V5
V          "EXECIO 1 DISKW DDCAS (FINIS"
V
V      END
V
V          ELSE NOP
V
V                                                                        0011202
V5
V/*  CHECK FOR GREATER THAN 1  EXTENTS                                */
V
V
V
V
V
V       IF Z = 1 & POS('EXTENTS',LISTC.N)<>0 THEN DO
V
V          Z = 0
V
V          EXT = RIGHT(LISTC.N,2)
V
V          EXT = RIGHT(EXT,3)
V
V          EXT = STRIP(EXT,B,'-')
V
V          EXTFOUND = '1'
V
V       END
V
V       ELSE NOP
V
V
V
V
V
V       IF EXT > '1' & EXTFOUND = '1' THEN DO
V
V          EXTVAR = BASE 'HAS GONE TO' EXT 'EXTENTS'
V
V          EXTFOUND = '0'
V
V          PUSH EXTVAR
V
V          "EXECIO 1 DISKW DDEXT (FINIS"
V
V          END
V
V          ELSE NOP
V
V
V
V    END
V
V
V
V
V
V                                                                        0021002
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0022002
V5
V/* ALL INPUT PROCESSED. WRITE STATISTICS MESSAGES TO THE STACK.    */   0022102
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0022202
V5
V          DAVEB = 'BATH DATASETS EXCEEDING 29 CI-SPLITS'
V
V          PUSH DAVEB                                                       0025
V1
V          "EXECIO 1 DISKW DDCIS (FINIS"
V
V
V
V          DAVEB = 'BATH DATASETS EXCEEDING 1 CA-SPLIT'
V
V          PUSH DAVEB                                                       0025
V1
V          "EXECIO 1 DISKW DDCAS (FINIS"
V
V
V
V          DAVEB = 'BATH DATASETS EXCEEDING 1 EXTENT'
V
V          PUSH DAVEB                                                       0025
V1
V          "EXECIO 1 DISKW DDEXT (FINIS"
V
V
V
V                                                                        0028002
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0029002
V5
V/* E N D    O F    P R O G R A M                                   */   0030002
V5
V/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0031002
V5
VMEMBER NAME  BATREN##
V/* Rexx - BATREN## ************************************************************
V
V * Batch Performance Rename Build Procedure
V
V * Purpose  1 - Check if new files exist
V
V *              If (1) is yes and INITIAL issue message and RC=1
V
V *          2 - Check if old files exist
V
V *              If (2) is no, issue message and continue with next file
V
V *              If (2) is yes, proceed to (3)
V
V *          3 - Get attributes of old files
V
V *          4 - Build gdg base statements for new files if INITIAL mode only
V
V *          5 - Build Hrecall statements for old files if migrated and INITIAL
V
V *          6 - Build Rename statements for old files to new files
V
V * Parms  : opt 'INITIAL' or 'BATCH'
V
V * Updates follow :
V
V * ver 0.3 - KB 20170407 - added code to avoid multi-renames for multi-volumes
V
V * ver 0.2 - KB 20170406 - fix to ignore invalid suffixed ## files
V
V * ver 0.1 - KB 20170126 - initial write
V
V *
V
V ******************************************************************************
V/
VClear
V
VGet_Source_Name:
V
V  Parse SOURCE . . exec_name .
V
V  Parse Upper Arg opt
V
V  ver = "0.3"
V
V
V
V  Say
V
V  Say "Starting "exec_name" version "ver" on "Date(W) Date()" at " Time()
V
V  Say
V
V  Say " '"opt"' mode selected"
V
V
V
VInitialise:
V
V  mode = Sysvar(sysenv)
V
V  If mode = 'FORE' Then Signal Exit
V
V  erc = 0
V
V  fcnt = 0
V
V  ercnt = 0
V
V
V
V  filelist = " "
V
V  /*exclude_list = " "*/
V
V  gdgbasecnt = 0
V
V  hrecallcnt = 0
V
V  renamecnt  = 0
V
V  renamelist = " "
V
V
V
VRead_INLIST:
V
V  "execio * diskR INLIST (stem inlist. finis)"
V
V  If rc <> 0 Then Do
V
V    Say " "
V
V    Say " Error - Reading INLIST file. Routine stopped."
V
V    Exit 12
V
V  End
V
V  "free fi(INLIST)"
V
V  If inlist.0 = 0 Then Do
V
V    Say " Error - no records on the INLIST file. Routine stopped."
V
V    Exit 12
V
V  End
V
V/*
V
VRead_EXCLUDE:
V
V  "execio * diskR EXCLUDE (stem exclude. finis)"
V
V  "free fi(EXCLUDE)"
V
V
V
VBuild_Exclude_List:
V
V  Do ex = 1 to exclude.0
V
V    exclude_list = exclude_list" "Strip(exclude.ex)
V
V  End
V
V*/
V
VExtract:
V
V  Do a = 1 to inlist.0
V
V    oldfile = Word(inlist.a,1)
V
V    dotPSpos = Length(oldfile)-2
V
V    newfile = Overlay(".##",oldfile,dotPSpos)
V
V    newbase = newfile
V
V
V
V    /*If Pos(oldfile,exclude_list) > 0 Then Iterate a*/
V
V
V
V    sline1 = " "oldfile
V
V    sline1 = Overlay(newfile,sline1,50)
V
V
V
V    Call Check_File(newfile)
V
V    If lrc = 0 Then Do
V
V      If opt = "INITIAL" Then Do
V
V        ercnt = ercnt + 1
V
V        error.ercnt = " NEW FILE ALREADY EXISTS - "newfile
V
V        erc = 1
V
V      End
V
V    End
V
V
V
V    Call Check_File(oldfile)
V
V    If lrc <> 0 Then Do
V
V      ercnt = ercnt + 1
V
V      error.ercnt = " OLD FILE GV00 MISSING   - "oldfile
V
V      erc = 2
V
V    End
V
V    Call Get_Old_File_Attributes
V
V
V
V  End
V
V
V
VDisplay_ERROR_Messages:
V
V  Say
V
V  Say " ERROR MESSAGES"
V
V  If ercnt = 0 Then Say "   No errors found"
V
V  Else Do
V
V    Say "   There were "ercnt" errors encountered. See ERRORS sysout"
V
V  End
V
V
V
VDisplay_GDGBASE_Define_Statements:
V
V  If opt = "INITIAL" Then Do
V
V    Say
V
V    Say " GDG BASE DEFINE STATEMENTS"
V
V    Do z = 1 to gdgbasecnt
V
V      Say Right(z,4," ")"    "gdgbase.z
V
V    End
V
V    Drop z
V
V  End
V
V
V
VDisplay_HRECALL_Statements:
V
V  Say
V
V  If opt = "INITIAL" Then Say " HRECALL STATEMENTS"
V
V  Else Say " HRECALL STATEMENTS (reference only - HRECALL DD not populated)"
V
V  If hrecallcnt = 0 Then Say "   No files were found to be migrated"
V
V  Do z = 1 to hrecallcnt
V
V    Say Right(z,4," ")"    "hrecall.z
V
V  End
V
V  Drop z
V
V
V
VDisplay_RENAME_Statements:
V
V  Say
V
V  Say " RENAME STATEMENTS"
V
V  If renamecnt = 0 Then Say "   No files were found to be renamed"
V
V  Do z = 1 to renamecnt
V
V    Say Right(z,4," ")"    "rename.z
V
V  End
V
V  Drop z
V
V  Say
V
V
V
VWrite_Statements:
V
V  "execio "renamecnt"  diskW RENAME  (stem rename.  finis)"
V
V  "execio "ercnt"      diskW ERRORS  (stem error.   finis)"
V
V  If opt = "INITIAL" Then Do
V
V    "execio "hrecallcnt" diskW HRECALL (stem hrecall. finis)"
V
V    "execio "gdgbasecnt" diskW GDGBASE (stem gdgbase. finis)"
V
V  End
V
V
V
VExit:
V
V  Say
V
V  Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at " Time()
V
V  Say
V
V  Exit erc
V
V
V
VCheck_File:
V
V  Arg filetype
V
V  trapit = OutTrap(listc1.)
V
V  "LISTC ENT('" || filetype || "') ALL"
V
V  lrc = rc
V
V  trapit = OutTrap(Off)
V
V
V
V  Return
V
V
V
VGet_Old_File_Attributes:
V
V  renamelist = " "
V
V  Do l = 1 to listc1.0
V
V    If Pos("GDG BASE",listc1.l) > 0 Then gdg = "Y"
V
V    If Pos(" LIMIT--",listc1.l) > 0 Then Do
V
V      xline = Translate(listc1.l," ","-")
V
V      gdg_limit    = Word(xline,2)
V
V      gdg_scratch  = Word(xline,3)
V
V      gdg_noempty  = Word(xline,4)
V
V      If gdg = "Y" Then Do
V
V        gdgxyz = "     LIMIT("gdg_limit")" gdg_scratch gdg_noempty")"
V
V        gdgbasecnt = gdgbasecnt + 1
V
V        gdgbase.gdgbasecnt = " DEF GDG (NAME('"newfile"') - "
V
V        gdgbasecnt = gdgbasecnt + 1
V
V        gdgbase.gdgbasecnt = gdgxyz
V
V      End
V
V    End
V
V    If Pos("NONVSAM ---- ",listc1.l) > 0 Then Do
V
V      xline = Translate(listc1.l," ","-")
V
V      gdg_file = Word(xline,2)
V
V    End
V
V    If Pos("VOLSER----",listc1.l) > 0 Then Do
V
V      If Pos(gdg_file,renamelist) > 0 Then Iterate l
V
V      xline = Translate(listc1.l," ","-")
V
V      volser = Word(xline,2)
V
V      If volser = "MIGRAT" Then Do
V
V        hrecallcnt = hrecallcnt + 1
V
V        hrecall.hrecallcnt = " HRECALL '"gdg_file"'"
V
V        hrecall.hrecallcnt = Overlay("WAIT",hrecall.hrecallcnt,60)
V
V      End
V
V
V
V      renamecnt = renamecnt + 1
V
V      rename.renamecnt = " ALTER   '"gdg_file"'"
V
V      rename.renamecnt = Overlay("-",rename.renamecnt,60)
V
V
V
V      checkfile = Left(gdg_file,Length(gdg_file)-9) /* PS base name */
V
V
V
V      Call Get_##_GV00
V
V
V
V      renamecnt = renamecnt + 1
V
V      rename.renamecnt = " NEWNAME('"Overlay(newfile,gdg_file,1)"')"
V
V      renamelist = renamelist" "gdg_file
V
V    End
V
V  End
V
V
V
V  Drop listc1.
V
V
V
V  Return
V
V
V
VGet_##_GV00:
V
V  newfile_length = Length(newfile) - 9
V
V  temp_newfile = newfile
V
V
V
V  If checkfile = temp_temp_checkfile Then Do /* same base different GV00 */
V
V    ##GV00num = ##GV00num + 1
V
V    If ##GV00num = 10000 Then ##GV00num = 1
V
V    ##GV00num = Right(##GV00num,4,'0')
V
V    ##GV00    = "G"##GV00num"V00"
V
V    newfile   = newbase"."##GV00
V
V    Return 0
V
V  End
V
V
V
V  listc_trap = OutTrap(listc2.)
V
V  Address TSO "listcat lvl('"temp_newfile"')" /* check for GV00 under ## */
V
V  l2rc = rc
V
V  If l2rc <> 0 Then Return 0 /* ## GV00 not found so rename as like */
V
V  listc_trap = OutTrap(Off)
V
V
V
V  listc_cnt = listc2.0 - 1
V
V
V
V  ##GV00dsn = Word(listc2.listc_cnt,3)
V
V  If Right(##GV00dsn,3) <> "V00" Then Return 0 /* not a valid GV00 */
V
V  ##GV00num = Right(##GV00dsn,8)
V
V  ##GV00num = SubStr(##GV00num,2,4)
V
V  ##GV00num = ##GV00num + 1
V
V  If ##GV00num = 10000 Then ##GV00num = 1
V
V  ##GV00num = Right(##GV00num,4,'0')
V
V  ##GV00    = "G"##GV00num"V00"
V
V
V
V  temp_temp_checkfile = checkfile
V
V  newfile = temp_newfile"."##GV00
V
V
V
V  Drop listc2.
V
V
V
V  Return 0
V
V
V
VMEMBER NAME  BATREN#O
V/* Rexx - BATREN## ************************************************************
V
V * Batch Performance Rename Build Procedure
V
V * Purpose  1 - Check if new files exist
V
V *              If (1) is yes and INITIAL issue message and RC=1
V
V *          2 - Check if old files exist
V
V *              If (2) is no, issue message and continue with next file
V
V *              If (2) is yes, proceed to (3)
V
V *          3 - Get attributes of old files
V
V *          4 - Build gdg base statements for new files if INITIAL mode only
V
V *          5 - Build Hrecall statements for old files if migrated and INITIAL
V
V *          6 - Build Rename statements for old files to new files
V
V * Parms  : opt 'INITIAL' or 'BATCH'
V
V * Updates follow :
V
V * ver 0.1 - KB 20170126 - initial write
V
V *
V
V ******************************************************************************
V/
VClear
V
VGet_Source_Name:
V
V  Parse SOURCE . . exec_name .
V
V  Parse Upper Arg opt
V
V  ver = "0.1"
V
V
V
V  Say
V
V  Say "Starting "exec_name" version "ver" on "Date(W) Date()" at " Time()
V
V  Say
V
V  Say " '"opt"' mode selected"
V
V
V
VInitialise:
V
V  mode = Sysvar(sysenv)
V
V  If mode = 'FORE' Then Signal Exit
V
V  erc = 0
V
V  fcnt = 0
V
V  ercnt = 0
V
V
V
V  filelist = " "
V
V  /*exclude_list = " "*/
V
V  gdgbasecnt = 0
V
V  hrecallcnt = 0
V
V  renamecnt  = 0
V
V
V
VRead_INLIST:
V
V  "execio * diskR INLIST (stem inlist. finis)"
V
V  If rc <> 0 Then Do
V
V    Say " "
V
V    Say " Error - Reading INLIST file. Routine stopped."
V
V    Exit 12
V
V  End
V
V  "free fi(INLIST)"
V
V  If inlist.0 = 0 Then Do
V
V    Say " Error - no records on the INLIST file. Routine stopped."
V
V    Exit 12
V
V  End
V
V/*
V
VRead_EXCLUDE:
V
V  "execio * diskR EXCLUDE (stem exclude. finis)"
V
V  "free fi(EXCLUDE)"
V
V
V
VBuild_Exclude_List:
V
V  Do ex = 1 to exclude.0
V
V    exclude_list = exclude_list" "Strip(exclude.ex)
V
V  End
V
V*/
V
VExtract:
V
V  Do a = 1 to inlist.0
V
V    oldfile = Word(inlist.a,1)
V
V    dotPSpos = Length(oldfile)-2
V
V    newfile = Overlay(".##",oldfile,dotPSpos)
V
V
V
V    /*If Pos(oldfile,exclude_list) > 0 Then Iterate a*/
V
V
V
V    sline1 = " "oldfile
V
V    sline1 = Overlay(newfile,sline1,50)
V
V
V
V    Call Check_File(newfile)
V
V    If lrc = 0 Then Do
V
V      If opt = "INITIAL" Then Do
V
V        ercnt = ercnt + 1
V
V        error.ercnt = " NEW FILE ALREADY EXISTS - "newfile
V
V        erc = 1
V
V      End
V
V    End
V
V
V
V    Call Check_File(oldfile)
V
V    If lrc <> 0 Then Do
V
V      ercnt = ercnt + 1
V
V      error.ercnt = " OLD FILE GV00 MISSING   - "oldfile
V
V      erc = 2
V
V    End
V
V    Call Get_Old_File_Attributes
V
V
V
V  End
V
V
V
VDisplay_ERROR_Messages:
V
V    Say
V
V    Say " ERROR MESSAGES"
V
V    If ercnt = 0 Then Say "   No errors found"
V
V    Else Do
V
V      Say "   There were "ercnt" errors encountered. See ERRORS sysout"
V
V    End
V
V
V
VDisplay_GDGBASE_Define_Statements:
V
V  If opt = "INITIAL" Then Do
V
V    Say
V
V    Say " GDG BASE DEFINE STATEMENTS"
V
V    Do z = 1 to gdgbasecnt
V
V      Say Right(z,4," ")"    "gdgbase.z
V
V    End
V
V    Drop z
V
V  End
V
V
V
VDisplay_HRECALL_Statements:
V
V  Say
V
V  If opt = "INITIAL" Then Say " HRECALL STATEMENTS"
V
V  Else Say " HRECALL STATEMENTS (reference only - HRECALL DD not populated)"
V
V  If hrecallcnt = 0 Then Say "   No files were found to be migrated"
V
V  Do z = 1 to hrecallcnt
V
V    Say Right(z,4," ")"    "hrecall.z
V
V  End
V
V  Drop z
V
V
V
VDisplay_RENAME_Statements:
V
V  Say
V
V  Say " RENAME STATEMENTS"
V
V  Do z = 1 to renamecnt
V
V    Say Right(z,4," ")"    "rename.z
V
V  End
V
V  Drop z
V
V  Say
V
V
V
VWrite_Statements:
V
V
V
V  "execio "renamecnt"  diskW RENAME  (stem rename.  finis)"
V
V  "execio "ercnt"      diskW ERRORS  (stem error.   finis)"
V
V  If opt = "INITIAL" Then Do
V
V    "execio "hrecallcnt" diskW HRECALL (stem hrecall. finis)"
V
V    "execio "gdgbasecnt" diskW GDGBASE (stem gdgbase. finis)"
V
V  End
V
V
V
VExit:
V
V  Say
V
V  Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at " Time()
V
V  Say
V
V  Exit erc
V
V
V
VCheck_File:
V
V  Arg filetype
V
V  trapit = OutTrap(listc1.)
V
V  "LISTC ENT('" || filetype || "') ALL"
V
V  lrc = rc
V
V  trapit = OutTrap(Off)
V
V
V
V  Return
V
V
V
VGet_Old_File_Attributes:
V
V  Do l = 1 to listc1.0
V
V    If Pos("GDG BASE",listc1.l) > 0 Then gdg = "Y"
V
V    If Pos(" LIMIT--",listc1.l) > 0 Then Do
V
V      xline = Translate(listc1.l," ","-")
V
V      gdg_limit    = Word(xline,2)
V
V      gdg_scratch  = Word(xline,3)
V
V      gdg_noempty  = Word(xline,4)
V
V      If gdg = "Y" Then Do
V
V        gdgxyz = "     LIMIT("gdg_limit")" gdg_scratch gdg_noempty")"
V
V        gdgbasecnt = gdgbasecnt + 1
V
V        gdgbase.gdgbasecnt = " DEF GDG (NAME('"newfile"') - "
V
V        gdgbasecnt = gdgbasecnt + 1
V
V        gdgbase.gdgbasecnt = gdgxyz
V
V      End
V
V    End
V
V    If Pos("NONVSAM ---- ",listc1.l) > 0 Then Do
V
V      xline = Translate(listc1.l," ","-")
V
V      gdg_file = Word(xline,2)
V
V    End
V
V    If Pos("VOLSER----",listc1.l) > 0 Then Do
V
V      xline = Translate(listc1.l," ","-")
V
V      volser = Word(xline,2)
V
V      If volser = "MIGRAT" Then Do
V
V        hrecallcnt = hrecallcnt + 1
V
V        hrecall.hrecallcnt = " HRECALL '"gdg_file"'"
V
V        hrecall.hrecallcnt = Overlay("WAIT",hrecall.hrecallcnt,60)
V
V      End
V
V
V
V      renamecnt = renamecnt + 1
V
V      rename.renamecnt = " ALTER   '"gdg_file"'"
V
V      rename.renamecnt = Overlay("-",rename.renamecnt,60)
V
V
V
V      checkfile = Left(gdg_file,Length(gdg_file)-9)
V
V
V
V      Call Get_##_GV00
V
V
V
V      renamecnt = renamecnt + 1
V
V      rename.renamecnt = " NEWNAME('"Overlay(newfile,gdg_file,1)"')"
V
V    End
V
V  End
V
V
V
V  Drop listc1.
V
V
V
V  Return
V
V
V
VGet_##_GV00:
V
V  pluscnt = 0
V
V  newfile_length = Length(newfile) - 9
V
V  temp_newfile = SubStr(newfile,1,newfile_length)
V
V  temp_newfile = newfile
V
V
V
V  If checkfile = temp_temp_checkfile Then pluscnt = pluscnt + 1
V
V  Else pluscnt = 1
V
V
V
V  listc_trap = OutTrap(listc2.)
V
V  Address TSO "listcat lvl('"temp_newfile"')"
V
V  If rc <> 0 Then Return 0
V
V  listc_trap = OutTrap(Off)
V
V
V
V  listc_cnt = listc2.0 - 1
V
V  ##GV00dsn = Word(listc2.listc_cnt,3)
V
V  ##GV00num = Right(##GV00dsn,8)
V
V  ##GV00num = SubStr(##GV00num,2,4)
V
V  ##GV00num = ##GV00num + pluscnt
V
V  If ##GV00num = 10000 Then ##GV00num = 1
V
V  ##GV00num = Right(##GV00num,4,'0')
V
V  ##GV00    = "G"##GV00num"V00"
V
V
V
V  temp_temp_checkfile = checkfile
V
V  newfile = temp_newfile"."##GV00
V
V
V
V  Drop listc2.
V
V
V
V  Return 0
V
V
V
VMEMBER NAME  CA7BUILD
V/* Language           : Rexx
V
V * Program Name       : CA7BUILD
V
V * Description        : To build CA7 control cards from BTI output.
V
V * Input Parameters   : cmr
V
V * Output Parameters  : none
V
V * Panel Names        : none
V
V * Table Names        : none
V
V * Skeleton Names     : none
V
V * Macro Names        : none
V
V * Rexx Names         : none
V
V * Program Names      : none
V
V * Message Names      : Internal ZEDxMSG's
V
V * Execution Mode     : TSO or Batch
V
V * Procedure          : none
V
V * Batch Job Name     : none
V
V * Restrictions       : JOC userids
V
V * User               : JCL Management
V
V * Author             : KEN BALNAVE
V
V * Department         : JCL MANAGEMENT
V
V * Owner              : KEN BALNAVE - JCL MANAGEMENT
V
V * Created            : 16th February 2006
V
V * Status             : Test/Live
V
V * Modified as below  : Latest modification on top.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 8th February 2018 - ver 4.1.0
V
V * 1: Updated calendar scheduling for issues with month calendars.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 5th October 2016 - ver 4.0.0
V
V * 1: Updated to cater for FDI1 CCI ssct change from UCT7 to CA71
V
V * 2: Added Cross Scheduling AGENT parameter pick up
V
V * 3: Changed '###' comments to 'DBM' to avoid errors in output report
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 14th April 2015 - ver 3.9
V
V * 1: Updated to cater for FDI1 CCI Node.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 10th March 2015 - ver 3.8
V
V * 1: Updated RESTART section to cater for RESTART=N
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 9th December 2014 - ver 3.7
V
V * 1: Changed CONDCODE/RELOPR setting to cater for #SCC cards
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 15th August 2014 - ver 3.6.5
V
V * 1: Updated WEEKLY scheduling for specific days to include missing comma.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 14th June 2013 - ver 3.6.4
V
V * 1: Added 'DONT SCHEDULE' info.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 28th March 2013 - ver 3.6.3
V
V * 1: Added bypass of JOBCARD if we only want the BTI section.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 10th March 2013 - ver 3.6.2
V
V * 1: Correct USR REQ's by removing check for duplicates.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 26th February 2013 - ver 3.6.1
V
V * 1: Added a date parm to the jobcard to identify when routine was run.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 21th February 2013 - ver 3.6
V
V * 1: Added check for HOLD=Y.
V
V * 2: Hardcoded SMFID parms for machine recognition.
V
V * 3: Moved REQUIREMENT write back to be after SUCCESSOR write and added extra
V
V *    check for duplicates.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 20th February 2013 - ver 3.5.3
V
V * 1: Updated node parm to be picked up from ENV before its picked up from CCI
V
V * 2: Update USR section to cater for ONLY option and length of requirement
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 15th February 2013 - ver 3.5.2
V
V * 1: Updated USR requirement section if report was split by '1LJOB,' to
V
V *    enable getting the SCHID from the next page.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 14th February 2013 - ver 3.5.1
V
V * 1: Updated TRIGGER section to pick up qtime & ldtime from ca7 rather than
V
V *    hardcoded 0010,0010.
V
V * 2: Corrected issue with checking SUCCESS jobs via CCI by adding node parm.
V
V * 3: Moved REQUIREMENT write to be before SUCCESSOR write.
V
V * 4: Moved DSN adds to be before DSN triggers.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 7th February 2013 - ver 3.4
V
V * 1: Added GDG=N for SIGNET specific dataset triggering.
V
V * 2: Added OWNER=JOCP000 if *NONE* is found (blank owner in CA7).
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 6th February 2013 - ver 3.3
V
V * 1: Added SCHID & TRGID to DSN triggered section
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 2nd January 2013 - ver 3.2
V
V * 1: Updated to check for LEADTM on SUCCESSOR fields
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 17th October 2012
V
V * 1: Commented out some SAY statements.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 24th August 2009
V
V * 1: Updated DTRG to be on 2 lines.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 28th July 2009
V
V * 1: Updated RESOLVE statement to display resolved dates.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 29th June 2009 (pre-backup CA7BLD24)
V
V * 1: Added REPEAT scheduling check.
V
V * 2: Added GDG variable.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 18th February 2009
V
V * 1: Re-added the SUCCESSOR write
V
V * 2: Added MAINT section.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 28th May 2008
V
V * 1: Updated looping in REQUIREMENTS section.
V
V * 2: Corrected system_name variables.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 5th October 2006
V
V * 1: Added setting of default cond_code and rel_oper statements.
V
V * 2: Change ZSYSID to MVSVAR setting as ZSYSID wasn't working ?
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 21st September 2006
V
V * 1: Removed the SUCCESSOR write as these variables will have been extracted
V
V *    from the REQUIREMENTS section, thus stopping duplicates.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 29th August 2006
V
V * 1: Added YEAR to CALENDAR scheduling.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 28th April 2006
V
V * 1: Added USER REQUIREMENT setup to reqjobs section.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 20th April 2006
V
V * 1: Changed JOB1 collection point to allow for XYZ* job listings.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 29th March 2006
V
V * 1: Corrected SCHEDULE section.
V
V * 2: Changed WEEK to drop leading zero's.
V
V * 3: Added TRGID section.
V
V *-----------------------------------------------------------------------------
V
V * KEN BALNAVE - 16th February 2006
V
V * 1: Rewrite - taken from CA7BUILD - ver 1.3, created by Stuart Dolman.
V
V *-----------------------------------------------------------------------------
V
V ******************************************************************************
V/
V
V
VIssue_Message:
V
V  Say 'CA7BUILD ver 4.1.0 - 'Date('W') Substr(Date('U'),4,2) Date('M'),
V
V                           Left(Date('S'),4)
V
V
V
VCollect_Variables:
V
V  Parse Arg cmr
V
V  If cmr = '' then Exit 12
V
V
V
VOverRide_If_TSO_Mode:
V
V  mode = Sysvar(sysenv)
V
V  If mode = 'FORE' then Do
V
V    "alloc fi(DDIN)  da('T.JOCS083.CA7BTI.LIST') SHR "
V
V    if rc /= 0 then exit 4
V
V    "alloc fi(DDOUT) da('T.JOCS083.CA7BTI') shr "
V
V    if rc /= 0 then exit 4
V
V  End
V
V
V
VGet_System_ID:
V
V  If MVSVAR(SYSSMFID) = 'IND2' Then node = 'IND2'
V
V  If MVSVAR(SYSSMFID) = 'INP2' Then node = 'INP2'
V
V
V
VInitialise:
V
V  dte             = "D."Date('S')
V
V  node_found      = 'N'
V
V  jcl_id          = '020'
V
V  system_name     = 'XXXXXXXX'
V
V  jobnet_name     = 'XX'
V
V  cond_code       = '0000'
V
V  rel_oper        = 'LT'
V
V  neg_dep_list    = ' '
V
V  neg_done_list   = ' '
V
V  trig_done_list  = ' '
V
V  vrm_done_list   = ' '
V
V  job1            = ' '
V
V  job_list        = ' '
V
V  line_check      = ' '
V
V  suc_line_check  = ' '
V
V  #type1          = ' '
V
V  vrm_list        = 'ASX CRQ EXC RCT SHR'
V
V  acnt            = 0 /* add jobframe count       DBM JOB       */
V
V  adsncnt         = 0 /* add dsn count            DBM DSN       */
V
V  ccnt            = 0 /* calendar count           built once    */
V
V  jcnt            = 0 /* jcl count                jcl list      */
V
V  ncnt            = 0 /* negative count           DBM JOBCONN   */
V
V  rcnt            = 0 /* requirement count        DBM JOBCONN   */
V
V  scnt            = 0 /* successor count          DBM JOBCONN   */
V
V  tbdcnt          = 0 /* triggered by dsn count   DBM SCHD,DTRG */
V
V  tbjcnt          = 0 /* trigger by job count     DBM SCHD,JTRG */
V
V  tcnt            = 0 /* triggered jobs count     DBM SCHD,JTRG */
V
V  ucnt            = 0 /* user req count                         */
V
V  vcnt            = 0 /* vrm count                              */
V
V  jlcnt           = 0 /* jobloop count                          */
V
V  ocnt            = 0 /* final output count                     */
V
V
V
V  a1cnt           = 0 /* annual count                                         *
V/
V  dowcnt          = 0 /* day-of-week count used with MONTHLY                  *
V/
V  wcnt            = 0 /* week count used with WEEKLY                          *
V/
V  w1cnt           = 0 /* week count used with MONTHLY                         *
V/
V  rdaycnt         = 0 /* relative day count used with MONTHLY                 *
V/
V  ndaycnt         = 0 /* non-day count used with MONTHLY                      *
V/
V  nrdaycnt        = 0 /* non-relative day count used with MONTHLY             *
V/
V
V
VBuild_Reverse_JCL_Statements:
V
V  If cmr <> "NOJCL" Then Do
V
V   jcnt = jcnt + 1
V
V   jcline.jcnt = "//RC"cmr" JOB (ACCOUNT),'"dte"',CLASS=A,MSGCLASS=9,"
V
V   jcnt = jcnt + 1
V
V   jcline.jcnt = "//         NOTIFY=&SYSUID"
V
V   jcnt = jcnt + 1
V
V   jcline.jcnt = "//*"
V
V   jcnt = jcnt + 1
V
V   jcline.jcnt =   "//STP0010  EXEC PGM=CAL2X2WB,"
V
V   If MVSVAR(SYSSMFID) = 'INP2' Then Do
V
V     jcnt = jcnt + 1
V
V     jcline.jcnt = "//         PARM='CCIINP2,UC07,,,OUTDD' ## INP2"
V
V   End
V
V   If MVSVAR(SYSSMFID) = 'IND2' Then Do
V
V     jcnt = jcnt + 1
V
V     jcline.jcnt = "//         PARM='CCIIND2,UC07,,,OUTDD' ## IND2"
V
V   End
V
V   jcnt = jcnt + 1
V
V   jcline.jcnt = "//SYSPRINT DD SYSOUT=*"
V
V   jcnt = jcnt + 1
V
V   jcline.jcnt = "//ERRORS   DD SYSOUT=*"
V
V   jcnt = jcnt + 1
V
V   jcline.jcnt = "//OUTDD    DD SYSOUT=*"
V
V   jcnt = jcnt + 1
V
V   jcline.jcnt = "//SYSIN    DD *"
V
V  End
V
V  jcnt = jcnt + 1
V
V  jcline.jcnt = "/LOGON"
V
V
V
VRead_LJOB_List_File:
V
V  "Execio * Diskr DDIN (Stem in. Finis)"
V
V  "free fi(DDIN)"
V
V  Say
V
V  Say " ===> "in.0" records read from CA7 list routine"
V
V  Say
V
V
V
VExtract:
V
V  Do linenum = 1 to in.0
V
V    If Pos("NODE: CCI",in.linenum) > 0 & node_found = 'N' Then Do
V
V      node = SubStr(in.linenum,90,6)
V
V      Say " Running for node "node
V
V      node_found = 'Y'
V
V    End
V
V    If Pos('.',linenum/1000) = 0 Then Say "A++++ at record "linenum
V
V    If Pos('SLIA-02',in.linenum) > 0 &,
V
V       Pos('NOT FOUND',in.linenum) > 0 then Do
V
V         nfjob = Strip(Substr(in.linenum,14,8))
V
V         Say "+++ "nfjob "not found. Routine continues +++"
V
V         Iterate
V
V    End
V
V    If Substr(in.linenum,36,4)  = "JOB="    Then Do
V
V      job_prefix = Substr(in.linenum,40,8)
V
V      job_prefix = Translate(job_prefix," ","*")
V
V      job_prefix = Word(job_prefix,1)
V
V      Say " "
V
V      Say " Looking for all jobs starting with "job_prefix
V
V      Say " "
V
V    End
V
V    If Substr(in.linenum,2,4)  = "JOB="    Then Do
V
V      job1_count = linenum+5
V
V      jlcnt = jlcnt + 1
V
V      Say " +++++ Calling JobLoop number "jlcnt
V
V      Call Jobloop
V
V    End
V
V    If Substr(in.linenum,21,7) = "/LOGOFF" Then Signal Merge_Contents
V
V  End
V
V
V
VMerge_Contents:
V
V  /* 1st - jcl lines */
V
V  Do m1 = 1 to jcnt
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = jcline.m1
V
V  End
V
V  /* 2nd - add job lines */
V
V  Do m2 = 1 to acnt
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = addline.m2
V
V  End
V
V
V
V  /* remove extra DBM JOB statements for tidyness */
V
V  t0ocnt = ocnt ; t1ocnt = ocnt - 1 ; t2ocnt = ocnt - 2
V
V  If oline.t2ocnt = "DBM" & oline.t1ocnt = "JOB" Then ocnt = ocnt - 3
V
V  If oline.t1ocnt = "DBM" & oline.t0ocnt = "JOB" Then ocnt = ocnt - 2
V
V
V
V  /* 3rd - calendar lines */
V
V  Do m3 = 1 to ccnt
V
V    If m3 = 1 & ccnt > 0 then Do
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM   CALENDARS"
V
V    End
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = cal_oline.m3
V
V  End
V
V  /* 5th - trigger by lines */
V
V  Do m5 = 1 to tbjcnt
V
V    If m5 = 1 & tbjcnt > 0 then Do
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM   JOBS TRIGGERED BY (2ND JOB TRIGGERED BY 1ST JOB)"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "SCHD,JTRG"
V
V    End
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = tbjline.m5
V
V  End
V
V  /* 6th - trigger lines */
V
V  Do m6 = 1 to tcnt
V
V    If m6 = 1 & tcnt > 0 then Do
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM   JOB TRIGGERS (1ST JOB TRIGGERS 2ND JOB)"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "SCHD,JTRG"
V
V    End
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = trigline.m6
V
V  End
V
V  /* 4th - add dsn lines */
V
V  Do m4 = 1 to adsncnt
V
V    If m4 = 1 & adsncnt > 0 then Do
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM   DSN'S"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DSN"
V
V    End
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = adsnline.m4
V
V  End
V
V  /* 7th - trigger by dsn lines */
V
V  Do m7 = 1 to tbdcnt
V
V    If m7 = 1 & tbdcnt > 0 then Do
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM   DSN TRIGGERS"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "SCHD,DTRG"
V
V    End
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = tbdline.m7
V
V  End
V
V  /* 8th - successor lines */
V
V  Do m8 = 1 to scnt
V
V    If Pos(sline.m8,line_check) > 0 then Do
V
V      nxm8 = m8 + 1
V
V      If Pos('SCHID=',sline.nxm8) > 0 then Do
V
V        m8 = m8 + 1
V
V      End
V
V      Iterate m8
V
V    End
V
V    If m8 = 1 & scnt > 0 then Do
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM   JOB SUCCESSORS (1ST JOB RUNS AFTER 2ND JOB)"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "JOBCONN"
V
V    End
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = sline.m8
V
V    line_check = line_check ' ' sline.m8
V
V    suc_line_check = suc_line_check ' ' sline.m8
V
V  End
V
V  /* 9th - requirement lines */
V
V  Do m9 = 1 to rcnt
V
V    If Pos(rline.m9,suc_line_check) > 0 then Do
V
V      nxm9 = m9 + 1
V
V      If Pos('SCHID=',rline.nxm9) > 0 then Do
V
V        m9 = m9 + 1
V
V      End
V
V      Iterate m9
V
V    End
V
V    If m9 = 1 & rcnt > 0 then Do
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM   JOB REQUIREMENTS (1ST JOB WAITS FOR 2ND JOB)"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "JOBCONN"
V
V    End
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = rline.m9
V
V    line_check = line_check ' ' rline.m9
V
V  End
V
V  /* 10th - negative dep lines */
V
V  Do m10 = 1 to ncnt
V
V    If Pos(nline.m10,line_check) > 0 then Iterate m10
V
V    If m10 = 1 & ncnt > 0 then Do
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM   NEGATIVE DEPENDANCIES"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "JOBCONN"
V
V    End
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = nline.m10
V
V    line_check = line_check ' ' nline.m10
V
V  End
V
V  /* 11th - user requirements */
V
V  Do m11 = 1 to ucnt
V
V    /*If Pos(usrline.m11,line_check) > 0 then Iterate m11*/
V
V    If m11 = 1 & ucnt > 0 then Do
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM   USER REQUIREMENTS"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "JOBCONN,USR"
V
V    End
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = usrline.m11
V
V    /*line_check = line_check ' ' usrline.m11*/
V
V  End
V
V  /* 12th - virtual resouce lines */
V
V  Do m12 = 1 to vcnt
V
V    /*If Pos(vrmline.m12,line_check) > 0 then Iterate m12*/
V
V    If m12 = 1 & vcnt > 0 then Do
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "DBM   VRM'S"
V
V      ocnt = ocnt + 1
V
V      oline.ocnt = "RM.1"
V
V    End
V
V    ocnt = ocnt + 1
V
V    oline.ocnt = vrmline.m12
V
V    /*line_check = line_check ' ' vrmline.m12*/
V
V  End
V
V
V
VGetout:                          /* All CA7 cards have been established */
V
V  ocnt = ocnt + 1
V
V  oline.ocnt = '/LOGOFF'
V
V  ocnt = ocnt + 1
V
V  oline.ocnt = '//*'
V
V  If ocnt > 13 then Do
V
V    "Execio "ocnt" Diskw DDOUT (stem oline. Finis)"
V
V    Say 'CA7BUILD complete.'
V
V  End
V
V  Else Do
V
V    Say 'CA7BUILD complete, but no BACKOUT records have been extracted.'
V
V  End
V
V  If mode = 'FORE' then "free fi(DDOUT)"
V
V
V
V  Address TSO "delstack"
V
V
V
VExit: exit 0
V
V
V
VJobloop:                            /* read input and call relevant section */
V
V  job1 = Strip(Substr(in.job1_count,2,8))
V
V  Say '  Building CA7 cards for 'job1
V
V  job_list = job_list' 'job1
V
V  #type1 = ' '
V
V  /*  say 'JOB LIST = 'job_list  */
V
V  Do Forever
V
V    cal_start = 'N'
V
V    linenum = linenum + 1
V
V    If Pos('.',linenum/1000) = 0 Then Say "B++++ at record "linenum
V
V    /* new start */
V
V    If Substr(in.linenum,75,1) = '/' Then Do
V
V      If Substr(in.linenum,71,4) /= 'DATE' Then Do
V
V        job1_count = linenum
V
V        /*say in.linenum*/
V
V        jobx = Strip(Substr(in.linenum,2,8))
V
V        If WordPos(jobx,job_list) > 0 then NOP
V
V        Else Signal Jobloop
V
V      End
V
V    /* new end */
V
V    End
V
V    linenum_1 = linenum - 1
V
V    If Word(in.linenum_1,1) = job1 Then Do
V
V      Call system_name
V
V      /*Say "     System name statement built"*/
V
V    End
V
V    If Pos('-- JOB INFORMATION --',in.linenum) > 0 Then Do
V
V      plus1_linenum = linenum + 1
V
V      unix_job = "N"
V
V      If Pos("LOAD STEP TO BE EXECUTED",in.plus1_linenum) = 0 Then Do
V
V        unix_job = "Y"
V
V      End
V
V    End
V
V    If Pos('JOB SET FOR EXEC ON MAIN',in.linenum) > 0 Then Do
V
V      Call exec_job
V
V      /*Say "     Exec statement built"*/
V
V    End
V
V    If Pos('JOB MARKED AS MAINT ONLY',in.linenum) > 0 Then Do
V
V      Call maint_job
V
V      /*Say "     MAINT statement built"*/
V
V    End
V
V    If Pos('JOB SET FOR HOLD IN REQQ',in.linenum) > 0 Then Do
V
V      Call hold_job
V
V      /*Say "     HOLD statement built"*/
V
V    End
V
V    If Pos('AUTO-GENERATION OF 7 RMS',in.linenum) > 0 Then Do
V
V      Call restart_job
V
V      /*Say "     RESTART statement built"*/
V
V    End
V
V    If Pos('OWNER=',in.linenum) > 0 Then Do
V
V      prmlib = ""
V
V      Call get_owner
V
V      /*Say "     Owner statement built"*/
V
V    End
V
V    If Pos('MSGCLASS=',in.linenum) > 0 & Pos('PRTY',in.linenum) > 0 Then Do
V
V      Call get_others
V
V      /*Say "     Msgclass statements built"*/
V
V    End
V
V    If Pos('JOBNET=',in.linenum) > 0 Then Do
V
V     Call jobnet
V
V      /*Say "     Jobnet statement built"*/
V
V    End
V
V    If Pos('DONT SCHEDULE ',in.linenum) > 0 Then Do
V
V      Call dont_schedule
V
V      /*Say "     Dont Schedule statement built" */
V
V    End
V
V    If Pos('CONSIDER ABNORMAL END IF',in.linenum) > 0 Then Do
V
V      Call cond_code
V
V      /*Say "     Cond Code statement built"*/
V
V    End
V
V    If Pos('# OF TIMES LATE',in.linenum) > 0 Then Do
V
V      If unix_job = "N" Then Call Add_Job
V
V      /*Say "     Add statement built"*/
V
V    End
V
V    If Pos('- AGENT INFORMATION ',in.linenum) > 0 Then Do
V
V      Call unixjob
V
V      Call Add_UNIX_Job
V
V      /*Say "     UNIX statements built"*/
V
V    End
V
V    If Pos('- SCHEDULES ',in.linenum) > 0 Then Do
V
V      Call schedules
V
V      /*Say "     Schedule statements built"*/
V
V    End
V
V    If Pos('- TRIGGERED BY ',in.linenum) > 0 Then Do
V
V      tlinenum = linenum + 1
V
V      Call triggerby
V
V      /*Say "     Triggered by statements built"*/
V
V    End
V
V    If Pos('- TRIGGERED JOBS -',in.linenum) > 0 Then Do
V
V      Call trigger
V
V      /*Say "     Trigger statements built"*/
V
V    End
V
V    If Pos('- SUCCESSOR JOBS -',in.linenum) > 0 Then Do
V
V      Call success
V
V      /*Say "     Successor statements built"*/
V
V    End
V
V    If Pos('- REQUIREMENTS AND',in.linenum) > 0 Then Do
V
V      Call reqjobs
V
V      /*Say "     Requirement statements built"*/
V
V    End
V
V    If Pos('- VIRTUAL RESOURCE ',in.linenum) > 0 Then Do
V
V      Call vrm
V
V      /*Say "     VRM statements built"*/
V
V    End
V
V    If Pos(' REQUEST COMPLETED ',in.linenum) > 0 Then Do
V
V      /*Say "     Starting to build Negative Dependencies"*/
V
V      Call negjobs
V
V      /*Say "     ALL Negative Dependency statements built"*/
V
V      Return
V
V    End
V
V  End
V
V  Return
V
V
V
Vsystem_name:
V
V  jcl_id      = Strip(Substr(in.linenum_1,11,3))
V
V  member_name = Strip(Substr(in.linenum_1,15,8))
V
V  system      = Strip(Substr(in.linenum_1,24,8))
V
V  uid         = Strip(Substr(in.linenum_1,33,3))
V
V  mainid      = Strip(Substr(in.linenum_1,37,3))
V
V  Tclass      = '6'
V
V  Tmsgclass   = '0'
V
V  Tjobnet     = 'XXXXXXXX'
V
V  lrtime      = Strip(Substr(in.linenum_1,70,10))
V
V  If lrtime <> '          ' Then lrt = '* LAST RUN DATE/TIME = ' lrtime' *'
V
V  Return
V
V
V
Vexec_job:
V
V  exec_id = Substr(in.linenum,44,1)
V
V  Return
V
V
V
Vmaint_job:
V
V  maint_id = Substr(in.linenum,44,1)
V
V  Return
V
V
V
Vhold_job:
V
V  hold_id = Substr(in.linenum,44,1)
V
V  If hold_id = "Y" Then hold_id = "HOLD=Y,"
V
V  Else hold_id = ""
V
V  Return
V
V
V
Vrestart_job:
V
V  restart_id = Substr(in.linenum,9,1)
V
V  If restart_id = "Y" Then restart_id = "RESTART=Y"
V
V  Else restart_id = "RESTART=N"
V
V  Return
V
V
V
Vget_owner:
V
V  owner = Strip(Substr(in.linenum,17,8))
V
V  If Pos("PRMLIB=",in.linenum) > 0 Then prmlib = SubStr(in.linenum,33,3)
V
V  If owner = "*NONE*" Then owner = "JOCP000"
V
V  Return
V
V
V
Vget_others:
V
V  class    = Substr(in.linenum,17,1)
V
V  If class = ',' then class = Tclass
V
V  msgclass = Substr(in.linenum,28,1)
V
V  If msgclass = ',' then msgclass = Tmsgclass
V
V  prty_pos = Pos('PRTY=',in.linenum) + 5
V
V  prty     = Substr(in.linenum,prty_pos,3)
V
V  Return
V
V
V
Vjobnet:
V
V  jobnet_line = Translate(in.linenum,' ','=')
V
V  jobnet_wpos = WordPos('JOBNET ',jobnet_line) + 1
V
V  jobnet_name = Word(jobnet_line,jobnet_wpos)
V
V  Return
V
V
V
Vdont_schedule:
V
V  sched_words = Words(in.linenum)
V
V  Select
V
V    When sched_words = 5 Then Do
V
V      #type1 = Word(in.linenum,4)
V
V      #date1 = Word(in.linenum,5)
V
V      #line = Left(#type1,1)"DATE="#date1
V
V    End
V
V    When sched_words = 7 Then Do
V
V      #type1 = Word(in.linenum,4)
V
V      #date1 = Word(in.linenum,5)
V
V      #time1 = Word(in.linenum,7)
V
V      #line = Left(#type1,1)"DATE="#date1","Left(#type1,1)"TIME="#time1
V
V    End
V
V    When sched_words = 10 Then Do
V
V      #type1 = Word(in.linenum,4)
V
V      #date1 = Word(in.linenum,5)
V
V      #time1 = Word(in.linenum,7)
V
V      #type2 = Word(in.linenum,9)
V
V      #date2 = Word(in.linenum,10)
V
V      #line = Left(#type1,1)"DATE="#date1","Left(#type1,1)"TIME="#time1","||,
V
V              Left(#type2,1)"DATE="#date2
V
V    End
V
V    When sched_words = 12 Then Do
V
V      #type1 = Word(in.linenum,4)
V
V      #date1 = Word(in.linenum,5)
V
V      #time1 = Word(in.linenum,7)
V
V      #type2 = Word(in.linenum,9)
V
V      #date2 = Word(in.linenum,10)
V
V      #time2 = Word(in.linenum,12)
V
V      #line = Left(#type1,1)"DATE="#date1","Left(#type1,1)"TIME="#time1","||,
V
V              Left(#type2,1)"DATE="#date2","Left(#type2,1)"TIME="#time2
V
V    End
V
V    OtherWise NOP
V
V  End
V
V  Return
V
V
V
Vcond_code:
V
V  cond_code = Word(in.linenum,6)
V
V  rel_oper  = Word(in.linenum,8)
V
V  Return
V
V
V
VAdd_Job:     /* got all the ADD variables - so ADD job */
V
V  If acnt = 0 then Do
V
V    acnt = acnt + 1
V
V    addline.acnt = 'DBM'
V
V    acnt = acnt + 1
V
V    addline.acnt = 'JOB'
V
V  End
V
V  acnt = acnt + 1
V
V  addline.acnt = 'ADD,'job1',OWNER='owner',CLASS='class',JCLID='jcl_id||,
V
V               ',EXEC='exec_id','hold_id
V
V  acnt = acnt + 1
V
V  addline.acnt = 'SYSTEM='system',USERID='uid',MSGCLASS='msgclass||,
V
V               ',PRTY='prty',MAINID='mainid','
V
V  acnt = acnt + 1
V
V  If cond_code = "JOB" & rel_oper = "ANY" Then Do
V
V    addline.acnt = 'JOBNET='jobnet_name||,
V
V                   ',RELOPR=#S'||,
V
V                   ',MAINT='maint_id||,
V
V                   ','restart_id
V
V  End
V
V  Else Do
V
V    addline.acnt = 'JOBNET='jobnet_name||,
V
V                   ',CONDCODE='cond_code||,
V
V                   ',RELOPR='rel_oper||,
V
V                   ',MAINT='maint_id||,
V
V                   ','restart_id
V
V  End
V
V
V
V  If #type1 <> "" Then Do
V
V    addline.acnt = addline.acnt","
V
V    acnt = acnt + 1
V
V    addline.acnt = #line
V
V  End
V
V  Return
V
V
V
Vunixjob:
V
V  linenum2 = linenum + 1
V
V  Do Until Substr(in.linenum2,9,9) = '---------'
V
V    If Pos('Job Type:',in.linenum2) > 0 Then Do
V
V      jobtype = Strip(SubStr(in.linenum2,19,10))
V
V    End
V
V    If Pos('Agent: ',in.linenum2) > 0 Then Do
V
V      agentid = Strip(SubStr(in.linenum2,17,40))
V
V    End
V
V    linenum2 = linenum2 + 1
V
V    If Pos('Userid:',in.linenum2) > 0 Then Return
V
V  End
V
V  Return
V
V
V
VAdd_UNIX_Job:     /* got all the ADD variables - so ADD unix job */
V
V  acnt = acnt + 1
V
V  addline.acnt = 'DBM'
V
V  acnt = acnt + 1
V
V  addline.acnt = 'AGJOB'
V
V  acnt = acnt + 1
V
V  addline.acnt = 'ADD,'job1',SYSTEM='system',USERID='uid',AGJOBTYP='jobtype','
V
V  acnt = acnt + 1
V
V  addline.acnt = 'AGENT='agentid',PRMLIB='prmlib',EXEC='exec_id||,
V
V               ',PRTY='prty
V
V  /* extra lines below to reset back to normal job add's */
V
V  acnt = acnt + 1
V
V  addline.acnt = 'DBM'
V
V  acnt = acnt + 1
V
V  addline.acnt = 'JOB'
V
V  Return
V
V
V
Vschedules:
V
V  type = ' '
V
V  cal_schid = ' '
V
V  dowline = ' '
V
V  new_id_found = n
V
V  linenum1 = linenum
V
V  linenum2 = linenum + 1
V
V  Do Until Substr(in.linenum2,9,9) = '---------'
V
V    If Pos('LIST=ALL',in.linenum) > 0 |,
V
V       Pos('LIST=NODD',in.linenum) > 0 |,
V
V       Pos('---JCL---',in.linenum) > 0 |,
V
V       Pos('STP DDS RUNS',in.linenum) > 0 Then Iterate
V
V    linenum1 = linenum1+1
V
V    If Pos('LAST RESOLV',in.linenum1) > 0 Then Iterate
V
V    linenum2 = linenum1+1
V
V    If Pos('SLIA',in.linenum1) > 0 Then Return
V
V    If Substr(in.linenum1,26,8) = "CALENDAR" Then Do
V
V      cal_start = 'Y'
V
V      scal = Right(Word(in.linenum1,2),2)
V
V      cal_year = Substr(Word(in.linenum1,2),5,2)
V
V      ccnt = ccnt + 1
V
V      cal_oline.ccnt = "SCHD"
V
V      ccnt = ccnt + 1
V
V      cal_oline.ccnt = "JOB"
V
V      ccnt = ccnt + 1
V
V      cal_oline.ccnt = "EDIT"
V
V      Iterate
V
V    End
V
V    If Substr(in.linenum1,8,4) = " ID=" Then Do
V
V      cal_schid  = Substr(in.linenum1,12,3)
V
V      roll_opt   = Substr(in.linenum1,23,1)
V
V      index_opt  = Substr(in.linenum1,32,4)
V
V      dowline = ' '
V
V      Iterate
V
V    End
V
V    If Substr(in.linenum1,8,6) = " SCAL=" Then Do
V
V      dotm_pos   = Pos('DOTM=',in.linenum1) + 5
V
V      cal_dotm   = Substr(in.linenum1,dotm_pos,4)
V
V      leadtm_pos = Pos('LEADTM=',in.linenum1) + 7
V
V      cal_leadtm = Substr(in.linenum1,leadtm_pos,4)
V
V      subtm_pos  = Pos('SUBTM=',in.linenum1) + 6
V
V      cal_subtm  = Substr(in.linenum1,subtm_pos,4)
V
V      start_pos  = Pos('STARTM=',in.linenum1) + 7
V
V      cal_start  = Substr(in.linenum1,start_pos,4)
V
V      If subtm_pos = 6 Then time_line = "TIME=("cal_dotm","cal_leadtm")"
V
V      Else time_line = "TIME=("cal_dotm","cal_leadtm","cal_subtm")"
V
V      Iterate
V
V    End
V
V    If Substr(in.linenum1,8,7) = " REPEAT" Then Do
V
V      repeat_found = y
V
V      /*Say "       Repetative job found - building variables"*/
V
V      repeat_temp = Translate(in.linenum1,' ','=')
V
V      Rinterval = Word(repeat_temp,3)
V
V      Rtype     = Word(repeat_temp,5)
V
V      Rcount    = Word(repeat_temp,7)
V
V      Rstop     = Word(repeat_temp,9)
V
V      repeat_line = "INTERVAL="Rinterval",TYPE="Rtype",COUNT="Rcount",STOP="||,
V
V                    Rstop","
V
V      Iterate
V
V    End
V
V
V
V    ccnt = ccnt + 1
V
V    cal_oline.ccnt = "ADD,SCHID="cal_schid","||,
V
V                     "ROLL="roll_opt","||,
V
V                     "INDEX="index_opt","||,
V
V                      time_line","
V
V    If repeat_found = y Then Do
V
V      ccnt = ccnt + 1
V
V      cal_oline.ccnt =  repeat_line
V
V      repeat_found = n
V
V      repeat_line = " "
V
V    End
V
V                     /*"SCAL="scal","||,*/
V
V    new_id_found = y
V
V
V
V    linenum3 = linenum1
V
V    Do Until Substr(in.linenum3,8,4) = " ID="
V
V      If Substr(in.linenum3,9,9) = '---------' |,
V
V         Pos(' REQUEST COMPLETED ',in.linenum3) > 0 Then,
V
V            Signal ReBuild_All_Variables
V
V      If Substr(in.linenum3,9,9) = '---------' |,
V
V         Pos(' REQUEST COMPLETED ',in.linenum3) > 0 Then Return
V
V      linenum3 = linenum3 + 1
V
V      If Pos('SLIA',in.linenum1) > 0 Then Leave
V
V      If Pos('LIST=ALL',in.linenum1) > 0 |,
V
V         Pos('LIST=NODD',in.linenum1) > 0 |,
V
V         Pos('---JCL---',in.linenum1) > 0 |,
V
V         Pos('STP DDS RUNS',in.linenum1) > 0 Then Do
V
V          linenum1 = linenum1 + 1
V
V          Iterate
V
V      End
V
V      prev_type = type
V
V      type = Word(in.linenum1,1)
V
V      If type = 'DAILY'  Then Do
V
V        ccnt = ccnt + 1
V
V        cal_oline.ccnt = "DAILY=Y,"
V
V      End
V
V      If type = 'WEEKLY' Then Do
V
V        day_pos = Pos(' DAY=',in.linenum1) + 5
V
V        days = Strip(Substr(in.linenum1,day_pos,40))
V
V        days = Translate(days,' ',',')
V
V        day_words  = Words(days)
V
V        If Pos('SUN',days) > 0 then day1 = 'X,'
V
V        Else day1 = ','
V
V        If Pos('MON',days) > 0 then day2 = 'X,'
V
V        Else day2 = ','
V
V        If Pos('TUE',days) > 0 then day3 = 'X,'
V
V        Else day3 = ','
V
V        If Pos('WED',days) > 0 then day4 = 'X,'
V
V        Else day4 = ','
V
V        If Pos('THU',days) > 0 then day5 = 'X,'
V
V        Else day5 = ','
V
V        If Pos('FRI',days) > 0 then day6 = 'X,'
V
V        Else day6 = ','
V
V        If Pos('SAT',days) > 0 then day7 = 'X'
V
V        Else day7 = ','
V
V        day_list = "DAYS=("day1||day2||day3||day4||day5||day6||day7")"
V
V        wcnt = wcnt + 1
V
V        ccnt = ccnt + 1
V
V        cal_oline.ccnt = "WEEKLY=Y,"day_list","
V
V      End
V
V      If type = 'MONTHLY' Then Do
V
V        /*trace i*/
V
V        if cal_schid = '110' then NOP
V
V        day_pos   = Pos(' DAY=',in.linenum1)   + 5
V
V        rday_pos  = Pos(' RDAY=',in.linenum1)  + 6
V
V        nday_pos  = Pos(' NDAY=',in.linenum1)  + 6
V
V        nrday_pos = Pos(' NRDAY=',in.linenum1) + 7
V
V        week_pos  = Pos(' WEEK=',in.linenum1)  + 6
V
V        month_pos = Pos(' MONTH=',in.linenum1) + 7
V
V
V
V        If day_pos > 5 then Do
V
V          dow = Substr(in.linenum1,day_pos,40)
V
V          blank_pos = Pos(' ',dow)
V
V          dow = Strip(Substr(dow,1,blank_pos))
V
V          If Pos(dow,dowline) = 0 then Do
V
V            dowcnt = dowcnt + 1
V
V            dow_line.dowcnt = dow
V
V          End
V
V          dowline = dowline dow
V
V        End
V
V        If nday_pos > 6 then Do
V
V          dow = Substr(in.linenum1,nday_pos,40)
V
V          blank_pos = Pos(' ',dow)
V
V          dow = Strip(Substr(dow,1,blank_pos))
V
V          If Pos(dow,dowline) = 0 then Do
V
V            dowcnt = dowcnt + 1
V
V            dow_line.dowcnt = dow
V
V          End
V
V          dowline = dowline dow
V
V        End
V
V        If week_pos > 6 then Do
V
V          week = Substr(in.linenum1,week_pos,40)
V
V          blank_pos = Pos(' ',week)
V
V          week = Strip(Substr(week,1,blank_pos))
V
V          week = Strip(week,L,0)
V
V          w1cnt = w1cnt + 1
V
V          week_line.w1cnt = "/"week
V
V          If day_pos > 5 then week_line.w1cnt = week
V
V        End
V
V        If nday_pos > 6 then Do
V
V          nday_found = y
V
V          nday = Substr(in.linenum1,nday_pos,40)
V
V          blank_pos = Pos(' ',nday)
V
V          nday = Strip(Substr(nday,1,blank_pos))
V
V          ndaycnt = ndaycnt + 1
V
V          nday_line.ndaycnt = "/"nday
V
V        End
V
V        If rday_pos > 6 then Do
V
V          rday_found = y
V
V          rday = Strip(Substr(in.linenum1,rday_pos,3))
V
V          rdaycnt = rdaycnt + 1
V
V          rday_line.rdaycnt = rday
V
V        End
V
V        If nrday_pos > 7 then Do
V
V          If Pos('NRDAY=08',in.linenum1) > 0 then NOP
V
V          nrday_found = y
V
V          nrday = Substr(in.linenum1,nrday_pos,40)
V
V          blank_pos = Pos(' ',nrday)
V
V          nrday = Strip(Substr(nrday,1,blank_pos))
V
V          nrdaycnt = nrdaycnt + 1
V
V          nrday_line.nrdaycnt = "/"nrday
V
V        End
V
V        months = Strip(Substr(in.linenum1,month_pos,40))
V
V        months = Translate(months,' ',',')
V
V        month_words = Words(months)
V
V        month_found = y
V
V        If Pos('JAN',months) > 0 | WordPos('1',months) > 0 then m1 = 'X'
V
V        Else m1 = ''
V
V        If Pos('FEB',months) > 0 | WordPos('2',months) > 0 then m2 = 'X'
V
V        Else m2 = ''
V
V        If Pos('MAR',months) > 0 | WordPos('3',months) > 0 then m3 = 'X'
V
V        Else m3 = ''
V
V        If Pos('APR',months) > 0 | WordPos('4',months) > 0 then m4 = 'X'
V
V        Else m4 = ''
V
V        If Pos('MAY',months) > 0 | WordPos('5',months) > 0 then m5 = 'X'
V
V        Else m5 = ''
V
V        If Pos('JUN',months) > 0 | WordPos('6',months) > 0 then m6 = 'X'
V
V        Else m6 = ''
V
V        If Pos('JUL',months) > 0 | WordPos('7',months) > 0 then m7 = 'X'
V
V        Else m7 = ''
V
V        If Pos('AUG',months) > 0 | WordPos('8',months) > 0 then m8 = 'X'
V
V        Else m8 = ''
V
V        If Pos('SEP',months) > 0 | WordPos('9',months) > 0 then m9 = 'X'
V
V        Else m9 = ''
V
V        If Pos('OCT',months) > 0 | WordPos('10',months) > 0 then m10 = 'X'
V
V        Else m10= ''
V
V        If Pos('NOV',months) > 0 | WordPos('11',months) > 0 then m11 = 'X'
V
V        Else m11= ''
V
V        If Pos('DEC',months) > 0 | WordPos('12',months) > 0 then m12 = 'X'
V
V        Else m12= ''
V
V        If Pos('ALL',months) > 0 then Do
V
V          month_list = ""
V
V          month_list = "MONTHS=(X,X,X,X,X,X,X,X,X,X,X,X),"
V
V        End
V
V        Else Do
V
V          month_list = "MONTHS=("m1","m2","m3","m4","m5","m6","||,
V
V                                 m7","m8","m9","m10","m11","m12"),"
V
V        End
V
V        If month_found = y then Do
V
V          If new_id_found = y then Do
V
V            ccnt = ccnt + 1
V
V            cal_oline.ccnt = "MONTHLY=Y,"||month_list
V
V            new_id_found = n
V
V          End
V
V          month_found = n
V
V        End
V
V      End
V
V      If type = 'ANNUAL'  Then Do
V
V        day_pos   = Pos(' DAY=',in.linenum1)   + 5
V
V        nday_pos  = Pos(' NDAY=',in.linenum1)  + 6
V
V
V
V        If day_pos > 6 then Do
V
V          annday = Substr(in.linenum1,day_pos,40)
V
V          blank_pos = Pos(' ',annday)
V
V          annday = Strip(Substr(annday,1,blank_pos))
V
V          a1cnt = a1cnt + 1
V
V          annual_line.a1cnt = annday
V
V        End
V
V        If nday_pos > 6 then Do
V
V          annday = Substr(in.linenum1,nday_pos,40)
V
V          blank_pos = Pos(' ',annday)
V
V          annday = Strip(Substr(annday,1,blank_pos))
V
V          a1cnt = a1cnt + 1
V
V          annual_line.a1cnt = "/"annday
V
V        End
V
V        ccnt = ccnt + 1
V
V        cal_oline.ccnt = "ANNUAL=Y,"
V
V      End
V
V      linenum1 = linenum1 + 1
V
V    End
V
V
V
V    /* next ID found */
V
V    month_found = n
V
V    If dowcnt > 0 then Do
V
V      NOP
V
V      Do s1 = 1 to dowcnt
V
V        ccnt = ccnt + 1
V
V        cal_oline.ccnt = "DOW="dow_line.s1","
V
V      End
V
V    End
V
V    If rdaycnt > 0 then Do
V
V      Do s2 = 1 to rdaycnt
V
V        If s2 = 1 then Do
V
V          new_rday_line = "RDAYS="rday_line.s2
V
V          If rdaycnt = 1 then Do
V
V            ccnt = ccnt + 1
V
V            cal_oline.ccnt = new_rday_line","
V
V            Leave s2
V
V          End
V
V          Iterate s2
V
V        End
V
V        new_rday_line = new_rday_line rday_line.s2
V
V        If s2 = rdaycnt then Do
V
V          ccnt = ccnt + 1
V
V          cal_oline.ccnt = new_rday_line","
V
V        End
V
V      End
V
V    End
V
V    If w1cnt > 0 then Do
V
V      Do s3 = 1 to w1cnt
V
V        If s3 = 1 then Do
V
V          new_nday_line = "WEEKS="week_line.s3
V
V          If w1cnt = 1 then Do
V
V            ccnt = ccnt + 1
V
V            cal_oline.ccnt = new_nday_line","
V
V            Leave s3
V
V          End
V
V          Iterate s3
V
V        End
V
V        new_nday_line = new_nday_line week_line.s3
V
V        If s3 = w1cnt then Do
V
V          ccnt = ccnt + 1
V
V          cal_oline.ccnt = new_nday_line","
V
V        End
V
V      End
V
V    End
V
V    If nrdaycnt > 0 then Do
V
V      Do s4 = 1 to nrdaycnt
V
V        If s4 = 1 then Do
V
V          new_nrday_line = "RDAYS="nrday_line.s4
V
V          If nrdaycnt = 1 then Do
V
V            ccnt = ccnt + 1
V
V            cal_oline.ccnt = new_nrday_line","
V
V            Leave s4
V
V          End
V
V          Iterate s4
V
V        End
V
V        new_nrday_line = new_nrday_line nrday_line.s4
V
V        If s4 = nrdaycnt then Do
V
V          ccnt = ccnt + 1
V
V          cal_oline.ccnt = new_nrday_line","
V
V        End
V
V      End
V
V    End
V
V    If a1cnt > 0 then Do
V
V      Do s5 = 1 to a1cnt
V
V        If s5 = 1 then Do
V
V          new_annual_line = "ANNDAYS="annual_line.s5
V
V          If a1cnt = 1 then Do
V
V            ccnt = ccnt + 1
V
V            cal_oline.ccnt = new_annual_line","
V
V            Leave s5
V
V          End
V
V          Iterate s5
V
V        End
V
V        new_annual_line = new_annual_line annual_line.s5
V
V        If s5 = s1cnt then Do
V
V          ccnt = ccnt + 1
V
V          cal_oline.ccnt = new_annual_line","
V
V        End
V
V      End
V
V    End
V
V
V
V    dowcnt = 0
V
V    wcnt = 0
V
V    w1cnt = 0
V
V    rdaycnt = 0
V
V    ndaycnt = 0
V
V    nrdaycnt = 0
V
V
V
V    cal_oline.ccnt = Substr(cal_oline.ccnt,1,(Length(cal_oline.ccnt)-1))
V
V
V
V    linenum1 = linenum1 - 1
V
V  End
V
V
V
V  Return
V
V
V
VReBuild_All_Variables:
V
V  /* next ID found */
V
V  month_found = n
V
V  If dowcnt > 0 then Do
V
V    NOP
V
V    Do s1 = 1 to dowcnt
V
V      ccnt = ccnt + 1
V
V      cal_oline.ccnt = "DOW="dow_line.s1","
V
V    End
V
V  End
V
V  If rdaycnt > 0 then Do
V
V    Do s2 = 1 to rdaycnt
V
V      If s2 = 1 then Do
V
V        new_rday_line = "RDAYS="rday_line.s2
V
V        If rdaycnt = 1 then Do
V
V          ccnt = ccnt + 1
V
V          cal_oline.ccnt = new_rday_line","
V
V          Leave s2
V
V        End
V
V        Iterate s2
V
V      End
V
V      new_rday_line = new_rday_line rday_line.s2
V
V      If s2 = rdaycnt then Do
V
V        ccnt = ccnt + 1
V
V        cal_oline.ccnt = new_rday_line","
V
V      End
V
V    End
V
V  End
V
V  If w1cnt > 0 then Do
V
V    Do s3 = 1 to w1cnt
V
V      If s3 = 1 then Do
V
V        new_nday_line = "WEEKS="week_line.s3
V
V        If w1cnt = 1 then Do
V
V          ccnt = ccnt + 1
V
V          cal_oline.ccnt = new_nday_line","
V
V          Leave s3
V
V        End
V
V        Iterate s3
V
V      End
V
V      new_nday_line = new_nday_line week_line.s3
V
V      If s3 = w1cnt then Do
V
V        ccnt = ccnt + 1
V
V        cal_oline.ccnt = new_nday_line","
V
V      End
V
V    End
V
V  End
V
V  If nrdaycnt > 0 then Do
V
V    Do s4 = 1 to nrdaycnt
V
V      If s4 = 1 then Do
V
V        new_nrday_line = "RDAYS="nrday_line.s4
V
V        If nrdaycnt = 1 then Do
V
V          ccnt = ccnt + 1
V
V          cal_oline.ccnt = new_nrday_line","
V
V          Leave s4
V
V        End
V
V        Iterate s4
V
V      End
V
V      new_nrday_line = new_nrday_line nrday_line.s4
V
V      If s4 = nrdaycnt then Do
V
V        ccnt = ccnt + 1
V
V        cal_oline.ccnt = new_nrday_line","
V
V      End
V
V    End
V
V  End
V
V
V
V  dowcnt = 0
V
V  wcnt = 0
V
V  w1cnt = 0
V
V  rdaycnt = 0
V
V  ndaycnt = 0
V
V  nrdaycnt = 0
V
V
V
V  cal_oline.ccnt = Substr(cal_oline.ccnt,1,(Length(cal_oline.ccnt)-1))
V
V
V
V  /* build resolve statements */
V
V      ccnt = ccnt + 1
V
V      cal_oline.ccnt = "SAVE"
V
V      ccnt = ccnt + 1
V
V      cal_oline.ccnt = "SAVE,JOB="job1",SCAL="scal
V
V      ccnt = ccnt + 1
V
V      cal_oline.ccnt = "DBM"
V
V      ccnt = ccnt + 1
V
V      cal_oline.ccnt = "RESOLV,SCAL="scal",TEST=NO,JOB="job1",OLDYR=*,"||,
V
V                       "YEAR="cal_year",PRINT=YES"
V
V
V
V  linenum1 = linenum1 - 1
V
V
V
V  /* last line found and about to leave the SCHDEDULES section */
V
V  Return 0
V
V
V
Vtriggerby:
V
V  linenum1 = linenum
V
V  linenum2 = linenum + 1
V
V  linenum3 = linenum + 1
V
V  Do Until Substr(in.linenum2,9,9) = '---------'
V
V    If Pos('LIST=ALL',in.linenum) > 0 |,
V
V       Pos('LIST=NODD',in.linenum) > 0 |,
V
V       Pos('---JCL---',in.linenum) > 0 |,
V
V       Pos('STP DDS RUNS',in.linenum) > 0 then iterate
V
V    linenum1 = linenum1+1
V
V    linenum2 = linenum2+1
V
V    If Pos('SLIA',in.linenum1) > 0 Then Return
V
V    If Substr(in.linenum1,12,4) = "JOB=" Then Do
V
V      trigid   = '999' ; subtime  = '9999'
V
V      trgjob1     = Strip(Substr(in.linenum1,16,8))
V
V      schid_pos   = Pos(" SCHID=",in.linenum1) + 7
V
V      blank_pos   = Pos(" ",in.linenum1,schid_pos)
V
V      schids      = Substr(in.linenum1,schid_pos,(blank_pos-schid_pos))
V
V      schid_list  = Translate(schids," ","/")
V
V      schid_words =  Words(schid_list)
V
V      If schid_words = 1 then schid = schid_list
V
V      Else Do
V
V        schid = Word(schid_list,1)
V
V        trigid = Word(schid_list,2)
V
V      End
V
V      qtime     = Strip(Substr(in.linenum1,44,4))
V
V      ldtime    = Strip(Substr(in.linenum1,56,4))
V
V      subtime   = Strip(Substr(in.linenum1,68,4))
V
V      test_trig = trgjob1'->'job1'->'schid
V
V      If Pos(test_trig,trig_done_list) > 0 then Iterate
V
V      trig_done_list = trig_done_list' 'trgjob1'->'job1'->'schids
V
V      tbjcnt = tbjcnt + 1
V
V      tbjline.tbjcnt = "UPD,JTRG,JOB="trgjob1",OPT=A,TJOB="job1||,
V
V                       ",QTM="qtime",LEADTM="ldtime","
V
V      tbjcnt = tbjcnt + 1
V
V      tbjline.tbjcnt = "SCHID="schid
V
V      If trigid /= '999' then tbjline.tbjcnt = tbjline.tbjcnt",TRGID="trigid
V
V      If subtime /= '9999' & subtime /= '0000' then,
V
V         tbjline.tbjcnt = tbjline.tbjcnt",SBTM="subtime
V
V    End
V
V    If Substr(in.linenum1,12,4) = "DSN=" Then Do
V
V      gdg_req = 'Y'
V
V      tran_dsn_line = Translate(in.linenum1,' ','(')
V
V      tran_dsn_line = Translate(tran_dsn_line,' ',')')
V
V      trgdsn1       = Word(tran_dsn_line,2)
V
V      If Words(tran_dsn_line) = 3 Then Do
V
V        gdg_req = 'N'
V
V        trgdsn1 = trgdsn1'('Word(tran_dsn_line,3)')'
V
V      End
V
V      tlinenum1     = linenum1 + 1
V
V
V
V      /* ken 2013-02-06 15:45 start */
V
V      dschid_pos   = Pos(" SCHID=",in.tlinenum1) + 7
V
V      dblank_pos   = Pos(" ",in.tlinenum1,dschid_pos)
V
V      dschids      = Substr(in.tlinenum1,dschid_pos,(dblank_pos-dschid_pos))
V
V      dschid_list  = Translate(dschids," ","/")
V
V      dschid_words =  Words(dschid_list)
V
V      If dschid_words = 1 then Do
V
V        dschid = dschid_list
V
V        dtrgExtra = ",SCHID="dschid
V
V      End
V
V      If dschid_words > 1 then Do
V
V        dschid  = Word(dschid_list,1)
V
V        dtrigid = Word(dschid_list,2)
V
V        dtrgExtra = ",SCHID="dschid",TRGID="dtrigid
V
V      End
V
V      /* ken 2013-02-06 15:45 end   */
V
V
V
V      /* ken 2013-02-06 15:45 start */
V
V      If Pos("SIGNET.",trgdsn1) > 0 Then gdg_req = "N"
V
V      /* ken 2013-02-06 15:45 end   */
V
V
V
V      qtime         = Strip(Substr(in.tlinenum1,44,4))
V
V      adsncnt = adsncnt + 1
V
V      adsnline.adsncnt = "ADD,DSN="trgdsn1",TYPE=NORM,SMF=Y,GDG="gdg_req
V
V      tbdcnt = tbdcnt + 1
V
V      tbdline.tbdcnt = "UPD,DTRG,DSN="trgdsn1",OPT=A,"
V
V      tbdcnt = tbdcnt + 1
V
V      tbdline.tbdcnt = "TJOB="job1",QTM="qtime
V
V
V
V      /* ken 2013-02-06 15:45 start */
V
V      tbdline.tbdcnt = tbdline.tbdcnt||dtrgExtra
V
V      /* ken 2013-02-06 15:45 end   */
V
V
V
V      If Substr(in.linenum3,9,9) = '---------' then Return
V
V    End
V
V  End
V
V  Return
V
V
V
Vtrigger:
V
V  linenum1 = linenum
V
V  linenum2 = linenum + 1
V
V  Do Until Substr(in.linenum2,9,9) = '---------'
V
V    If Pos('LIST=ALL',in.linenum) > 0 |,
V
V       Pos('LIST=NODD',in.linenum) > 0 |,
V
V       Pos('---JCL---',in.linenum) > 0 |,
V
V       Pos('STP DDS RUNS',in.linenum) > 0 then iterate
V
V    linenum1 = linenum1+1
V
V    linenum2 = linenum2+1
V
V    If Pos('SLIA',in.linenum1) > 0 Then Return
V
V    If Substr(in.linenum1,12,4) = "JOB=" Then Do
V
V      trigid   = '999' ; subtime  = '9999'
V
V      trgjob1 = Strip(Substr(in.linenum1,16,8))
V
V      schid_pos   = Pos(" SCHID=",in.linenum1) + 7
V
V      blank_pos   = Pos(" ",in.linenum1,schid_pos)
V
V      schids      = Substr(in.linenum1,schid_pos,(blank_pos-schid_pos))
V
V      schid_list  = Translate(schids," ","/")
V
V      schid_words =  Words(schid_list)
V
V      If schid_words = 1 then schid = schid_list
V
V      Else Do
V
V        schid = Word(schid_list,1)
V
V        trigid = Word(schid_list,2)
V
V      End
V
V      qtime     = Strip(Substr(in.linenum1,44,4))
V
V      ldtime    = Strip(Substr(in.linenum1,56,4))
V
V      subtime   = Strip(Substr(in.linenum1,68,4))
V
V      test_trig = job1'->'trgjob1'->'schid
V
V      If Pos(test_trig,trig_done_list) > 0 then Iterate
V
V      trig_done_list = trig_done_list' 'job1'->'trgjob1'->'schids
V
V      tcnt = tcnt + 1
V
V      trigline.tcnt = "UPD,JTRG,JOB="job1",OPT=A,TJOB="trgjob1||,
V
V                      ",QTM="qtime",LEADTM="ldtime","
V
V      /* ken test     ",QTM=0010,LEADTM=0010,"     */
V
V      tcnt = tcnt + 1
V
V      trigline.tcnt = "SCHID="schid
V
V      If trigid /= '999' then trigline.tcnt = trigline.tcnt",TRGID="trigid
V
V      If subtime /= '9999' & subtime /= '0000' then,
V
V         trigline.tcnt = trigline.tcnt",SBTM="subtime
V
V    End
V
V  End
V
V  Return
V
V
V
Vsuccess:
V
V  linenum1 = linenum
V
V  linenum2 = linenum + 1
V
V  Do Until Substr(in.linenum2,9,9) = '---------'
V
V    linenum1 = linenum1+1
V
V    linenum2 = linenum2+1
V
V    If Pos('SLIA',in.linenum1) > 0 Then Return
V
V    If Substr(in.linenum1,12,4) = 'JOB=' Then Do
V
V      sucjob1 = Strip(Substr(in.linenum1,16,9))
V
V      schid   = Strip(Substr(in.linenum1,31,5))
V
V      If Substr(sucjob1,1,1) = '/' Then Do
V
V        sucjob1a    = Translate(sucjob1,' ','/')
V
V        neg_dep_job = Translate(job1,' ','/')
V
V        neg_dep_job = Strip(neg_dep_job)
V
V        neg_list = sucjob1a'/'neg_dep_job
V
V        If Pos(neg_list,neg_dep_list) = 0 then Do
V
V          neg_dep_list = neg_dep_list' 'sucjob1a'/'neg_dep_job
V
V        End
V
V      End
V
V      Else Do
V
V        ldtime2 = ''
V
V        Call Extract_From_Ca72 node "LJOB,LIST=RQJOB,JOB="sucjob1
V
V        Do sx = 1 to list2.0
V
V          Parse Pull InLine2
V
V          If SubStr(InLine2,9,12) = "JOB="job1 Then Do
V
V            ldtime2 = Word(InLine2,4)
V
V            ldtime2_hh = Strip(SubStr(ldtime2,8,4))
V
V            If ldtime2_hh = "" Then ldtime2_hh = "00"
V
V            /*If Length(ldtime2_hh) < 4 Then ldtime2 = Right(ldtime2_hh,4,'0')*
V/
V            If ldtime2_hh = "00" then ldtime2 = ""
V
V            Else ldtime2 = ",LEADTM="ldtime2_hh
V
V            Address TSO "delstack"
V
V            Leave sx
V
V          End
V
V        End
V
V        scnt = scnt + 1
V
V        sline.scnt = "UPD,JOB,"sucjob1",OPT=A,PRED="job1||ldtime2
V
V        If schid = '000' then Iterate
V
V        sline.scnt = sline.scnt',SCHID='schid
V
V      End
V
V    End
V
V  End
V
V  Return
V
V
V
Vvrm:
V
V  linenum1 = linenum
V
V  linenum2 = linenum + 1
V
V  Do Until Substr(in.linenum2,9,9) = '---------'
V
V    If Pos('LIST=ALL',in.linenum) > 0 |,
V
V       Pos('LIST=NODD',in.linenum) > 0 |,
V
V       Pos('---JCL---',in.linenum) > 0 |,
V
V       Pos('STP DDS RUNS',in.linenum) > 0 then iterate
V
V    linenum1 = linenum1+1
V
V    linenum2 = linenum2+1
V
V    If Pos('SLIA',in.linenum1) > 0 Then Return
V
V    vrm_type = Substr(in.linenum1,9,3)
V
V    If WordPos(vrm_type,vrm_list) > 0 Then Do
V
V      vrm_name = Strip(Substr(in.linenum1,13,40))
V
V      schid    = Strip(Substr(in.linenum2,35,5))
V
V      free_id  = Substr(in.linenum2,46,1)
V
V      test_vrm = job1'->'vrm_type'->'vrm_name'->'schid
V
V      If Pos(test_vrm,vrm_done_list) > 0 then Iterate
V
V      vrm_done_list = vrm_done_list' 'job1'->'vrm_type'->'vrm_name'->'schid
V
V      vcnt = vcnt + 1
V
V      vrmline.vcnt = "UPD,RM.1,JOB="job1",OPT=A"||,
V
V                     ",TYPE="vrm_type",FREE="free_id",SCHID="schid","
V
V      vcnt = vcnt + 1
V
V      vrmline.vcnt = "RSRC="vrm_name
V
V    End
V
V  End
V
V  Return
V
V
V
Vreqjobs:
V
V  linenum1 = linenum
V
V  Do Until Pos('SLIA',in.linenum1) > 0
V
V    linenum1 = linenum1 + 1
V
V    If Substr(in.linenum1,2,Length(job_prefix)) = job_prefix Then Return 0
V
V    If Substr(in.linenum1,9,4) = 'JOB=' &,
V
V       Pos('SCHID',in.linenum1) > 0 Then Do
V
V      req_words = Words(in.linenum1)
V
V      If req_words = 4 then ldtime = ','Word(in.linenum1,4)
V
V      Else ldtime = ''
V
V      reqjob1 = Strip(Substr(in.linenum1,13,9))
V
V      schid   = Strip(Substr(in.linenum1,35,5))
V
V      If Substr(reqjob1,1,1) = '/' Then Do
V
V        job1a       = Translate(job1,' ','/')
V
V        neg_dep_job = Translate(reqjob1,' ','/')
V
V        neg_dep_job = Strip(neg_dep_job)
V
V        neg_list = job1a'/'neg_dep_job
V
V        If Pos(neg_list,neg_dep_list) = 0 then Do
V
V          neg_dep_list = neg_dep_list' 'job1a'/'neg_dep_job
V
V        End
V
V      End
V
V      Else Do
V
V        rcnt = rcnt + 1
V
V        rline.rcnt = "UPD,JOB,"job1",OPT=A,PRED="reqjob1||ldtime
V
V        If schid = '000' then Iterate
V
V        rline.rcnt = rline.rcnt',SCHID='schid
V
V      End
V
V    End
V
V    If Substr(in.linenum1,9,4) = 'USR=' then Do
V
V      nxlinenum = linenum1 + 1
V
V      If Left(in.nxlinenum,6) = '1LJOB,' Then nxlinenum = nxlinenum + 6
V
V      user_req = Strip(Substr(in.linenum1,13,59))
V
V      schid    = Strip(Substr(in.nxlinenum,35,5))
V
V      If Strip(SubStr(in.linenum1,72,7)) = "(ONLY)" Then nxrun = "ONLY"
V
V      Else nxrun = "YES"
V
V      ucnt = ucnt + 1
V
V      usrline.ucnt = "UPD,USR,"job1",OPT=C,USR="user_req","
V
V      If Length(usrline.ucnt) < 55 | Length(usrline.ucnt) = 55 Then Do
V
V        usrline.ucnt = usrline.ucnt||"NEXTRUN="nxrun
V
V      End
V
V      Else Do
V
V        ucnt = ucnt + 1
V
V        usrline.ucnt = "NEXTRUN="nxrun
V
V      End
V
V      If schid = '000' then Iterate
V
V      usrline.ucnt = usrline.ucnt','
V
V      ucnt = ucnt + 1
V
V      usrline.ucnt = "SCHID="schid
V
V    End
V
V  End
V
V  Return
V
V
V
Vnegjobs:
V
V  Do n = 1 to Words(neg_dep_list)
V
V    jobs = Word(neg_dep_list,n)
V
V    jobs = Translate(jobs,' ','/')
V
V    negjob1 = Word(jobs,1)
V
V    negjob2 = Word(jobs,2)
V
V    neg_check1 = negjob1'/'negjob2
V
V    neg_check2 = negjob2'/'negjob1
V
V    If Pos(neg_check1,neg_done_list) > 0 |,
V
V       Pos(neg_check2,neg_done_list) > 0 then Iterate n
V
V    ncnt = ncnt + 1
V
V    nline.ncnt = "UPD,JOB,"negjob1",OPT=A,PRED=/"negjob2
V
V    ncnt = ncnt + 1
V
V    nline.ncnt = "UPD,JOB,"negjob2",OPT=A,PRED=/"negjob1
V
V    neg_done_list = neg_done_list neg_check1 neg_check2
V
V  End
V
V  Return
V
V
V
VExtract_From_CA72:
V
V  Parse UPPER Arg node command
V
V
V
VExecute_CA72:
V
V  rslt = cal2x2wa()
V
V  Select
V
V    When Right(node,2) = "D2" Then Do
V
V      ca7_node = "CCIIND2"
V
V      ca7_ssct = "CA71"
V
V      uid_pass = "UCC701,U7SVC01}"
V
V    End
V
V    When Right(node,2) = "P2" Then Do
V
V      ca7_node = "CCIINP2"
V
V      ca7_ssct = "CA71"
V
V      uid_pass = "UCC701,U7SVC01}"
V
V    End
V
V    OtherWise NOP
V
V  End
V
V
V
V  ca7_debug = "N}  "
V
V
V
V  Address CA7 "/LOGON  "uid_pass||Command
V
V
V
VQueue_Results2:
V
V  Drop LIST2.
V
V  LIST2.0 = Queued()
V
V
V
V  Return
V
V
V
VMEMBER NAME  CHCKDTA4
V/*==================================  REXX  ==================================*
V/
V/*    Name          -   CHCKDTA4                                              *
V/
V/*    Author        -   David Jones                                           *
V/
V/*    Written       -   30th June 2011                                        *
V/
V/*    Environment   -   Batch                                                 *
V/
V/*    Version       -   1.0                                                   *
V/
V/*    Modified by   -                                                         *
V/
V/*    Modified Date -                                                         *
V/
V/*    Function      -   To identify if dsn is a null file by returning RC=04  *
V/
V/*    Parm          -   None                                                  *
V/
V/*==================================  REXX  ==================================*
V/
VSay 'CHCKDTA4 - Version 1.0 30/06/2011'
V
V  "EXECIO 3 DISKR INFILE (STEM REC. FINIS"
V
V
V
V  IF REC.0 <= 2 THEN
V
VDO
V
V  say '##########################################################'
V
V  say '#                                                        #'
V
V  say '#  Input file is empty or only contains header/trailer   #'
V
V  say '#                                                        #'
V
V  say '##########################################################'
V
V     exit 4
V
V     END
V
V  ELSE
V
V     exit 0
V
VMEMBER NAME  CHECKDT1
V/*=============================  REXX  ==============================*/
V
V/*                                                                   */
V
V/*    NAME          -   CHECKDT1                                     */
V
V/*    AUTHOR        -   MARK ROUNCE                                  */
V
V/*    WRITTEN       -   27TH APRIL 2004                              */
V
V/*    ENVIRON       -   Batch                                        */
V
V/*    VERSION       -   1                                            */
V
V/*    MODIFIED BY   -                                                */
V
V/*    MODIFIED DATE -                                                */
V
V/*    FUNCTION      -   TO IDENTIFY IF DSN IS 1 OR LESS RECORDS      */
V
V/*    PARM          -   None                                         */
V
V/*                                                                   */
V
V/*===================================================================*/
V
V  "EXECIO * DISKR INFILE (STEM REC. FINIS"
V
V
V
V  IF REC.0 <= 1 THEN
V
VDO
V
V  say '##########################################################'
V
V  say '#                                                        #'
V
V  say '#    file contains no data transmission not triggered    #'
V
V  say '#                                                        #'
V
V  say '##########################################################'
V
V     exit 1
V
V     END
V
V  ELSE
V
V     exit 0
V
VMEMBER NAME  CHECKDT4
V/*=============================  REXX  ==============================*/
V
V/*                                                                   */
V
V/*    NAME          -   CHECKDT4                                     */
V
V/*    AUTHOR        -   MARK ROUNCE                                  */
V
V/*    WRITTEN       -   14TH JAN 2004                                */
V
V/*    ENVIRON       -   Batch                                        */
V
V/*    VERSION       -   1                                            */
V
V/*    MODIFIED BY   -                                                */
V
V/*    MODIFIED DATE -                                                */
V
V/*    FUNCTION      -   TO IDENTIFY IF DSN IS 5 OR LESS RECORDS      */
V
V/*    PARM          -   None                                         */
V
V/*                                                                   */
V
V/*===================================================================*/
V
V  "EXECIO * DISKR INFILE (STEM REC. FINIS"
V
V
V
V  IF REC.0 <= 5 THEN
V
VDO
V
V  say '##########################################################'
V
V  say '#                                                        #'
V
V  say '#    file contains no data transmission not triggered    #'
V
V  say '#                                                        #'
V
V  say '##########################################################'
V
V     exit 1
V
V     END
V
V  ELSE
V
V     exit 0
V
VMEMBER NAME  FALCOUNT
VParse SOURCE . . exec_name .
V
Vver = "0.1"
V
VSay
V
VSay "Starting "exec_name" version "ver" on "Date(W) Date()" at "Time()
V
VSay
V
Vparse arg count
V
V
V
VIf datatype(count) <> 'NUM' Then
V
V  Do
V
V    say
V
V    say '     Error:'
V
V    say '     Non numeric parm passed to exec'
V
V    say
V
V    exit 4
V
V  End
V
V
V
VIf words(count) <> 1 Then
V
V  Do
V
V    say
V
V    say '     Error:'
V
V    say '     incorrect amount of parms passed to exec there should only '
V
V    say '     be 1 parm passed. This should be the number of records that '
V
V    say '     contistute the file being null.'
V
V    say
V
V    exit 4
V
V  End
V
V
V
V
V
V"Execio 4 Diskr INPUT (stem REC. finis"
V
V
V
V  If REC.0 <= count Then
V
VDo
V
V  say '    count does not meet criteria transmission not triggered'
V
V  Say
V
V  Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at "Time()
V
V  Say
V
V   exit 1
V
VEnd
V
V  ELSE
V
V    say '    count meets criteria transmission triggered'
V
V    Say
V
V    Say
V
V    Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at "Time()
V
V    Say
V
V    Exit 0
V
VMEMBER NAME  GREG2JUL
V/*=============================  REXX  ==============================*/
V
V/*                                                                   */
V
V/*    NAME          -   GREG2JUL                                     */
V
V/*    AUTHOR        -   Stuart Dolman                                */
V
V/*    WRITTEN       -   21st July 1996                               */
V
V/*    ENVIRON       -   Called by REXX SWNDMUP1                      */
V
V/*    VERSION       -   1                                            */
V
V/*    MODIFIED BY   -   Stuart Dolman                                */
V
V/*    MODIFIED DATE -   1st March 2000                               */
V
V/*    FUNCTION      -   To convert gregorian date to julian          */
V
V/*                                                                   */
V
V/*===================================================================*/
V
V
V
Varg day month year
V
V
V
Vif month = '01' then tot = day
V
V
V
Vif month = '02' then tot = day + 31
V
V
V
Vif month = '03' then tot = day + 59
V
V
V
Vif month = '04' then tot = day + 90
V
V
V
Vif month = '05' then tot = day + 120
V
V
V
Vif month = '06' then tot = day + 151
V
V
V
Vif month = '07' then tot = day + 181
V
V
V
Vif month = '08' then tot = day + 212
V
V
V
Vif month = '09' then tot = day + 243
V
V
V
Vif month = '10' then tot = day + 273
V
V
V
Vif month = '11' then tot = day + 304
V
V
V
Vif month = '12' then tot = day + 334
V
V
V
Vif tot > 59 & month > 2 then rem = year//4
V
V
V
Vif rem = 0 then tot = tot + 1
V
V
V
Vtot = right(tot,3,'0')
V
V
V
Vb = year||tot
V
V
V
Vreturn b
V
VMEMBER NAME  LRUNTASK
V/* rexx */
V
Vclear
V
VInitialise_Version:
V
V  ver = "0.1"
V
V
V
VIssue_Message:
V
V  Say
V
V  Say "Starting LRUNTASK version "ver" on "Date(W) Date()" at "Time()
V
V  Say
V
V
V
VGet_DataSetNames_From_Invoking_Jcl:
V
V  x = Listdsi(INPUT FILE)
V
V  InDsn = SysDsname
V
V
V
V  x = Listdsi(CURRGEN FILE)
V
V  CurrGen =  SysDsname
V
V
V
VIf_Error:
V
V  If Right(CurrGen,3) <> "V00" Then Do
V
V    Say "  Error in supplied file name "CurrGen
V
V    Exit 12
V
V  End
V
V
V
VInitialise_Variables:
V
V  GV00 = SubStr(CurrGen,(Length(CurrGen)-7),8)
V
V
V
V  old_gen_num = SubStr(GV00,2,4)
V
V  new_gen_num = old_gen_num + 1
V
V  new_gen_num = Right(new_gen_num,4,'0')
V
V
V
V  next_gen = "G"new_gen_num"V00"
V
V
V
V  OutDsn = SubStr(CurrGen,1,(Length(CurrGen)-9))"."next_gen
V
V
V
V  "Rename '"InDsn"' '"OutDsn"'"
V
V  If rc <> 0 Then Do
V
V    Say "  Return Code " rc " from Rename"
V
V    Exit rc
V
V  End
V
V  Else Do
V
V    Say "  Rename successfull "
V
V    Say "    Original file name       "InDsn
V
V    Say "    Renamed file name        "OutDsn
V
V  End
V
V
V
VExit:
V
V  Say
V
V  Say "Ending   LRUNTASK version "ver" on "Date(W) Date()" at "Time()
V
V  Say
V
V  Exit 0
V
VMEMBER NAME  PFILREXX
V/* Rexx */
V
V/*                                                                            *
V/
V/* Function:                                                                  *
V/
V/* Determine FILENAME, SNODE or IP ADDRESS, and pass details to Integrity     *
V/
V/* check program DZD040.                                                      *
V/
V/* Abend if any issues encountered.                                           *
V/
V/*                                                                            *
V/
V/* Key Steps:                                                                 *
V/
V/* Establish if Connect Direct, FTP or SFTP is being used, and invoke         *
V/
V/* specific check routines accordingly.                                       *
V/
V/*                                                                            *
V/
V/* Common Checks                                                              *
V/
V/* Check if ´non gdg´ file is being checked - continue but hilight issue      *
V/
V/*                                                                            *
V/
V/* Connect Direct (CD) Process - specific checks                              *
V/
V/* Interogate CDIRECT.PARMS (member passsed from jcl) to find CD Process Name *
V/
V/* Interogate CDIRECT.BASE (Process Name) to find SNODE name and SEND type    *
V/
V/* Interogate CDIRECT.PARMS (member passsed from jcl) to find File Name       *
V/
V/* Check that both INFILE and PARM file are the same                          *
V/
V/* Write values to OUTPUT1, passed as ATCC to program DZD040                  *
V/
V/*                                                                            *
V/
V/* Secure File Transfer Protocol (SFTP) Process - specific checks             *
V/
V/* Interogate FTP.PARMS (member passsed from jcl) to find IP address          *
V/
V/* Interogate FTP.PARMS to check that process name = passed process name      *
V/
V/* Reformat IP Address to 15 characters (pad with leading zero's)             *
V/
V/* Write values to OUTPUT1, passed as ATCC to program DZD040                  *
V/
V/*                                                                            *
V/
V/******************************************************************************
V/
V/* Updated : v0.3 Thursday  20th October 2016 - Ken Balnave                   *
V/
V/*   Added SFTP check process.                                                *
V/
V/*   Changed the MSGID's and Exit rc's.                                       *
V/
V/******************************************************************************
V/
V/* Updated : v0.2 Tuesday 3rd May 2016 - Ken Balnave                          *
V/
V/*   Added BYPASS process to ignore checking of PARM members (CD only).       *
V/
V/******************************************************************************
V/
V/* Updated : v0.1 Tuesday 23rd Feb 2016 - Ken Balnave                         *
V/
V/*   Initial write.                                                           *
V/
V/******************************************************************************
V/
V
V
V  ver = "v0.3"
V
V  Say ; Say " Starting PFILREXX "ver" on "Date(w) Date()" at "Time() ; Say
V
V
V
VCollect_PROCESS_TYPE_BYPASS_Parms:
V
V  Parse Upper Arg process type bypass
V
V  If process = "" | process = "&PROCESS" Then Do
V
V    wtomsg1 = "++"
V
V    wtomsg2 = "++  MSGID 10 - INVALID OR MISSING PROCESS FIELD ENTERED"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    Say "   Missing or invalid PROCESS field entered" ; Say
V
V    Exit 10
V
V  End
V
V  If type /= "CD" & type /= "FTP" & type /= "SFTP" Then Do
V
V    wtomsg1 = "++"
V
V    wtomsg2 = "++  MSGID 11 - INVALID OR MISSING TYPE FIELD ENTERED"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    Say "   Missing or invalid TYPE field entered" ; Say
V
V    Exit 11
V
V  End
V
V  If bypass /= "N" & bypass /= "Y" Then Do
V
V    wtomsg1 = "++"
V
V    wtomsg2 = "++  MSGID 13 - INVALID BYPASS FIELD ENTERED"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    Say "   Invalid BYPASS field entered" ; Say
V
V    Exit 13
V
V  End
V
V
V
VCollect_Allocated_Files:
V
V  st_trap = outtrap(var.)
V
V  "LISTA ST"
V
V  st_trap = outtrap(off)
V
V
V
VInitialise_File_Names:
V
V  Do i = 1 to var.0
V
V    Parse var var.i v1 v2 v3 v4
V
V    prev = i - 1
V
V    If Pos("INFILE",v1) > 0 Then Do
V
V      line = Strip(var.prev)
V
V      line = Translate(line,' ','(')
V
V      chkdsn = Word(line,1)
V
V      If Right(chkdsn,3) = "V00" Then Do
V
V        chkdsn = SubStr(chkdsn,1,(Length(chkdsn)-9))
V
V        Leave i
V
V      End
V
V      Else Do
V
V        wtomsg1 = "++"
V
V        wtomsg2 = "++  MSGID 07 - "chkdsn" is not a GDG file  +++"
V
V        "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V        "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"
V
V        "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V        Say "   File being checked is NOT A GDG file"
V
V        Say "     "chkdsn  ; Say
V
V        /*Exit 07*/
V
V      End
V
V    End
V
V  End
V
V
V
VInitiliase:
V
V  proc_found = n
V
V  sftp_found = n
V
V  parm_line  = " "
V
V  Select
V
V    When MVSVAR(SYSSMFID) = 'IND2' Then Do
V
V      In_Parm = "CDIRECT.TEST.PARMS"
V
V      In_Base = "CDIRECT.TEST.BASE"
V
V      In_FTP  = "FTP.TEST.PARMS"
V
V    End
V
V    When MVSVAR(SYSSMFID) = 'INP2' Then Do
V
V      In_Parm = "CDIRECT.PARMS"
V
V      In_Base = "CDIRECT.BASE"
V
V      In_FTP  = "FTP.PARMS"
V
V    End
V
V  End
V
V
V
V  If type = "FTP"  Then Signal FTP_Section
V
V  If type = "SFTP" Then Signal SFTP_Section
V
V
V
VCD_Section:
V
V  CD_parm_lib = In_Parm"("Strip(process)")"
V
V
V
VAllocate_Read_Free_Parm:
V
V  Drop parm.
V
V  "alloc fi(INPARM) da('"CD_parm_lib"') shr "
V
V  "execio * diskR INPARM (stem parm. finis)"
V
V  "free fi(INPARM)"
V
V
V
VRead_Parm_Get_Values:
V
V  Do a = 1 to parm.0
V
V    parm_line = parm_line" "Strip(parm.a)
V
V    If Pos("PROC=",parm.a) > 0 Then Do
V
V      proc_found = y
V
V      Parse Var parm.a start "PROC=" proc_name remain
V
V      base_lib = In_Base"("Strip(proc_name)")"
V
V    End
V
V  End
V
V  If proc_found = n Then Do
V
V    wtomsg1 = "++"
V
V    wtomsg2 = "++  MSGID 14 - PROC STATEMENT NOT FOUND IN "CD_parm_lib
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    Say "   PROC statement not found in "CD_parm_lib ; Say
V
V    Exit 14
V
V  End
V
V
V
VAllocate_Read_Free_Base:
V
V  Drop base.
V
V  "alloc fi(INBASE) da('"base_lib"') shr "
V
V  "execio * diskR INBASE (stem base. finis)"
V
V  "free fi(INBASE)"
V
V
V
VRead_Base:
V
V  chkF = n
V
V  Do b = 1 to base.0
V
V    If Pos(" PROCESS ",base.b) > 0 & Pos(" SNODE=",base.b) > 0 Then Do
V
V      Parse Var base.b start "SNODE=" snode
V
V      snode = Word(snode,1)
V
V    End
V
V    If Pos("FROM",base.b) > 0 & Pos("DSN=",base.b) > 0 Then Do
V
V      If Pos(",DISP",base.b) > 0 Then Do
V
V        Parse Var base.b start "DSN=" stype "," remain
V
V      End
V
V      Else Do
V
V        Parse Var base.b start "DSN=" stype remain
V
V      End
V
V      chkF = y
V
V      Leave b
V
V    End
V
V  End
V
V  If chkF = n Then Do
V
V    wtomsg1 = "++"
V
V    wtomsg2 = "++  MSGID 15 - INVALID LAYOUT DETECTED IN "base_lib
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    Say "   INVALID layout detected in "base_lib ; Say
V
V    Exit 15
V
V  End
V
V
V
VFind_Sending_DataSetName:
V
V  parm_line = Translate(parm_line," ","=")
V
V  wpos = WordPos(stype,parm_line) + 1
V
V  sdsn = Word(parm_line,wpos)
V
V  sdsn = Translate(sdsn," ","(")
V
V  sdsn = Word(sdsn,1)
V
V
V
V  If bypass = "Y" Then Do
V
V    Say "   BYPASS mode in effect. PARMLIB dataset not verified."
V
V    Say "   Check dataset passed      = "chkdsn
V
V    Say "   Encrypted PARMLIB dataset = "sdsn ; Say
V
V    sdsn = chkdsn
V
V    Signal Create_CD_Line
V
V  End
V
V
V
V  If chkdsn <> sdsn Then Do
V
V    wtomsg1 = "++"
V
V    wtomsg2 = "++  MSGID 16 - SERIOUS ERROR - MISMATCH DETECTED"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    Say "   Serious error - mismatch in what is being checked in JCL",
V
V        "and what is being sent in "CD_parm_lib
V
V    Say "     Checking  -  "chkdsn
V
V    Say "     Sending   -  "sdsn
V
V    Say
V
V    Exit 16
V
V  End
V
V
V
VCreate_CD_Line:
V
V  DummyLine = "SNODE"
V
V  DummyLine = Overlay(stype,DummyLine,26)
V
V  Say "   "DummyLine
V
V  oline.1 = Translate(snode)
V
V  oline.1 = Overlay(sdsn,oline.1,26)
V
V  Say "   "oline.1"              <=== This line passed to DZD040"
V
V
V
V  Signal Write_ATCC
V
V
V
V
V
VFTP_Section:
V
V  If type = "FTP" Then Do
V
V    wtomsg1 = "++"
V
V    wtomsg2 = "++  MSGID 99 - FTP SECTION NOT VALID YET"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    Say "   FTP process not created yet" ; Say
V
V    Exit 99
V
V  End
V
V
V
V  Signal Write_ATCC
V
V
V
V
V
VSFTP_Section:
V
V  INprocess = Overlay("IN",process,1)
V
V  SFTP_parm_lib = In_FTP"("Strip(INprocess)")"
V
V
V
VAllocate_Read_Free_Parm:
V
V  Drop parm.
V
V  "alloc fi(INPARM) da('"SFTP_parm_lib"') shr "
V
V  "execio * diskR INPARM (stem parm. finis)"
V
V  "free fi(INPARM)"
V
V
V
VRead_Parm_Get_Values:
V
V  Do a = 1 to parm.0
V
V    parm_line = parm_line" "Strip(parm.a)
V
V    If Pos("sftp ",parm.a) > 0 | Pos("SFTP ",parm.a) > 0 Then Do
V
V      sftp_found = y
V
V      Parse Var parm.a start "-b " proc_name middle "@" ip_address remain
V
V      If Pos("/",proc_name) > 0 Then Do
V
V        proc_name = Translate(proc_name," ","/")
V
V        wpn = Words(proc_name)
V
V        proc_name = Word(proc_name,wpn)
V
V      End
V
V    End
V
V  End
V
V  If sftp_found = n Then Do
V
V    wtomsg1 = "++"
V
V    wtomsg2 = "++  MSGID 17 - SFTP STATEMENT NOT FOUND IN "SFTP_parm_lib
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    Say "   SFTP statement not found in "SFTP_parm_lib ; Say
V
V    Exit 17
V
V  End
V
V
V
V  If process <> proc_name Then Do
V
V    wtomsg1 = "++"
V
V    wtomsg2 = "++  MSGID 18 - MISMATCH DETECTED IN PROCESS NAME"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"
V
V    "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"
V
V    Say "   Mismatch between passed process name "process" and 'IN' member",
V
V        "process name "proc_name
V
V    Exit 18
V
V  End
V
V
V
VPad_IP_Address:
V
V  temp_ip_address = Translate(ip_address," ",".")
V
V  new_ip_address = ""
V
V  Do ip = 1 to 4
V
V    new_ip_add = Right(Word(temp_ip_address,ip),3,"0")"."
V
V    new_ip_address = new_ip_address||new_ip_add
V
V  End
V
V  new_ip_address = SubStr(new_ip_address,1,15)
V
V
V
VCreate_SFTP_Line:
V
V  DummyLine = "IP-ADDRESS"
V
V  DummyLine = Overlay("DSN",DummyLine,26)
V
V  Say "   "DummyLine
V
V  oline.1 = new_ip_address
V
V  oline.1 = Overlay(chkdsn,oline.1,26)
V
V  Say "   "oline.1"              <=== This line passed to DZD040"
V
V
V
V  Signal Write_ATCC
V
V
V
VWrite_ATCC:
V
V  "execio 1 diskW output1 (stem oline. finis"
V
V  "free fi(output1)"
V
V
V
V  Say ; Say " Ending PFILREXX "ver" on "Date(w) Date()" at "Time() ; Say
V
V
V
VExit: exit 0
V
VMEMBER NAME  RUNTASK
V  If REC.0 <= count Then
V
VDo
V
V  say '    count does not meet criteria transmission not triggered'
V
V  Say
V
V  Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at "Time()
V
V  Say
V
V   exit 1
V
VEnd
V
V  ELSE
V
V    say '    count meets criteria transmission triggered'
V
V    Say
V
V    Say
V
V    Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at "Time()
V
V    Say
V
V    Exit 0
V
V/* rexx */
V
Vclear
V
VInitialise_Version:
V
V  ver = "0.1"
V
V
V
VIssue_Message:
V
V  Say
V
V  Say "Starting LRUNTASK version "ver" on "Date(W) Date()" at "Time()
V
V  Say
V
V
V
VGet_DataSetNames_From_Invoking_Jcl:
V
V  x = Listdsi(INPUT FILE)
V
V  InDsn = SysDsname
V
V
V
V  x = Listdsi(CURRGEN FILE)
V
V  CurrGen =  SysDsname
V
V
V
VIf_Error:
V
V  If Right(CurrGen,3) <> "V00" Then Do
V
V    Say "  Error in supplied file name "CurrGen
V
V    Exit 12
V
V  End
V
V
V
VInitialise_Variables:
V
V  GV00 = SubStr(CurrGen,(Length(CurrGen)-7),8)
V
V
V
V  old_gen_num = SubStr(GV00,2,4)
V
V  new_gen_num = old_gen_num + 1
V
V  new_gen_num = Right(new_gen_num,4,'0')
V
V
V
V  next_gen = "G"new_gen_num"V00"
V
V
V
V  OutDsn = SubStr(CurrGen,1,(Length(CurrGen)-9))"."next_gen
V
V
V
V  "Rename '"InDsn"' '"OutDsn"'"
V
V  If rc <> 0 Then Do
V
V    Say "  Return Code " rc " from Rename"
V
V    Exit rc
V
V  End
V
V  Else Do
V
V    Say "  Rename successfull "
V
V    Say "    Original file name       "InDsn
V
V    Say "    Renamed file name        "OutDsn
V
V  End
V
V
V
VExit:
V
V  Say
V
V  Say "Ending   LRUNTASK version "ver" on "Date(W) Date()" at "Time()
V
V  Say
V
V  Exit 0
V
VMEMBER NAME  TEMP
V/* rexx */
V
Vx = MVSVAR(SYSSMFID)
V
VSAY X
V
VMEMBER NAME  TRANCHCK
V/* Language           : Rexx
V
V * Program Name       : TRANCHCK
V
V * Description        : Record the outgoing GV00 number and check if it has
V
V *                    : already been sent out. If it has, issue RC=20 to run
V
V *                    : WTOR to inform Service Desk.
V
V *                    : Purge history records older than 40 days.
V
V ******************************************************************************
V/
V
V
V  Say
V
V  Say "Starting TRANCHCK v1.0 on "Date()" at " Time()
V
V  Say
V
V
V
VCollect_Allocated_Files:
V
V  st_trap = outtrap(var.)
V
V  "LISTA ST"
V
V  st_trap = outtrap(off)
V
V
V
VInitialise:
V
V  pCnt = 0
V
V  pDate = Date('B')-180
V
V  pfullDate = Date('N',pDate,'B')
V
V  cDate = Date()
V
V  cTime = Time()
V
V  cDT   = Right(cDate,11," ") cTime
V
V
V
VInitialise_File_Names:
V
V  Do i = 1 to var.0
V
V    Parse var var.i v1 v2 v3 v4
V
V    prev = i - 1
V
V    If Pos("TRANDSN",v1) > 0 Then Do
V
V      line = Strip(var.prev)
V
V      line = Translate(line,' ','(')
V
V      dsn = Word(line,1)
V
V    End
V
V    If Pos("HISTORY",v1) > 0 Then Do
V
V      line = Strip(var.prev)
V
V      line = Translate(line,' ','(')
V
V      pds = Word(line,1)
V
V    End
V
V    If Pos(".JOB",v1) > 0 Then Do
V
V      line = Translate(v1,' ','.')
V
V      jobname = Word(line,2)
V
V      Leave i
V
V    End
V
V  End
V
V
V
VReadCheckWrite:
V
V  pdsmemb = pds"("jobname")"
V
V  "free fi(HISTORY)"
V
V  "alloc fi(HISTORY) da('"pdsmemb"') shr "
V
V  testIT = SysDsn("'"pdsmemb"'")
V
V  If testIT = "OK" then Do
V
V    "execio * diskR HISTORY (stem hist. finis)"
V
V    Say " "hist.0" record/s read from HISTORY member into stack"
V
V    Call Check
V
V    oLine.1 = Left(dsn,58," ")
V
V    oLine.1 = Overlay(cDT,oline.1,60)
V
V    Say " 1 New Record added => "oLine.1
V
V    oCnt = 1
V
V    Do w = 1 to hist.0
V
V      bypass = n
V
V      checkDate = Strip(SubStr(hist.w,60,11))
V
V      Call Purge_History
V
V      If bypass = y Then Iterate w
V
V      oCnt = oCnt + 1
V
V      oLine.oCnt = hist.w
V
V    End
V
V    "execio "oCnt" diskW HISTORY (stem oLine. finis)"
V
V    Say " "oCnt" record/s written to HISTORY member from updated stack"
V
V  End
V
V  Else Do
V
V    oLine.1 = Left(dsn,58," ")
V
V    oLine.1 = Overlay(cDT,oline.1,60)
V
V    "execio 1 diskW HISTORY (stem oLine. finis)"
V
V    Say " First Time Record added => "oLine.1
V
V  End
V
V
V
VDisplay_Purged_Records:
V
V  If pCnt > 0 Then Do
V
V    Say " "pCnt" record/s deleted from HISTORY member that are older than",
V
V        "purge date '"pfullDate"' are listed below"
V
V    Say
V
V    Do p = 1 to pCnt
V
V      Say " "purhist.p
V
V    End
V
V  End
V
V
V
VExit:
V
V  Say
V
V  Say "Ending   TRANCHCK RC=0 on "Date()" at "Time()
V
V  Say
V
V  Exit 0
V
V
V
VCheck:
V
V  Do c = 1 to hist.0
V
V    If Word(hist.c,1) = dsn Then Do
V
V      Say " "dsn" has already been recorded as sent out on "SubStr(hist.c,60,20
V)
V      Say " Please investigate as a matter of urgency"
V
V      Say
V
V      Say "Ending   TRANCHCK RC=20 on "Date()" at " Time()
V
V      Say
V
V      Exit 20
V
V    End
V
V  End
V
V
V
V  Return 0
V
V
V
VPurge_History:
V
V  inDate = Date('B',checkDate)
V
V  If inDate < pDate Then Do
V
V    pCnt = pCnt + 1
V
V    purhist.pcnt = hist.w
V
V    bypass = y
V
V  End
V
V
V
V  Return 0
V
V
V
VMEMBER NAME  TRANEDIT
V/*================================  Rexx  ====================================*
V/
V/*    Name          - TRANEDIT                                                *
V/
V/*    Author        - Stuart Dolman                                           *
V/
V/*    Written       - December 2005                                           *
V/
V/*    Environment   - TSO/Batch (IKJEFT01)                                    *
V/
V/*    Version       - 1.4                                                     *
V/
V/*    Function      - Update date,time or sequence number in file             *
V/
V/*    Modified      - February 2006                                           *
V/
V/*    Modified by   - Stuart Dolman                                           *
V/
V/*    Modification  - Add Date sequence number reset on new day               *
V/
V/*    Modified      - March 2006                                              *
V/
V/*    Modified by   - Stuart Dolman                                           *
V/
V/*    Modification  - Add Date copy date                                      *
V/
V/*    Modified      - August 2006                                             *
V/
V/*    Modified by   - Stuart Dolman                                           *
V/
V/*    Modification  - Add Sequence number from Ctlcard                        *
V/
V/*    Modified      - October 2006                                            *
V/
V/*    Modified by   - Stuart Dolman                                           *
V/
V/*    Modification  - Add insert date                                         *
V/
V/*===============================  Variables =================================*
V/
V/*    KEYWORD       - Word to be searched for in JCL. stem   ( from EXEC )    *
V/
V/*    OFFSET        - Offset where overlay is to take place  ( from EXEC )    *
V/
V/*    DATEFRMT      - format of the date that is to be used  ( from EXEC )    *
V/
V/*    COUNT         - Counter for export routine                              *
V/
V/*    hh            - hours                                                   *
V/
V/*    mi            - minutes                                                 *
V/
V/*    ss            - seconds                                                 *
V/
V/*    yyyy          - 4 digit year                                            *
V/
V/*    dd            - day of the month (numeric)                              *
V/
V/*    mmm           - First three characters of Month (Alpha)                 *
V/
V/*    mm            - month (numeric)                                         *
V/
V/*    yy            - year (numeric)                                          *
V/
V/*    yp            - century (numeric)                                       *
V/
V/*    jjjjj         - 5 digit julian date                                     *
V/
V/*    jjj           - 3 digit julian date                                     *
V/
V/*    day           - day of the week (Alpha)                                 *
V/
V/*    dy3           - First three charachters of DOW (Upper Alpha)            *
V/
V/*    #             - day of week (numeric start with Monday)                 *
V/
V/*============================================================================*
V/
V/*trace i*/
V
VSay 'TRANEDIT - Version 1.4  25/10/2006'
V
V
V
VParse SOURCE . . exec_name .
V
VParse ARG ARGS
V
VIf Words(ARGS) ¬= 3 Then
V
V  Do
V
V    Say exec_name' - ERROR - not enough parms passed to exec '
V
V    Exit 5
V
V  End
V
V
V
VParse VAR ARGS KEYWORD OFFSET DATEFRMT
V
V
V
V/*============================ Variable Setup ================================*
V/
V/*                        Set up variables for editing                        *
V/
V/*============================================================================*
V/
VCOUNT = 0
V
V   hh = Substr(Time(),1,2)
V
V   mi = Substr(Time(),4,2)
V
V   ss = Substr(Time(),7,2)
V
V yyyy = Substr(Date(S),1,4)
V
V   dd = Substr(Date(E),1,2)
V
V  mmm = Substr(Date(M),1,3)
V
V   mm = Substr(Date(E),4,2)
V
V   yy = Substr(Date(E),7,2)
V
V   yp = Substr(yyyy,1,2)
V
Vjjjjj = Date(J)
V
V  jjj = Substr(jjjjj,3)
V
V  day = Date(W)
V
V  bdt = date(b)
V
V  M1 = substr(DATE('S',bdt - 15,'B'),1,6)
V
V  M2 = substr(DATE('S',bdt - 45,'B'),1,6)
V
V  dy3 = Translate(Substr(Date(W),1,3))
V
VSelect
V
V  When Substr(day,1,3) = 'Mon' Then # = '1'
V
V  When Substr(day,1,3) = 'Tue' Then # = '2'
V
V  When Substr(day,1,3) = 'Wed' Then # = '3'
V
V  When Substr(day,1,3) = 'Thu' Then # = '4'
V
V  When Substr(day,1,3) = 'Fri' Then # = '5'
V
VOtherwise Nop
V
VEnd
V
V
V
V/*============================ Read in File ==================================*
V/
V/*             Read file to be edited into stem variable JCL.                 *
V/
V/*============================================================================*
V/
VDSNINFO = Listdsi(EDITFILE FILE)
V
V
V
V"Execio * Diskr EDITFILE (Stem JCL. Finis"
V
V If RC ¬= 0 Then
V
V   Do
V
V     Say exec_name' - ERROR - Unable to allocate 'SYSDSNAME
V
V     Say exec_name' - ERROR - or member not Found'
V
V     Exit 10 + RC
V
V   End
V
V/*===================== Read Date from CTLDATES V+ ===========================*
V/
V/* If DATEFRMT is prefixed with Upper Case VCTL this section will read the    *
V/
V/* date in from DD CTLDATES. After the VCTL prefix the next three digits are  *
V/
V/* the Org Number that will be looked for in the CTLDATES file.               *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,4) = 'VCTL' Then
V
V  Do
V
V    Org_Num     = Substr(DATEFRMT,5,3)
V
V    Date_Format = Substr(DATEFRMT,8)
V
V    Call Get_VCtldate
V
V    Call Conv_Date_Var Date_Format
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*========================== Sequence Number Update ==========================*
V/
V/* If the edit is to update a sequnce number this will read in the DATEFRMT   *
V/
V/* variable feed from the exec parm. The number suffixed on the end of SEQNUM *
V/
V/* will detemine how long the sequence number will be padded out to           *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,6) = 'SEQNUM' Then
V
V  Do
V
V    SEQPAD = Substr(DATEFRMT,7)
V
V    If Datatype(SEQPAD) ¬= 'NUM' Then
V
V      Do
V
V        Say exec_name' - ERROR - Invalid Parameter passed for Seqential'
V
V        Say exec_name' - ERROR - Number update'
V
V        Exit 15
V
V      End
V
V     Call Seq_Update
V
V     Call EXP_File
V
V     Call Seq_Exit
V
V   End
V
V
V
V/*======================= Read Date from DATEFILE ============================*
V/
V/* If DATEFRMT is prefixed with UpperCase PASTE the date will be supplied     *
V/
V/* directly after PASTE.                                                      *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,5) = 'PASTE' Then
V
V  Do
V
V    Date_var = Substr(DATEFRMT,6)
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*======================= Read Date from DATEFILE ============================*
V/
V/* If DATEFRMT is prefixed with Upper Case COPY the date format supplied will *
V/
V/* be as follows after COPY the next two characters are the input offset the  *
V/
V/* next set of charaters upto the ¢ symbol will be the input keyword. The     *
V/
V/* date fornat supplied after that will be read to ascertain the length of    *
V/
V/* the date to be read in.                                                    *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,4) = 'COPY' Then
V
V  Do
V
V    Read_Offset = Substr(DATEFRMT,5,2)
V
V    Read_Keyword = Substr(DATEFRMT,7,Index(DATEFRMT,'¢',)-7)
V
V    Date_Format = Substr(DATEFRMT,Index(DATEFRMT,'¢',)+1)
V
V    Call Get_date
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*======================= Read Date from CTLDATES ============================*
V/
V/* If DATEFRMT is prefixed with Upper Case CTL this section will read the     *
V/
V/* date in from DD CTLDATES. Then the date will be passed to Conv_Date_Var    *
V/
V/* to format the date for editing.                                            *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,3) = 'CTL' Then
V
V  Do
V
V    Date_Format = Substr(DATEFRMT,4)
V
V    Call Get_Ctldate
V
V    Call Conv_Date_Var Date_Format
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*===================Date and Sequence Number Update==========================*
V/
V/* If DATEFRMT is prefixed with Uppercase DSEQ this section will read the     *
V/
V/* fifth of DATEFRMT as the sequence number padding and the rest as the date  *
V/
V/* format. The date will be read in from the output file and if the date is   *
V/
V/* the same as todays date then 1 will be added to the sequence number, if    *
V/
V/* the dates differ the sequence number will be reset to 1.                   *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,4) = 'DSEQ' Then
V
V  Do
V
V    Date_Format = Substr(DATEFRMT,6)
V
V    Date_Length = Length(Date_Format)
V
V    SeqPad      = Substr(DATEFRMT,5,1)
V
V    Call Conv_Date_Var Date_Format
V
V    Call Get_File_Date_and_Seq
V
V    seqnum = File_Seq
V
V    If date_var = file_date then seqnum = seqnum + 1
V
V    else
V
V    seqnum = '1'
V
V    seqnum = right(Seqnum,SeqPad,'0')
V
V    Date_var = Date_var||seqnum
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*===================Date and Sequence Number Update==========================*
V/
V/* If DATEFRMT is prefixed with Uppercase SEQD this section will read the     *
V/
V/* sixth of DATEFRMT as the sequence number padding and the rest as the date  *
V/
V/* format. The date will be read in from the output file and if the date is   *
V/
V/* the same as todays date then 1 will be added to the sequence number, if    *
V/
V/* the dates differ the sequence number will be reset to 1.                   *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,4) = 'SEQD' Then
V
V  Do
V
V    Date_Format = Substr(DATEFRMT,6)
V
V    Date_Length = Length(Date_Format)
V
V    SeqPad      = Substr(DATEFRMT,5,1)
V
V    Call Conv_Date_Var Date_Format
V
V    Call Get_Seq_and_File_Date
V
V    seqnum = File_Seq
V
V    If date_var = file_date then seqnum = seqnum + 1
V
V    else
V
V    seqnum = '1'
V
V    seqnum = right(Seqnum,SeqPad,'0')
V
V    Date_var = seqnum||Date_var
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*===================Date and Sequence Number Update==========================*
V/
V/* If DATEFRMT is prefixed with Uppercase DSQQ this section will read the     *
V/
V/* fifth of DATEFRMT as the sequence number padding and the rest as the date  *
V/
V/* format.                                                                    *
V/
V/*                                                                            *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,4) = 'DSQQ' Then
V
V  Do
V
V    Date_Format = Substr(DATEFRMT,6)
V
V    Date_Length = Length(Date_Format)
V
V    SeqPad      = Substr(DATEFRMT,5,1)
V
V    Call Conv_Date_Var Date_Format
V
V    Call Get_SeqNum
V
V    seqnum = File_Seq
V
V    seqnum = seqnum + 1
V
V    seqnum = right(Seqnum,SeqPad,'0')
V
V    Date_var = Date_var||seqnum
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*==================Date and Sequence CTL Number Update=======================*
V/
V/* If DATEFRMT is prefixed with Uppercase DSCQ this section will read the     *
V/
V/* fifth of DATEFRMT as the sequence number padding and the rest as the date  *
V/
V/* format. The Sequence number is read in from DD SEQNFILE.                   *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,4) = 'DSCQ' Then
V
V  Do
V
V    Date_Format = Substr(DATEFRMT,6)
V
V    Date_Length = Length(Date_Format)
V
V    SeqPad      = Substr(DATEFRMT,5,1)
V
V    Call Conv_Date_Var Date_Format
V
V    Call Get_Ctl_SeqNum
V
V    seqnum = seqnum + 1
V
V    seqnum = right(Seqnum,SeqPad,'0')
V
V    Date_var = Date_var||seqnum
V
V    Call Date_Update
V
V    Call EXP_File
V
V    seqnum.1 = seqnum
V
V    Call Update_Seq_Ctl
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*==================Date and Sequence CTL Number Update=======================*
V/
V/* If DATEFRMT is prefixed with Uppercase DSCR this section will read the     *
V/
V/* fifth of DATEFRMT as the sequence number padding and the rest as the date  *
V/
V/* format. The Sequence number is read in from DD SEQNFILE. Reset sequence    *
V/
V/* number if ctl date does not equal today.                                   *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,4) = 'DSCR' Then
V
V  Do
V
V    Date_Format = Substr(DATEFRMT,6)
V
V    Date_Length = Length(Date_Format)
V
V    SeqPad      = Substr(DATEFRMT,5,1)
V
V    Call Conv_Date_Var Date_Format
V
V    Call Get_Ctl_Date_and_Seq
V
V    If date_var = file_date then seqnum = seqnum + 1
V
V    else
V
V    seqnum = '1'
V
V    seqnum = right(Seqnum,SeqPad,'0')
V
V    seqnum.1 = seqnum||' '||Date_var
V
V    Date_var = Date_var||seqnum
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Call Update_Seq_Ctl
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*===================== Sequence CTL Number Update ===========================*
V/
V/* If DATEFRMT is prefixed with Uppercase SEQC this section will read the     *
V/
V/* fifth of DATEFRMT as the sequence number padding and the rest as the date  *
V/
V/* format. The Sequence number is read in from DD SEQNFILE. Reset sequence    *
V/
V/* number if ctl date does not equal today.                                   *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,4) = 'SEQC' Then
V
V  Do
V
V    Date_Format = Substr(DATEFRMT,6)
V
V    Date_Length = Length(Date_Format)
V
V    SeqPad      = Substr(DATEFRMT,5,1)
V
V    Call Conv_Date_Var Date_Format
V
V    Call Get_Ctl_Date_and_Seq
V
V    If date_var = file_date then seqnum = seqnum + 1
V
V    else
V
V    seqnum = '1'
V
V    seqnum = right(Seqnum,SeqPad,'0')
V
V    seqnum.1 = seqnum||' '||Date_var
V
V    Date_var = seqnum
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Call Update_Seq_Ctl
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*==============Date Time and Sequence Number Update for MCI==================*
V/
V/* If DATEFRMT is prefixed with Uppercase MCIU this section will read the     *
V/
V/* fifth of DATEFRMT as the sequence number padding and the rest as the date  *
V/
V/* format. The date will be read in from the output file and if the date is   *
V/
V/* the same as todays date then 1 will be added to the sequence number, if    *
V/
V/* the dates differ the sequence number will be reset to 1. This is for MCI   *
V/
V/* files only.                                                                *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,4) = 'MCIU' Then
V
V  Do
V
V    Date_Format = Substr(DATEFRMT,6)
V
V    Date_Length = Length(Date_Format)
V
V    SeqPad      = Substr(DATEFRMT,5,1)
V
V    Call Conv_Date_Var Date_Format
V
V    Call Get_File_Date_and_Seq
V
V    seqnum = File_Seq
V
V    date_part = Substr(date_var,1,Pos('.',date_var))
V
V    date_file = Substr(file_date,1,Pos('.',file_date))
V
V    If date_part = date_file then seqnum = seqnum + 1
V
V    else
V
V    seqnum = '1'
V
V    seqnum = right(Seqnum,SeqPad,'0')
V
V    Date_var = Date_var||seqnum
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,4) = 'PAGO' Then
V
V  Do
V
V    Date_Format = Substr(DATEFRMT,6)
V
V    Date_Length = Length(Date_Format)
V
V    SeqPad      = Substr(DATEFRMT,5,1)
V
V    Call Conv_Date_Var Date_Format
V
V    Call Get_File_Date_and_Seq
V
V    seqnum = File_Seq
V
V    date_part = Substr(date_var,1,Pos('_',date_var))
V
V    date_file = Substr(file_date,1,Pos('_',file_date))
V
V    If date_part = date_file then seqnum = seqnum + 1
V
V    else
V
V    seqnum = '1'
V
V    seqnum = right(Seqnum,SeqPad,'0')
V
V    Date_var = Date_var||seqnum
V
V    Call Date_Update
V
V    Call EXP_File
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*============================= Instert Date =================================*
V/
V/* If DATEFRMT is prefixed with INS this section will take the 4th character  *
V/
V/* from DATEFRMT as the ending string of the date. Any thing after the 4th    *
V/
V/* character is the new date format. The date will be overriden in the        *
V/
V/* ctlcard with all characters after it replaced.                             *
V/
V/*============================================================================*
V/
VIf Substr(DATEFRMT,1,3) = 'INS' Then
V
V  Do
V
V    Date_Format = Substr(DATEFRMT,5)
V
V    Ending_Char  = Substr(DATEFRMT,4,1)
V
V    Call Conv_Date_Var Date_Format
V
V    Call Date_Update_Ins
V
V    Call EXP_File
V
V    Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V    Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var
V
V    Exit
V
V  End
V
V
V
V/*================================ Catch All =================================*
V/
V/* This section will perfrom the edit if not a sequence number or reading the *
V/
V/* date from CTLDATES. This will use the dates from the variables set at the  *
V/
V/* start of the Rexx.                                                         *
V/
V/*============================================================================*
V/
VCall Conv_Date_Var DATEFRMT
V
VCall Date_Update
V
VCall EXP_File
V
V
V
VSay exec_name' - Rexx Routine Completed Cond Code 0'
V
VSay exec_name '- Date Format used 'DATEFRMT' converted to 'Date_Var
V
V
V
VExit
V
V
V
VDate_Update:
V
V/*============================= Date_Update ==================================*
V/
V/* This routine will read in stem JCL. and overlay variable date_var on the   *
V/
V/* line that contains the KEYWORD variable. The overlay takes place at the    *
V/
V/* starting pint of the KEYWORD + the OFFSET supplied by the exec parm.       *
V/
V/*============================================================================*
V/
VDo A=1 to JCL.0 by 1
V
V    O = Index(JCL.A,Keyword)
V
V    If O > 0 Then
V
V    Do
V
V      X = O + Offset
V
V      JCL.A = Overlay(date_var,JCL.A,X)
V
V      B = 0
V
V    End
V
VEnd
V
VReturn
V
V
V
VDate_Update_Ins:
V
V/*============================= Date_Update ==================================*
V/
V/* This routine will read in stem JCL. and overlay variable date_var on the   *
V/
V/* line that contains the KEYWORD variable. The overlay takes place at the    *
V/
V/* starting pint of the KEYWORD + the OFFSET supplied by the exec parm.       *
V/
V/*============================================================================*
V/
VDo A=1 to JCL.0 by 1
V
V    O = Index(JCL.A,Keyword)
V
V    If O > 0 Then
V
V    Do
V
V      X = O + Offset
V
V      Y = Index(JCL.A,Ending_Char,X)
V
V      End_of_Line = Substr(JCL.A,Y)
V
V      date_var = date_var||End_of_Line
V
V      JCL.A = Overlay(date_var,JCL.A,X)
V
V      JCL.A = Substr(JCL.A,1,80)
V
V      B = 0
V
V    End
V
VEnd
V
VReturn
V
V
V
VGet_date:
V
V/*============================== Get_Ctldate =================================*
V/
V/* This routine will read the date in from DD CTLDATES and will Call GREG2JUL *
V/
V/* to convert this date into Julian fomat if required.                        *
V/
V/*============================================================================*
V/
V"Execio * Diskr DATEFILE (Stem INDATE. Finis"
V
V  If RC ¬= 0 Then
V
V  Do
V
V    SAY exec_name' - ERROR -  Unable to Allocate DD DATEFILE File'
V
V    Delstack
V
V    Exit RC + 10
V
V  End
V
V
V
VDo D = 1 to INDATE.0
V
V  O = Index(INDATE.D,Read_Keyword)
V
V  If O > 0 Then date_Var = Substr(INDATE.D,O+Read_Offset,Length(Date_Format))
V
VEnd
V
V
V
VReturn
V
V
V
VGet_Ctldate:
V
V/*============================== Get_Ctldate =================================*
V/
V/* This routine will read the date in from DD CTLDATES and will Call GREG2JUL *
V/
V/* to convert this date into Julian fomat if required.                        *
V/
V/*============================================================================*
V/
V"Execio 1 Diskr DATEFILE (Stem CTLDATES. Finis"
V
V  If RC ¬= 0 Then
V
V  Do
V
V    SAY exec_name' - ERROR -  Unable to Allocate CTLDATES File'
V
V    Delstack
V
V    Exit RC + 10
V
V  End
V
V
V
V
V
VCTLDATE = Substr(CTLDATES.1,17,8)
V
V
V
VParse VAR CTLDATE mm '/' dd '/' yy
V
V
V
VCall GREG2JUL dd mm yy
V
V
V
VJJJJJ = RESULT
V
VJJJ = Substr(RESULT,3)
V
V
V
VReturn
V
V
V
VSEQ_Update:
V
V/*=============================== SEQ_Update =================================*
V/
V/* This routine will read in stem JCL. and read in the old sequence number    *
V/
V/* the line containing the KEYWORD. It will then add one to the sequence      *
V/
V/* number read in then overlay the original sequnce number.                   *
V/
V/*============================================================================*
V/
V  B = 1
V
V
V
V   Do A=1 to JCL.0 by 1
V
V       O = Index(JCL.A,KEYWORD)
V
V       If O > 0 Then
V
V       Do
V
V         X = O + OFFSET
V
V         FILENUM = Substr(JCL.A,X,SEQPAD)
V
V         FILENUM = FILENUM + 1
V
V         FILENUM = Right(FILENUM,SEQPAD,0)
V
V         JCL.A = Overlay(FILENUM,JCL.A,X)
V
V         B = 0
V
V       End
V
V   End
V
V
V
V If B = 1 Then
V
V   Do
V
V     Say exec_name' - ERROR -  No Matching Characters Found'
V
V     Say exec_name' - ERROR -  Sequential Numbering not updated'
V
V     Exit 30 + RC
V
V   End
V
V
V
VReturn
V
V
V
VConv_Date_Var:
V
V/*=========================== Conv_Date_Var ==================================*
V/
V/* This routine will take in the DATEFRMT variable and will replace the date  *
V/
V/* and time fields in variable date_var ready for editing.                    *
V/
V/*============================================================================*
V/
VArg date_var
V
VIf Index(date_var,'YYYY') > 0 Then
V
Vdate_var = Overlay(YYYY,date_var,Index(date_var,'YYYY'))
V
VIf Index(date_var,'HH') > 0 Then
V
Vdate_var = Overlay(HH,date_var,Index(date_var,'HH'))
V
VIf Index(date_var,'MI') > 0 Then
V
Vdate_var = Overlay(MI,date_var,Index(date_var,'MI'))
V
VIf Index(date_var,'SS') > 0 Then
V
Vdate_var = Overlay(SS,date_var,Index(date_var,'SS'))
V
VIf Index(date_var,'DD') > 0 Then
V
Vdate_var = Overlay(DD,date_var,Index(date_var,'DD'))
V
VIf Index(date_var,'MMM') > 0 Then
V
Vdate_var = Overlay(MMM,date_var,Index(date_var,'MMM'))
V
VIf Index(date_var,'MM') > 0 Then
V
Vdate_var = Overlay(MM,date_var,Index(date_var,'MM'))
V
VIf Index(date_var,'YY') > 0 Then
V
Vdate_var = Overlay(YY,date_var,Index(date_var,'YY'))
V
VIf Index(date_var,'YP') > 0 Then
V
Vdate_var = Overlay(YP,date_var,Index(date_var,'YP'))
V
VIf Index(date_var,'JJJJJ') > 0 Then
V
Vdate_var = Overlay(JJJJJ,date_var,Index(date_var,'JJJJJ'))
V
VIf Index(date_var,'JJJ') > 0 Then
V
Vdate_var = Overlay(JJJ,date_var,Index(date_var,'JJJ'))
V
VIf Index(date_var,'DAY') > 0 Then
V
Vdate_var = Overlay(DAY,date_var,Index(date_var,'DAY'))
V
VIf Index(date_var,'DY3') > 0 Then
V
Vdate_var = Overlay(DY3,date_var,Index(date_var,'DY3'))
V
VIf Index(date_var,'M1') > 0 Then
V
Vdate_var = Overlay(M1,date_var,Index(date_var,'M1'))
V
VIf Index(date_var,'M2') > 0 Then
V
Vdate_var = Overlay(M2,date_var,Index(date_var,'M2'))
V
VIf Index(date_var,'N') > 0 Then
V
Vdate_var = Overlay(N,date_var,Index(date_var,'N'))
V
VReturn date_var
V
V
V
VEXP_FILE:
V
V/*================================ EXP_FILE ==================================*
V/
V/* This routine will write the stem JCL. back to the file that is to be       *
V/
V/* updated. If the return code of the Execio is not 0 the routine will wait   *
V/
V/* 2 second and try again, it will try this upto 5 times and fail.            *
V/
V/*============================================================================*
V/
V  "Execio "JCL.0" Diskw "EDITFILE" (Stem JCL. Finis"
V
V
V
V   Select
V
V     When RC ¬= 0 & COUNT < 5 Then
V
V       Do
V
V         RET = RC + 20
V
V         COUNT = COUNT + 1
V
V         "Call *(OPSWAIT) '2'"
V
V         Signal EXP_FILE
V
V       End
V
V
V
V     When RC ¬= 0 & COUNT >= 5 Then
V
V       Do
V
V         Say exec_name' - ERROR - Unable to allocate 'SYSDSNAME
V
V         Say exec_name' - ERROR - or member not Found'
V
V         Exit RET
V
V       End
V
V
V
V   Otherwise
V
V   Nop
V
V   End
V
V
V
V"Free F("EDITFILE")"
V
V"Delstack"
V
V
V
VReturn
V
V
V
VGet_SeqNum:
V
V
V
VDo A = 1 to JCL.0
V
V  O = Index(JCL.A,KEYWORD)
V
V  NOFF = OFFSET+Date_Length
V
V  If O > 0 Then
V
V    Do
V
V      File_Seq  = Substr(JCL.A,NOFF+O,SeqPad)
V
V    End
V
VEnd
V
V
V
VReturn File_Date File_Seq
V
V
V
VGet_File_Date_and_Seq:
V
V
V
VDo A = 1 to JCL.0
V
V  O = Index(JCL.A,KEYWORD)
V
V  If O > 0 Then
V
V    Do
V
V      File_Date = Substr(JCL.A,OFFSET+O,Date_Length)
V
V      File_Seq  = Substr(JCL.A,OFFSET+O+Date_Length,SeqPad)
V
V    End
V
VEnd
V
V
V
VReturn File_Date File_Seq
V
V
V
VGet_SEQ_and_File_Date:
V
V
V
VDo A = 1 to JCL.0
V
V  O = Index(JCL.A,KEYWORD)
V
V  If O > 0 Then
V
V    Do
V
V      File_Date = Substr(JCL.A,OFFSET+O+Seqpad,Date_Length)
V
V      File_Seq  = Substr(JCL.A,OFFSET+O,SeqPad)
V
V    End
V
VEnd
V
V
V
VReturn File_Date File_Seq
V
V
V
VSeq_Exit:
V
V     Say exec_name' - Rexx Routine Completed Cond Code 0'
V
V     Say exec_name' - File sequence number updated to 'FILENUM
V
V
V
V Exit
V
V
V
VGet_Ctl_SeqNum:
V
V
V
V"Execio 1 Diskr SEQNFILE ( Finis"
V
V  If RC ¬= 0 Then
V
V    Do
V
V      Say exec_name' -  Unable to Allocate SEQNFILE File'
V
V      Delstack
V
V      Exit RC + 10
V
V    End
V
V
V
V  Pull Seqnum
V
V
V
VReturn Seqnum
V
V
V
VGet_Ctl_Date_and_Seq:
V
V
V
V"Execio 1 Diskr SEQNFILE ( Finis"
V
V  If RC ¬= 0 Then
V
V    Do
V
V      Say exec_name' -  Unable to Allocate SEQNFILE File'
V
V      Delstack
V
V      Exit RC + 10
V
V    End
V
V
V
V  Pull Line
V
V
V
V  Seqnum = word(line,1)
V
V  File_Date = word(line,2)
V
V
V
VReturn File_Date Seqnum
V
V
V
VUpdate_Seq_Ctl:
V
V
V
V"Execio 1 Diskw SEQNFILE (Stem seqnum. Finis"
V
V  If RC ¬= 0 Then
V
V    Do
V
V      Say exec_name' -  Unable to Allocate SEQNFILE File'
V
V      Delstack
V
V      Exit RC + 15
V
V    End
V
V
V
VReturn
V
V
V
VGet_VCtldate:
V
V/*============================== Get_Ctldate =================================*
V/
V/* This routine will read the date in from DD CTLDATES and will Call GREG2JUL *
V/
V/* to convert this date into Julian fomat if required.                        *
V/
V/*============================================================================*
V/
V"Execio * Diskr DATEFILE (Stem CTLDATES. Finis"
V
V  If RC ¬= 0 Then
V
V  Do
V
V    SAY exec_name' - ERROR -  Unable to Allocate CTLDATES File'
V
V    Delstack
V
V    Exit RC + 10
V
V  End
V
V
V
VDo A = 1 to CTLDATES.0
V
V  If Substr(CTLDATES.A,3,4) = ' '||Org_Num Then
V
V    Do
V
V      CTLDATE = Substr(CTLDATES.A,45,8)
V
V      Leave
V
V    End
V
VEnd
V
V
V
VIf CTLDATE = 'CTLDATE' Then
V
V  Do
V
V    Say exec_name' - Error - ORG 'Org_Num' not found in File'
V
V    Exit RC + 20
V
V  End
V
V
V
VParse VAR CTLDATE dd '/' mm '/' yy
V
Vyyyy = '20'||yy
V
V
V
VCall GREG2JUL dd mm yy
V
V
V
VJJJJJ = RESULT
V
VJJJ = Substr(RESULT,3)
V
V
V
VReturn
V
