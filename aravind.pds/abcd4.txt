MEMBER NAME   ACF2TRAP
/* REXX exec to trap ACFs 2 command responses */                         0001000
/* E.g. tso acf2trap L(IST) LIKE(JB-) IF(PROJ='BSP')                     0002000
         tso acf2trap L(IST) LIKE(-) IF(PROJ='BSP') name=yes             0003000
         tso acf2trap L(IST) LIKE(-) name=yes edit=yes                   0004000
     Specify name=<something> if you only want the name records          0005000
*/                                                                       0006000
                                                                         0007000
parse arg parms                                                          0008000
cmd = parmParse(parms)                                                   0009000
if (args.edit = 'ARGS.EDIT') then args.edit = 'Y' /* Default */          0010000
                                                                         0011000
searchString = args.search /* Set the search argument */                 0012000
if searchString = 'ARGS.SEARCH' then searchString = ''                   0013000
resultCount = 0 /* No lines found yet */                                 0014000
                                                                         0015000
/* Push commands onto stack to be executed after we invoke acf2. */      0016000
queue cmd                                                                0017000
queue 'quit'                                                             0018000
                                                                         0019000
DontCare = Outtrap("CmdOut.")                                            0020000
    acf                                                                  0021000
DontCare = Outtrap("OFF") /* done now. */                                0022000
                                                                         0023000
if CmdOut.0 < 1 then say "No lines captured"                             0024000
                                                                         0025000
resultCount = resultcount +1 /* Increment count of lines found.*/        0026000
result.resultCount = 'Results of command' cmd                            0027000
                                                                         0028000
/* Add message about SEARCH= if not specified. */                        0029000
if (args.search = 'ARGS.SEARCH') then                                    0030000
    do                                                                   0031000
    resultCount = resultcount +1 /* Increment count of lines found.*/    0032000
    result.resultCount = 'Add SEARCH=<string> to filter results'         0033000
    end                                                                  0034000
                                                                         0035000
/* Add message about NAME= if not specified. */                          0036000
if (args.name = 'ARGS.NAME') then                                        0037000
    do                                                                   0038000
    resultCount = resultcount +1 /* Increment count of lines found.*/    0039000
    result.resultCount = 'Add NAME=YES for name records only'            0040000
    end                                                                  0041000
                                                                         0042000
/* Add message about EDIT= if not specified. */                          0043000
if (args.edit = 'ARGS.EDIT') then                                        0044000
    do                                                                   0045000
    resultCount = resultcount +1 /* Increment count of lines found.*/    0046000
    result.resultCount = 'Add EDIT=YES for editable results.'            0047000
    end                                                                  0048000
                                                                         0049000
/* Step through all trapped output line-by-line. If the line contains    0050000
    our seach string, add it to the result stem variable.                0051000
    If the name= parm was specified, then only list the 1 line of each   0052000
    user. We do this by seeing if the 1st word = the 6 chars at pos 31.  0053000
*/                                                                       0054000
                                                                         0055000
do i = 1 to cmdout.0                                                     0056000
                                                                         0057000
    /* Keep the 'invalid' or 'ambiguous command' message if issued */    0058000
    if (pos('ACF67001',cmdout.i) <> 0 ) then                             0059000
       do                                                                0060000
       resultCount = resultcount +1 /* Increment count of lines found.*/ 0061000
       result.resultCount = cmdout.i /* Add this line to result stem */  0062000
       end                                                               0063000
                                                                         0064000
    /* If we specified a value for the name=, (we only want the name     0065000
       records) and the 1st word doesn't match the chars at pos 31       0066000
       (this is a name record) then iterate. */                          0067000
    if (args.name <> 'ARGS.NAME') then                                   0068000
       do                                                                0069000
       fWord = word(cmdout.i,1) /* Might be a TSO ID */                  0070000
       sWord = word(cmdout.i,2) /* Might be acct. info */                0071000
                                                                         0072000
       if pos(substr(fWord,1,1),sWord) = 0 | ,                           0073000
            pos(substr(fWord,2,3),sWord) = 0 | ,                         0074000
              pos(substr(fWord,5,3),sWord) = 0 then iterate              0075000
       end                                                               0076000
   /*  word(cmdout.i,1) <>,                                              0077000
          substr(cmdout.i,31,length(word(cmdout.i,1))) then iterate */   0078000
                                                                         0079000
 /* f isblank(cmdout.i) then iterate /* Ignore blank lines */ */         0080000
    if cmdout.i = '' then iterate /* Ignore blank lines */               0081000
                                                                         0082000
    /* If line contains search string/search string is blank, save it */ 0083000
    if (pos(searchString,cmdout.i) <> 0 ) |,                             0084000
           (searchString = '') then                                      0085000
       do                                                                0086000
       resultCount = resultcount +1 /* Increment count of lines found.*/ 0087000
       result.resultCount = cmdout.i /* Add this line to result stem */  0088000
       end                                                               0089000
end                                                                      0090000
                                                                         0091000
result.0 = resultCount   /* Set count of lines found */                  0092000
                                                                         0093000
/* If we have result records, then edit or just print them */            0094000
if result.0 > 0 then                                                     0095000
    do                                                                   0096000
    if args.edit <> 'ARGS.EDIT' then /* EDIT was specified */            0097000
       do                                                                0098000
       /* Put all ines found into a temporary data set and edit it. */   0099000
       ddnm = 'DD'||random(1,99999)    /* choose random ddname  */       0100000
       junk = msg(off)                                                   0101000
       "ALLOC FILE("||ddnm||") UNIT(VIO) NEW TRACKS SPACE(5,5) DELETE",  0102000
       " REUSE LRECL(140) RECFM(F B) BLKSIZE(8960)"                      0103000
       "EXECIO" result.0  "DISKW" ddnm "(STEM result. FINIS"             0104000
       address ISPEXEC "LMINIT DATAID(TEMP) DDNAME("||ddnm||")"          0105000
       address ISPEXEC "VIEW   DATAID("||temp")"                         0106000
       address ISPEXEC "LMFREE DATAID("||temp")"                         0107000
       junk = msg(off)                                                   0108000
       "FREE FI("||ddnm||")"                                             0109000
       end                                                               0110000
    else                                                                 0111000
       do i = 1 to result.0                                              0112000
       say result.i                                                      0113000
       end                                                               0114000
    end                                                                  0115000
else say 'No lines to show'                                              0116000
                                                                         0117000
exit(0)                                                                  0118000
                                                                         0119000
/* Parse a string, stripping any potential vriable assignments and       0120000
    assigning them.                                                      0121000
    e.g. parmParse('parm1 colour=red parm2 name=fred action=jumps parm5')0122000
    will return 'parm1 parm2 parm5' and set args.colour to 'red',        0123000
    args.name to 'fred' and args.action to 'jump'. It will also set      0124000
    args.stems to 'colour name action'                                   0125000
*/                                                                       0126000
parmParse:                                                               0127000
   parse arg args                                                        0128000
   args.stems = ''                                                       0129000
   do i = 1 to words(args)                                               0130000
      word = word(args,i)                                                0131000
      x = pos('=',word)                                                  0132000
/* If this parm contains '=' then assign the variable to the value */    0133000
      if x > 0 then                                                      0134000
         if datatype(left(word,x-1),'S') then                            0135000
            do                                                           0136000
            interpret 'args.'word(args,i)                                0137000
            /* Add this var to the list of vars we've created */         0138000
            args.stems = args.stems||' '||left(word(args,i),x-1)         0139000
            /* strip this word from the argument string */               0140000
            args = delword(args,i,1)                                     0141000
            i = i-1 /* Back up as we've deleted the current word */      0142000
            if i > words(args) then leave /* Gone off the end? */        0143000
            end                                                          0144000
   end                                                                   0145000
   return args                                                           0146000
MEMBER NAME   BGDG
/* Language            : Rexx

 * Program Name        : BGDG

 * Description         : Build GDG bases, based on (+1) & (0) characters found

 *                     : in member being edited.

 * Input Parameters    : lim opt extra

 * Output Parameters   : on screen displayed

 * Panel Names         : none

 * Table Names         : none

 * Skeleton Names      : none

 * Macro Names         : none

 * Rexx Names          : none

 * Program Names       : none

 * Message Names       : Internal ZEDxMSG's

 * Execution Mode      : Macro

 * Procedure           : none

 * Batch Job Name      : none

 * Restrictions        : none

 * User                : all_users

 * Author              : Ken Balnave

 * Department          : JCL Management

 * Owner               : Ken Balnave - JCL Management

 * Created             : 6th December 2004

 * Status              : Test/Live

 * Modified as below   : Latest modification on top.

  *-----------------------------------------------------------------------------

 * Ken Balnave - 6th December 2004

 * 1: Initial coding.

  *-----------------------------------------------------------------------------

  ******************************************************************************
/


Initialise:

   Address isredit "MACRO (lim opt extra)"

   If lim = '' | opt = '' then Do

     Say 'the parms are lim (for limit) and opt (TEST or NOTEST or TESTNO)'

     Say 'eg : BGDG 3 NOTEST or BGDG 6 TEST'

     Exit 4

   End

   opt = Translate(opt)

   P1gdg_count = 0 ; Z0gdg_count = 0

   dsn_list = ' '

   zero_start = n

   dup_count = 0



Exclude_And_Find_Plus1_Gens:

   type = '(+1)'

   "isredit exclude all"

   "isredit CURSOR = 1 1"

   "isredit find '(+' all"

   "isredit x all '//*'"

   Do until rc > 0

     "isredit (line,col) = CURSOR"

     "isredit (lineval) = LINE "line



     dsn_pos     = Pos('DSN=',lineval) + 4

     If dsn_pos  = 4 then Do

       "isredit find '(+' nx"

       Iterate

     End

     plus_one    = Pos('(+',lineval,dsn_pos)

     If plus_one = -1 then Leave



     dsn = Substr(lineval,dsn_pos,(plus_one-dsn_pos))

     Call Check_Possible_Errors

     If Pos(dsn,dsn_list) > 0 then Do

       dup_count = dup_count + 1

       "isredit find next nx 'DSN='"

       If rc > 0 then Signal Exit

       "isredit find next nx '(+'"

       If rc > 0 then Signal Exit

       Iterate

     End

     dsn_list = dsn_list' 'dsn

     Call Check_Valid_File



     "isredit find '(+' nx"

   End



Exclude_And_Find_Zero_Gens:

   If extra = '0' then Do

     type = '(0)'

     zero_start = y

     "isredit FIND '//' FIRST"

     "isredit reset"

     "isredit exclude all"

     "isredit CURSOR = 1 1"

     "isredit find (0) all"

     "isredit x all '//*'"

     Do until rc > 0

       "isredit (line,col) = CURSOR"

       "isredit (lineval) = LINE "line



       dsn_pos     = Pos('DSN=',lineval) + 4

       If dsn_pos  = 4 then Do

         "isredit find (0) nx"

         Iterate

       End

       zero_pos    = Pos('(0)',lineval,dsn_pos)

       If zero_pos = -1 then Leave



       dsn = Substr(lineval,dsn_pos,(zero_pos-dsn_pos))

       Call Check_Possible_Errors

       If Pos(dsn,dsn_list) > 0 then Do

         dup_count = dup_count + 1

         "isredit find next nx 'DSN='"

         If rc > 0 then Signal Exit

         "isredit find next nx '(0)'"

         If rc > 0 then Signal Exit

         Iterate

       End

       dsn_list = dsn_list' 'dsn

       Call Check_Valid_File



       "isredit find (0) nx"

     End

   End



Exit:

   Say Copies('=',75)

   Say 'Summary of events'

   If opt = 'NOTEST' | opt = 'TESTNO' then,

      Say P1gdg_count "GDG bases",

      "("P1gdg_count-Z0gdg_count" Plus1 & "Z0gdg_count" Zero) created"

   If opt = 'TEST' then,

      Say P1gdg_count "GDG bases",

      "("P1gdg_count-Z0gdg_count" Plus1 & "Z0gdg_count" Zero)",

      "will be created when you re-do with NOTEST"

   If dup_count > 0 then Say dup_count' duplicates found and ignored'



   "isredit FIND '//' FIRST"

   "isredit reset"

   exit 1



Check_Valid_File:

   cdsn = "'"dsn"'"

   listc_trap = Outtrap(listc.)

   "listc ent("cdsn") gdg"

   lc_rc = rc

   listc_trap = Outtrap(off)



   If lc_rc /= 0 then Do

     P1gdg_count = P1gdg_count + 1

     If zero_start = y then Z0gdg_count = Z0gdg_count +1

     If opt = 'NOTEST' | opt = 'TESTNO' then Do

       say_msg ='Building GDG base for 'dsn

       say_msg = Overlay(type,say_msg,70)

       Say say_msg

       Address TSO "DEF GDG (NAME("cdsn") LIMIT("lim") SCRATCH)"

       If rc /= 0 then Do

         Say 'Error creating GDG base for 'dsn

         Exit 16

       End

     End

     If opt = 'TEST' then Do

       say_msg = 'Simulating GDG base build for 'dsn

       say_msg = Overlay(type,say_msg,70)

       Say say_msg

     End

   End



   Return



Check_Possible_Errors:

   If Pos(',',dsn) > 0 | Pos('&',dsn) > 0 then Do

     zedsmsg = 'Invalid chars  - line' Strip(line,L,'0')

     zedlmsg = dsn' contains invalid characters. Please correct and re-try'

     "ispexec setmsg msg (isrz001)"

     Exit 4

   End

   If Length(dsn) > 35 then Do

     zedsmsg = 'DSN tooooo long'

     zedlmsg = dsn' is 'Length(dsn) - 35' characters too long'

     "ispexec setmsg msg (isrz001)"

     Exit 4

   End



   Return



MEMBER NAME   CCI
/* REXX */                                                               0001000
0
ISPEXEC VGET (ZUSER)                                                     0002000
0
"ISREDIT MACRO"                                                          0003000
0
"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                   0004000
0
"'//SYSIN    DD *'"                                                      0005000
0
"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                   0006000
0
"'//OUTDD    DD SYSOUT=*'"                                               0007000
0
"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                   0008000
0
"'//ERRORS   DD SYSOUT=*'"                                               0009000
0
"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                   0010000
0
"'//SYSPRINT DD SYSOUT=*'"                                               0011000
0
"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                   0012000
0
"'//         PARM='CCIIND2,CA71,,,OUTDD''"                               0013000
2
"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                   0014000
0
"'//STEP01   EXEC PGM=CAL2X2WB,'"                                        0015000
0
"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                   0016000
0
"'//*'"                                                                  0017000
0
"ISREDIT LINE_BEFORE .ZF = DATALINE ",                                   0018000
0
"'//&ZUSER.B JOB (0000,OPER),ANYJOB,MSGCLASS=0,CLASS=I'"                 0019000
1
"ISREDIT LINE_AFTER .ZL = DATALINE ",                                    0020000
0
"'/*'"                                                                   0021000
0
MEMBER NAME   CICDAILY
/* Rexx - CICDAILY edit macro.                                   */      0001000
0
/* Filter a CICS log down to short of storage & stress messages */       0002000
0
/*--------------------------------------------------------------*/       0003000
0
                                                                         0004000
0
Address isredit                                                          0005000
0
"MACRO"                                                                  0006000
0
/* Hide everything */                                                    0007000
0
"x all"                                                                  0008000
0
"hide x"                                                                 0009000
0
                                                                         0010000
0
/* Find relevant messages */                                             0011000
0
"f 'under stress' all"                                                   0012000
0
"f 'short on storage' all"                                               0013000
0
/* "f ' ABEND ' all"    */                                               0014000
0
"f DFHSR0001 all"                                                        0015000
0
"f DFHAC2236 all"                                                        0016000
0
                                                                         0017000
0
"x 0C7 all"    /* Hide app abends */                                     0018000
0
"x all r'ABEND.+0C4.+FALC040'"                                           0019000
0
                                                                         0020000
0
/* Go to the end of the log */                                           0021000
0
"down m"                                                                 0022000
0
                                                                         0023000
0
/* Find the start of the current day */                                  0024000
0
"f ' ---- ' 18 last"                                                     0025000
0
exit 1                        /* Reset cursor to command line   */       0026000
0
MEMBER NAME   DELDUPE
/* Rexx - DELDUPE edit macro.                                   */       0001000
1
/* Remove duplicates from columns i-j (i,j are parameters)      */       0002000
1
/* if i and j are not specified, they default to 1 and width.   */       0003000
1
/* If only i is specified, j defaults to width.                 */       0004000
1
/*-------------------------------------------------------------*/        0005000
1
/* Lines containing duplicates will end up excluded. Uee the    */       0006000
1
/* 'flip' command to show them or 'delete all x' to remove them*/        0007000
1
/*-------------------------------------------------------------*/        0008000
1
Address isredit                                                          0009000
1
"MACRO (LCOL,RCOL)"           /* Indicate macro with 2 parms    */       0010000
1
"(DW) = DATA_WIDTH"           /* Get maximum data width         */       0011000
1
"(LAST) = LINENUM .ZLAST"     /* Get number of last line        */       0012000
1
"RESET X"                     /* Un-Exclude all lines           */       0013000
1
if datatype(lcol,'N')=0 then lcol=1   /* Set left column        */       0014000
1
if datatype(rcol,'N')=0 then rcol = dw /* Right col   */                 0015000
1
len=abs(rcol-lcol)+1          /* Get length of compare area     */       0016000
1
lcol=min(lcol,rcol)           /* Get left col                   */       0017000
1
do linenum = 1 to last        /* Loop through all lines         */       0018000
1
   "(LINE) = LINE "linenum    /* Place line data in 'line'      */       0019000
1
   test=substr(line,lcol,len) /* Take just columns to compare   */       0020000
1
   if test = testold then     /* Compare against previous line  */       0021000
1
     "XSTATUS "linenum" = X"          /* If match, exclude line */       0022000
1
   testold = test             /* Save current line compare area */       0023000
1
end                           /*                                */       0024000
1
exit 1                        /* Reset cursor to command line   */       0025000
1
MEMBER NAME   EGDG
/* Language            : Rexx

 * Program Name        : EGDG

 * Description         : Build GDG bases, based on list of file names

 *                     : in member being edited.

 * Input Parameters    : lim opt extra

 * Output Parameters   : on screen displayed

 * Panel Names         : none

 * Table Names         : none

 * Skeleton Names      : none

 * Macro Names         : none

 * Rexx Names          : none

 * Program Names       : none

 * Message Names       : Internal ZEDxMSG's

 * Execution Mode      : Macro

 * Procedure           : none

 * Batch Job Name      : none

 * Restrictions        : none

 * User                : all_users

 * Author              : Stuart Dolman

 * Department          : JCL Management

 * Owner               : Stuart Dolman - JCL Management

 * Created             : November 2015

 * Status              : Test/Live

 * Modified as below   : Latest modification on top.

  *-----------------------------------------------------------------------------

 * Stuart Dolman - November 2015 (bodged from Mr Balnave BGDG)

 * 1: Initial coding.

  *-----------------------------------------------------------------------------

  ******************************************************************************
/


Initialise:

   Address isredit "MACRO (lim opt extra)"

   If lim = '' | opt = '' then Do

     Say 'the parms are lim (for limit) and opt (TEST or NOTEST or TESTNO)'

     Say 'eg : EGDG 3 NOTEST or EGDG 6 TEST'

     Exit 4

   End

   opt = Translate(opt)

   P1gdg_count = 0 ; Z0gdg_count = 0

   dsn_list = ' '

   zero_start = n

   dup_count = 0

   type = '(+1)'



Exclude_And_Find_Plus1_Gens:

   "isredit CURSOR = 1 1"

   Do until rc > 0

     "isredit (line,col) = CURSOR"

     "isredit (lineval) = LINE "line

     dsn = strip(lineval)

     Call Check_Possible_Errors

     If Pos(dsn,dsn_list) > 0 then Do

       dup_count = dup_count + 1

       "isredit find next '@'p 1 1"

       If rc > 0 then Signal Exit

/*     "isredit find next nx '(+'"

       If rc > 0 then Signal Exit */

       Iterate

     End

     dsn_list = dsn_list' 'dsn

     Call Check_Valid_File



     "isredit find '@'p 1 1"

   End





Exit:

   Say Copies('=',75)

   Say 'Summary of events'

   If opt = 'NOTEST' | opt = 'TESTNO' then,

      Say P1gdg_count "GDG bases",

      "("P1gdg_count-Z0gdg_count" Plus1 & "Z0gdg_count" Zero) created"

   If opt = 'TEST' then,

      Say P1gdg_count "GDG bases",

      "("P1gdg_count-Z0gdg_count" Plus1 & "Z0gdg_count" Zero)",

      "will be created when you re-do with NOTEST"

   If dup_count > 0 then Say dup_count' duplicates found and ignored'



   "isredit FIND '//' FIRST"

   "isredit reset"

   exit 1



Check_Valid_File:

   cdsn = "'"dsn"'"

   listc_trap = Outtrap(listc.)

   "listc ent("cdsn") gdg"

   lc_rc = rc

   listc_trap = Outtrap(off)



   If lc_rc /= 0 then Do

     P1gdg_count = P1gdg_count + 1

     If zero_start = y then Z0gdg_count = Z0gdg_count +1

     If opt = 'NOTEST' | opt = 'TESTNO' then Do

       say_msg ='Building GDG base for 'dsn

       say_msg = Overlay(type,say_msg,70)

       Say say_msg

       Address TSO "DEF GDG (NAME("cdsn") LIMIT("lim") SCRATCH)"

       If rc /= 0 then Do

         Say 'Error creating GDG base for 'dsn

         Exit 16

       End

     End

     If opt = 'TEST' then Do

       say_msg = 'Simulating GDG base build for 'dsn

       say_msg = Overlay(type,say_msg,70)

       Say say_msg

     End

   End



   Return



Check_Possible_Errors:

   If Pos(',',dsn) > 0 | Pos('&',dsn) > 0 then Do

     zedsmsg = 'Invalid chars  - line' Strip(line,L,'0')

     zedlmsg = dsn' contains invalid characters. Please correct and re-try'

     "ispexec setmsg msg (isrz001)"

     Exit 4

   End

   If Length(dsn) > 35 then Do

     zedsmsg = 'DSN tooooo long'

     zedlmsg = dsn' is 'Length(dsn) - 35' characters too long'

     "ispexec setmsg msg (isrz001)"

     Exit 4

   End



   Return



MEMBER NAME   ISPFHTML
/* REXX */                                                               0001000
2
caption = "This is an ISPF screen capture"                               0002000
2
address ispexec                                                          0003000
2
"vput (caption) shared"                                                  0004000
2
"libdef ispllib dataset id('jocs065.ispfhtml.load')"                     0005000
2
"select pgm(ispfhtml) parm(download)"                                    0006000
2
"libdef ispllib"                                                         0007000
2
"vget (zwscon zuser)"                                                    0008000
2
if zwscon = '' then /* if no wkstn connection */                         0009000
2
   "browse dataset(ispfcap.htm)" /* Browse output */                     0010000
2
MEMBER NAME   JDATE
/* REXX */                                                               0001000
0
     zedlmsg = 'Today''s Julian date is' DATE('J')                       0002000
0
   address ispexec                                                       0003000
0
   "setmsg msg(isrz001)"                                                 0004000
0
MEMBER NAME   RAPIT
/* REXX */

ISPEXEC VGET (ZUSER)

"ISREDIT MACRO"

"ISREDIT LINE_BEFORE .ZF = DATALINE ",

"'//SYSUT1   DD DATA,DLM=ZZ'"

"ISREDIT LINE_BEFORE .ZF = DATALINE ",

"'//SYSIN    DD DUMMY'"

"ISREDIT LINE_BEFORE .ZF = DATALINE ",

"'//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=6400)'"

"ISREDIT LINE_BEFORE .ZF = DATALINE ",

"'//SYSUT2   DD DSN=&&&&&&&&ACF2,DISP=(,CATLG),SPACE=(TRK,2),UNIT=SYSDA,'"

"ISREDIT LINE_BEFORE .ZF = DATALINE ",

"'//SYSPRINT DD SYSOUT=Z'"

"ISREDIT LINE_BEFORE .ZF = DATALINE ",

"'//COPY1  EXEC PGM=IEBGENER'"

"ISREDIT LINE_BEFORE .ZF = DATALINE ",

"'//&ZUSER.Z JOB (7248,SPR1),MSGCLASS=Z,PRTY=7,CLASS=I'"

"ISREDIT LINE_AFTER .ZL = DATALINE ",

"'ZZ'"

"ISREDIT LINE_AFTER .ZL = DATALINE ",

"'//*'"

"ISREDIT LINE_AFTER .ZL = DATALINE ",

"'//SUBMIT   EXEC PGM=JOBCOPY'"

"ISREDIT LINE_AFTER .ZL = DATALINE ",

"'//STEPLIB  DD  DSN=ACF2.JOBCOPY,DISP=SHR'"

"ISREDIT LINE_AFTER .ZL = DATALINE ",

"'//SYSUT1   DD  DSN=&&&&&&&&ACF2,DISP=(OLD,DELETE)'"

"ISREDIT LINE_AFTER .ZL = DATALINE ",

"'//SYSUT2   DD  SYSOUT=(A,INTRDR),DCB=(BLKSIZE=80,LRECL=80,RECFM=F)'"

MEMBER NAME   SITEST
/* REXX */                                                               0000100
0
     msg.jobname = T$SYS10Z                                              0000110
4
     msg.userid = 'JOCS065'                                              0000120
4
                                                                         0000200
0
     ROOTSYS = 'Z580'        /* system where the RDF table lives */      0003000
0
                                                                         0004000
0
     /* Jobnames and users treated as generic i.e. with * on end. ''     0005001
5
        matches all */                                                   0005101
5
     MONITORED_USERS = 'FR'                                              0006001
7
     MONITORED_JOBS = 'T$S'                                              0007000
                                                                         0018000
0
/* End of INIT */                                                        0019000
0
                                                                         0020001
3
say 'Blank check = ' pos('','fred')                                      0021001
3
                                                                         0021500
7
 if MONITORED_USERS <> '' & pos(MONITORED_USERS, msg.userid) <> 1,       0023201
4
          then say 'No user match'                                       0023401
 if MONITORED_JOBS <> '' & pos(MONITORED_JOBS, msg.jobname) <> 1,        0023501
       then say 'No job match'                                           0025101
                                                                         0025300
9
say "check if jobname contains mask :" pos(MONITORED_USERS, msg.userid)  0025400
9
                                                                         0026000
0
MEMBER NAME   SRCHFILT
/* Rexx - SRCHFILT edit macro.                                  */       0001000
0
Address isredit                                                          0009000
0
"MACRO"                                                                  0010000
0
"X ALL"                        /* Exclude all lines           */         0013100
0
"F FOUND 50 ALL"                                                         0013200
0
"F DSN: ALL"                                                             0013300
0
"HIDE X"                                                                 0013400
0
exit 1                        /* Reset cursor to command line   */       0025000
0
MEMBER NAME   SUFFIX
/*************************   REXX  *************************************/

/**      EDIT MACRO.     05/02/2002.                                  **/

/**      SUFFIX EACH LINE IN A DATASET WITH A USER SUPPLIED STRING    **/

/**********************************************************************/

'ISREDIT MACRO (SUFFIX)'                   /* START THE MACRO          */

IF SUFFIX = "" THEN DO                     /* IF NO PARM HAS BEEN      */

    ZEDSMSG = ' NO SUFFIX ENTERED '        /* SUPPLIED THEN FINISH     */

    ADDRESS ISPEXEC                        /* WITH A SHORT MESSAGE     */

    'SETMSG MSG(ISRZ001)'

    EXIT

END





SUFFIX = STRIP(SUFFIX,B,'"')               /* IF THE SUFFIX STRING HAS */

                                           /* SPACES IT SHOULD BE      */

                                           /* WRAPPED IN DOUBLE QUOTES */

                                           /* STRIP THEM OFF           */



'ISREDIT (FIRST) = LINENUM .ZFIRST'        /* FIND THE LINE NUMBER OF  */

'ISREDIT (LAST)  = LINENUM .ZLAST'         /* THE FIRST AND LAST LINES */

'ISREDIT (RECLEN) = LRECL'                 /* AND THE RECORD LENGTH    */





DO I = FIRST TO LAST                       /* MAIN LOOP:               */

    'ISREDIT (LINEDATA ) = LINE ' I        /* THE SUFFIXED LINE IS     */

    STRIPPED= STRIP(LINEDATA,T)            /* CREATED BY READING THE   */

    NUM=LENGTH(STRIPPED)                   /* CURRENT LINE, REMOVING   */

    NEWLINE=OVERLAY(SUFFIX,STRIPPED,NUM+1) /* TRAILING BLANKS AND THEN */

    NEWLEN=LENGTH(NEWLINE)                 /* APPENDING THE SUFFIX     */

    IF NEWLEN > RECLEN                     /* IF THE NEWLINE IS LONGER */

    THEN ERRCODE=99                        /* THAN THE PHYSICAL        */

    ELSE                                   /* SET ERRCODE TO 99        */

    'ISREDIT LINE ' I '  =  (NEWLINE)'     /* IF LINE IS OK THEN WRITE */

    END                                    /* NEW LINE                 */





                                           /* CHECK TO SEE IF THE      */

    IF ERRCODE=99 THEN DO                  /* RETURN CODE HAS BEEN SET */

    ZEDSMSG = ' NOT ALL LINES SUFFIXED'    /* AND RETURN SOME MESSAGES */

    ZEDLMSG = ' SUFFIX TOO LONG FOR SOME RECORDS '

    ADDRESS ISPEXEC

    'SETMSG MSG(ISRZ001)'

    END



EXIT

MEMBER NAME   TSOE
/* REXX */

/*                            */

/* AUTHOR: MARK ZELDEN        */

/*                            */

/* TRACE ?I */

ARG TSOCMD

ADDRESS ISPEXEC "CONTROL ERRORS RETURN"

ADDRESS TSO

DDNM = 'DD'||RANDOM(1,99999)     /* CHOOSE RANDOM DDNAME  */

JUNK = MSG(OFF)

"ALLOC FILE("||DDNM||") UNIT(VIO) NEW TRACKS SPACE(5,5) DELETE",

" REUSE LRECL(140) RECFM(F B) BLKSIZE(8960)"

JUNK = MSG(ON)

/*                                     */

/*   ISSUE TSO COMMND AND TRAP OUTPUT  */

/*                                     */

JUNK=OUTTRAP(LINE.)

TSOCMD

JUNK=OUTTRAP('OFF')

/*                                     */

"EXECIO" LINE.0   "DISKW" DDNM "(STEM LINE. FINIS"

ADDRESS ISPEXEC "LMINIT DATAID(TEMP) DDNAME("||DDNM||")"

ADDRESS ISPEXEC "EDIT    DATAID("||TEMP")"

ADDRESS ISPEXEC "LMFREE DATAID("||TEMP")"

JUNK = MSG(OFF)

"FREE FI("||DDNM||")"

MEMBER NAME   VCURSOR
/* REXX exec to do cursor sensitive data extraction from an ISPF      */ 0038000
0
/*       Screen.                                                      */ 0039000
0
/*       Uses undocumented/Unsupported variables zscreeni & Zscreenc  */ 0040000
0
/*       available in ISPF for OS/390 R2.5 (ISPF4.5).                 */ 0041000
0
/*                                                                    */ 0042000
0
/*------------------------------------------------------------------ */  0043000
0
/* ---> NOTE: ZSCREENI and ZSCREENC may give odd results in some      */ 0044000
0
/* --->        situations such as command line at the bottom!!!!      */ 0045000
0
/* --->        If this is a problem, force a call to subroutine       */ 0046000
0
/* --->        GET_ZSCREEN_VALUES instead of using ISPF's variables.  */ 0047000
0
/*------------------------------------------------------------------ */  0048000
0
/*                                                                    */ 0049000
0
/*       Screen image may translate attr bytes to dsn chars causing   */ 0050000
0
/*       extra characters like '#' to be added to the dsname          */ 0051000
0
/*                                                                    */ 0052000
0
/*       Will not work in popups if invoked with the SUSPEND keyword. */ 0053000
0
/*       Note that the default command table entry for TSO does have  */ 0054000
0
/*       the SUSPEND keyword.                                         */ 0055000
0
/*                                                                    */ 0056000
0
/*       Usage:                                                       */ 0057000
0
/*         Name this VCURSOR, set a pfkey to VCURSOR and              */ 0058000
0
/*         create a command table entry:                              */ 0059000
0
/*             VCURSOR   0  SELECT CMD(%VCURSOR)                      */ 0060000
0
/*         (Or setting pfkey to TSO %VCURSOR will work in most cases) */ 0061000
0
/*         Then place cursor on dsname and press the pf key.          */ 0062000
0
/*         ZSCREENC may be wrong if initial command doesn't start     */ 0063000
0
/*         with a percent or have MODE(FSCR) on the SELECT statement. */ 0064000
0
/*                                                                    */ 0065000
0
/*       Author : Doug Nadel  April 24, 1999                          */ 0066000
0
/*       Updates: Apr 26, 1999 now views PDS members also.            */ 0067000
0
/*                Aug 18, Allow dsname in parentheses.                */ 0068000
0
/*                        Added additional information re MODE(FSCR). */ 0069000
0
/*                        Bypass ZSCREENI and ZSCREENC if needed.     */ 0070000
0
/*                        (ISPF version <4.5 but will work in 4.5+)   */ 0071000
0
/*                March 31, 2000 Added basic recognition of GDG names */ 0072000
0
/*                               and view/edit/browse customization   */ 0073000
0
/*                April 3, 2000  Added prompt panel.                  */ 0074000
0
/*------------------------------------------------------------------ */  0075000
0
/*        Customization to set service to view edit or browse         */ 0076000
0
/*        or to use prompt panel.                                     */ 0077000
0
/*------------------------------------------------------------------ */  0078000
0
service='PROMPT'                      /* set to VIEW, EDIT, or BROWSE */ 0079000
0
                                      /* or PROMPT.                   */ 0080000
0
/*------------------------------------------------------------------ */  0081000
0
Address ispexec                                                          0082000
0
'VGET (ZSCREENI,ZSCREENC,ZENVIR)'       /* Extract screen image,         0083000
0
                                           cursor pos and ISPF level  */ 0084000
0
If substr(zenvir,5,4) <4.5 Then                                          0085000
0
   Call get_zscreen_values                                               0086000
0
trtable='abcdefghijklmnopqrstuvwxyz'    /* Setup valid dsname chars   */ 0087000
0
trtable=trtable||translate(trtable)||'¢#@0123456789.''-{()'              0088000
0
trtable=translate(xrange('00'x,'FF'x),,trtable,' ')                      0089000
0
zscreeni=translate(zscreeni,,trtable,' ') /* Remove non-Dsn chars     */ 0090000
0
If substr(zscreeni,zscreenc+1,1) <> ' ' Then /* Maybe csr on dsn      */ 0091000
0
   Do                                   /* Extract dsn from screen image 0092000
0
                                           and view dataset           */ 0093000
0
     name=word(substr(zscreeni,1+lastpos(' ',zscreeni,zscreenc)),1)      0094000
0
     name=translate(strip(substr(name,1,56))) /* Max of 56 char name  */ 0095000
0
     If substr(name,1,1)='(' Then                                        0096000
0
       Parse Var name '('name')'.                                        0097000
0
     Parse Var name dsn '('mem')'       /* Is there a member name?    */ 0098000
0
     omem=mem                                                            0099000
0
     If mem<>'' Then                    /* If so, reformat for view      0100000
0
                                           cmd                        */ 0101000
0
       Do                                                                0102000
0
         gdg=0                                                           0103000
0
         name=dsn                       /* Get dsn                    */ 0104000
0
         If substr(name,1,1)='''' Then  /* if original name started with 0105000
0
                                           quotes                     */ 0106000
0
           name=name''''                /* Fix quotes                 */ 0107000
0
         If datatype(mem,'N') = 1 Then  /* Gdg?                       */ 0108000
0
           Do                                                            0109000
0
             Drop otrap.                                                 0110000
0
             Call outtrap 'otrap.'                                       0111000
0
             Address tso 'LISTCAT ENT('name')' /* Get real gdg names  */ 0112000
0
             Call outtrap 'OFF'                                          0113000
0
             If otrap.0>(2-2*mem) Then  /* If enough lines returned   */ 0114000
0
               Do                                                        0115000
0
                 a=otrap.0-1+2*mem      /* Parse listcat output       */ 0116000
0
                 n="'"subword(otrap.a,3,1)"'" /* Get real dsname      */ 0117000
0
                 If sysdsn(n)='OK' Then /* Verify that ds exists      */ 0118000
0
                   Do                   /* If real gdg name exists    */ 0119000
0
                     name=n             /* Use rea name as dsname     */ 0120000
0
                     mem=''             /* Forget the member name     */ 0121000
0
                     omem=''            /* Forget the member name     */ 0122000
0
                     gdg=1              /* Indicate we forgot member     0123000
0
                                           name                       */ 0124000
0
                   End                                                   0125000
0
               End                                                       0126000
0
           End                                                           0127000
0
         If gdg=0 Then                  /* If gdg check failed        */ 0128000
0
           mem='MEMBER('mem')'          /* Add member keyword for view*/ 0129000
0
       End                                                               0130000
0
     'CONTROL ERRORS RETURN'            /* Return errors to program   */ 0131000
0
     'LMINIT DATAID(VCURSOR) DATASET('name')' /* Alloc w/ Tso naming  */ 0132000
0
     If rc>0 & substr(name,1,1) <> "'" Then /* Alloc w/O tso name     */ 0133000
0
       'LMINIT DATAID(VCURSOR) DATASET('''name''')'                      0134000
0
     If rc=0 Then                                                        0135000
0
       Do                                                                0136000
0
         service=translate(service)                                      0137000
0
         If service='PROMPT' Then                                        0138000
0
           Call getservice                                               0139000
0
         If service<>"" Then                                             0140000
0
         service 'DATAID('vcursor')' mem    /* View the dataset     */   0141000
0
       End                                                               0142000
0
     Else                               /* Allocs failed: Set original   0143000
0
                                           message                    */ 0144000
0
       'LMINIT DATAID(VCURSOR) DATASET('name')'                          0145000
0
     If rc>7 Then                                                        0146000
0
       'SETMSG MSG(ISRZ002)'            /* If error, show messages    */ 0147000
0
     'LMFREE DATAID(&VCURSOR)'          /* Free ds if allocated       */ 0148000
0
   End                                                                   0149000
0
Else                                    /* Cursor was not on a dsname */ 0150000
0
   Do                                   /* Give user an error message */ 0151000
0
     zerrsm = 'Invalid cursor position'                                  0152000
0
     Parse Value '* YES The cursor was not on a data set name.',         0153000
0
       With zerrhm zerralrm zerrlm                                       0154000
0
     'SETMSG MSG(ISRZ002)'                                               0155000
0
   End                                                                   0156000
0
Exit 0                                                                   0157000
0
get_zscreen_values:                     /* obtain the screen image    */ 0158000
0
Address ispexec 'VGET (ZSCREENW,ZSCREEND)'                               0159000
0
p = ptr(96+ptr(ptr(24+ptr(112+ptr(132+ptr(540))))))                      0160000
0
zscreeni=translate(storage(d2x(p),,                                      0161000
0
   zscreenw*zscreend),,xrange('00'x,'3f'x))                              0162000
0
zscreenc = c2d(storage(,                                                 0163000
0
   d2x(164+ptr(ptr(24+ptr(112+ptr(132+ptr(540)))))),4))                  0164000
0
Return                                                                   0165000
0
ptr:   Return c2d(bitand(storage(d2x(Arg(1)),4),'7FFFFFFF'x))            0166000
0
getservice: Procedure Expose service name omem                           0167000
0
'VGET ZSCREEN'                                                           0168000
0
service='EDIT'                                                           0169000
0
dsn=name                                                                 0170000
0
Parse Source   . . me .                                                  0171000
0
If omem <> "" Then                                                       0172000
0
   Do                                                                    0173000
0
    If substr(dsn,1,1)='''' Then                                         0174000
0
      dsn=substr(dsn,1,length(dsn)-1)'('omem')'''                        0175000
0
    Else                                                                 0176000
0
      dsn=dsn'('omem')'                                                  0177000
0
   End                                                                   0178000
0
Address tso                                                              0179000
0
ddname='¢VCSR¢'zscreen                                                   0180000
0
'alloc f('ddname') reuse new del dso(po) dir(1) sp(1)' ,                 0181000
0
   'track recfm(f b) lrecl(80)'                                          0182000
0
Address ispexec                                                          0183000
0
'LMINIT DATAID(DID) DDNAME('ddname') ENQ(EXCLU)'                         0184000
0
'LMOPEN DATAID(&DID) OPTION(OUTPUT)'                                     0185000
0
Call write ")ATTR"                                                       0186000
0
Call write "+ TYPE(NT)"                                                  0187000
0
Call write "@ TYPE(PT)"                                                  0188000
0
Call write "? TYPE(CH)"                                                  0189000
0
Call write "# TYPE(output) just(asis) caps(off)"                         0190000
0
Call write ")BODY WINDOW(60,14)"                                         0191000
0
Call write "                   @Cursor Sensitive Action+"                0192000
0
Call write "+%"                                                          0193000
0
Call write "+Dataset:+&DSN"                                              0194000
0
Call write "+"                                                           0195000
0
Call write "?   Select action:"                                          0196000
0
Call write "       _Z% 1. Edit"                                          0197000
0
Call write "      %#VCAXXY      +"                                       0198000
0
Call write "      %#VCAXXZ      +"                                       0199000
0
Call write " "                                                           0200000
0
Call write "? Press%END?to cancel this action."                          0201000
0
Call write " "                                                           0202000
0
Call write "? To avoid this panel, modify your "me" exec."               0203000
0
Call write ")INIT"                                                       0204000
0
Call write " VGET (VCACTNX) PROFILE"                                     0205000
0
Call write " .ZVARS = 'VCACTNX'"                                         0206000
0
Call write " &VCAXXY = '   2. View'"                                     0207000
0
Call write " &VCAXXZ = '   3. Browse'"                                   0208000
0
Call write ")REINIT"                                                     0209000
0
Call write " REFRESH(*)"                                                 0210000
0
Call write ")PROC"                                                       0211000
0
Call write " IF (.CURSOR = VCAXXY) &VCACTNX = '2' /* allow csr selct*/"  0212000
0
Call write " IF (.CURSOR = VCAXXZ) &VCACTNX = '3'"                       0213000
0
Call write " VER (&VCACTNX, NB ,LIST,1,2,3)"                             0214000
0
Call write " IF (.MSG NE &Z) &VCACTNX=1"                                 0215000
0
Call write " VPUT (VCACTNX) PROFILE"                                     0216000
0
Call write ")END"                                                        0217000
0
'LMMADD DATAID(&DID) MEMBER(FOO)'                                        0218000
0
'LMFREE DATAID(&DID)'                                                    0219000
0
'LIBDEF ISPPLIB LIBRARY ID('ddname')'                                    0220000
0
'ADDPOP'                                                                 0221000
0
'DISPLAY PANEL(FOO)'                                                     0222000
0
If rc>0 Then service=""                                                  0223000
0
Else If vcactnx=2 Then service='VIEW'                                    0224000
0
Else If vcactnx=3 Then service='BROWSE'                                  0225000
0
'REMPOP'                                                                 0226000
0
'LIBDEF ISPPLIB'                                                         0227000
0
Address tso                                                              0228000
0
'FREE F('ddname')'                                                       0229000
0
Return                                                                   0230000
0
write:                                                                   0231000
0
Parse Arg p1                                                             0232000
0
"LMPUT DATAID(&DID) MODE(INVAR) DATALOC(P1) DATALEN(80)"                 0233000
0
Return                                                                   0234000
0
MEMBER NAME   ZOOME
/* REXX */                                                               0001000
0
address ispexec                                                          0002000
0
 /*****************************************************************/     0003000
0
 /* Type 'zoome' on the command line and then place your cursor on*/     0004000
0
 /* a line of JCL contianing DSN= or PATH=. You will then be taken*/     0005000
0
 /* into ISPF VIEW on that dataset or PATH.                        */    0006000
0
 /*                                                                */    0007000
0
 /* Even more useful if you assign ZOOME to a PF key, so you can   */    0008000
0
 /* place your cursor and just hit the PF key.                     */    0009000
0
 /*                                                                */    0010000
0
 /* Extended from original 'ZOOM' macro to handle PATH=, ORDER=    */    0011000
0
 /*****************************************************************/     0012000
0
     "ISREDIT MACRO"                   /* Required */                    0013000
0
     "isredit (row,col) = cursor"      /* Get row and column number */   0014000
0
     "isredit (lineData) = line" row   /* Get the line data */           0015000
0
                                                                         0016000
0
     /* find DSP=SYS1.&SYSNAME..PARMLIB or PATH= */                      0017000
0
     filePos = INDEX(lineData,'DSN=')     /* Find DSN= */                0018000
0
     if ( filePos = 0 ) then              /* No DSN=, */                 0019000
0
        do                                                               0020000
0
           filePos = INDEX(lineData,'ORDER=')  /* Look for PATH = */     0021000
0
           if ( filePos = 0 ) then              /* No ORDER=, */         0022000
0
              do                                                         0023000
0
                 filePos = INDEX(lineData,'PATH=')  /* Look for PATH = */0024000
0
                 if ( filePos <> 0 ) then /* PATH= was found */          0025000
0
                    do                                                   0026000
0
                    pathflag = 1                                         0027000
0
                    file = substr(lineData,filePos+5)                    0028000
0
                    end                                                  0029000
0
                 else                                                    0030000
0
                    do /* Nothing found; use text under cursor as DSN */ 0031000
0
                    filePos = col                                        0032000
0
                    file = findDsn(filePos,lineData)                     0033000
0
                    end                                                  0034000
0
                 end                                                     0035000
0
              else /* ORDER= was found */                                0036000
0
                 file = substr(lineData,filePos+6)                       0037000
0
        end                                                              0038000
0
      else /* DSN= was found */                                          0039000
0
         file = substr(lineData,filePos+4) /* file = Pos to end line */  0040000
0
                                                                         0041000
0
     /* DSN= or PATH= not found. */                                      0042000
0
     /* this should never happen, as if these aren't found, we just take 0043000
0
        the data underthe cursor */                                      0044000
0
     if ( filePos = 0 ) then                                             0045000
0
        do                                                               0046000
0
        zedsmsg = 'No DSN= or PATH= found' /* Set short message */       0047000
0
        zedlmsg = 'In line data ' lineData /* Set long message */        0048000
0
        'ISPEXEC SETMSG MSG(ISRZ001)'      /* Set the message  */        0049000
0
        exit                                                             0050000
0
        end                                                              0051000
0
                                                                         0052000
0
     /* Look for a ')', ',' or ' ' to terminate the file name */         0053000
0
     /* If a PATH, then ' ' is the terminator */                         0054000
0
     member = index(file,')')                     /* Find ')' */         0055000
0
     if ( member > 0 ) then file = substr(file,1,member)                 0056000
0
     comma = index(file,',')                     /* Find ',' */          0057000
0
     if ( comma > 0 ) then file = substr(file,1,comma-1)                 0058000
0
     /* None of these - just return the string ending in ' ' */          0059000
0
     file = subword(file,1,1)                                            0060000
0
                                                                         0061000
0
     upper file /* Convert to upper case */                              0062000
0
     file = subVar(file) /* Replace any symbolic variables */            0063000
0
                                                                         0064000
0
     /* See if dataset exists */                                         0065000
0
     if ( pathflag <> 1 ) then  /* Not a PATH */                         0066000
0
        do                                                               0067000
0
        x = SYSDSN("'"file"'")                                           0068000
0
                                                                         0069000
0
        if ( x = 'OK' ) then /* Does the file exist? */                  0070000
0
           "ISPEXEC EDIT DATASET('"file"')" /* Yes - edit it */          0071000
0
        else                                /* No - issue message */     0072000
0
           do                                                            0073000
0
           zedsmsg = 'Dataset not Found'    /* Set short message */      0074000
0
           zedlmsg = x "'"file"'"           /* Set long message */       0075000
0
           'ISPEXEC SETMSG MSG(ISRZ001)'    /* Set the message  */       0076000
0
           end                                                           0077000
0
        end                                                              0078000
0
     else                      /* the file is PATH */                    0079000
0
        do                                                               0080000
0
        ADDRESS TSO "oedit " file                                        0081000
0
        end                                                              0082000
0
     exit                                                                0083000
0
                                                                         0084000
0
                                                                         0085000
0
 /* See if a character is valid in a DSN */                              0086000
0
 dsnChar: procedure                                                      0087000
0
     arg char                                                            0088000
0
     validChar = '. $#()&@' /* OK DSN chars + with alpha-nums */         0089000
0
     return (datatype(char,'A') | (index(validChar,char))>0)             0090000
1
     exit                                                                0091000
0
                                                                         0092000
0
 findDsn: procedure                                                      0093000
0
     /* Return a substring deliminated by valid dsn-characters.          0094000
0
        The search location for the substr is given by posn.             0095000
0
        Start by tracking back through the string from the initial posn  0096000
0
        until we get to position 1 (start opf string) or we find a non-  0097000
0
        valid DSN char. Then track forward until we reach end of string  0098000
0
        or another non-valid DSN char. Then return the substring between 0099000
0
        these 2 positions.                                               0100000
0
        This isn't completely accurate, as it doesn't require the found  0101000
0
        string to meet the 8.8.8 etc pattern                             0102000
0
     */                                                                  0103000
0
     parse arg posn,str                                                  0104000
0
     if (dsnChar(substr(str,posn,1))=0) then return '' /* no DSN here */ 0105000
0
     /* loop until char is non-DSN */                                    0106000
0
     do until (dsnChar(substr(str,posn,1))=0)                            0107000
0
        posn=posn-1 /* Point to previous character */                    0108000
0
        if posn = 0 then leave /* Start of string reached */             0109000
0
        end                                                              0110000
0
     posn=posn+1 /* Went off end, so step forward */                     0111000
0
                                                                         0112000
0
     /* Now find the end of the string */                                0113000
0
     endPos=posn                                                         0114000
0
     do until (dsnChar(substr(str,endPos,1))=0)                          0115000
0
     /* Track forward to find end of possible DSN */                     0116000
0
        endPos=endPos+1                                                  0117000
0
        if (endPos>length(str)) then leave /* gone off end */            0118000
0
     end                                                                 0119000
0
     return substr(str,posn,endPos-posn)                                 0120000
0
     exit                                                                0121000
0
                                                                         0122000
0
 subVar: procedure                                                       0123000
0
 /* Replace symbolic vars in string with their values */                 0124000
0
     parse arg string                                                    0125000
0
     i = index(string,'&SYSNAME.')                                       0126000
0
     if ( i <> 0 ) then                                                  0127000
0
        do                                                               0128000
0
        sysname = MVSVAR('SYSNAME')                                      0129000
0
        string = substr(string,1,i-1)||sysname||substr(string,i+9)       0130000
2
        end                                                              0131000
0
                                                                         0132000
0
     i = index(string,'&LOCATE.')                                        0133000
0
     if ( i <> 0 ) then                                                  0134000
0
        do                                                               0135000
0
        locate = MVSVAR('SYMDEF','LOCATE')                               0136000
0
        string = substr(string,1,i-1)||locate||substr(string,i+8)        0137000
2
        end                                                              0138000
0
                                                                         0139000
0
     return string                                                       0140000
0
                                                                         0141000
0
MEMBER NAME   RSAVE
/* REXX */                                                               0001000
1
"ISREDIT MACRO (iMEMBER)"                                                0002000
1
ADDRESS ISREDIT                                                          0003000
1
"(zlast) = LINENUM .ZLAST"                                               0004000
1
"(zfirst) = LINENUM .ZFIRST"                                             0005000
1
"(sSESS,sJUNK) = SESSION"                                                0006000
1
if sSESS ¬= 'VIEW' then                                                  0007000
1
    do                                                                   0008000
1
    msg = 'VREP does not work within 'sSESS                              0009000
1
    x = setmsg(msg)                                                      0010000
1
    exit                                                                 0011000
1
    end                                                                  0012000
1
                                                                         0013000
1
if zLast = 0 | zFirst = 0 then                                           0014000
1
    do                                                                   0015000
1
    msg = 'VREP does not Cater for empty files'                          0016000
1
    x = setmsg(msg)                                                      0017000
1
    exit                                                                 0018000
1
    end                                                                  0019000
1
                                                                         0020000
1
"(sLIB,sJUNK,sJUNK1) = DATASET"                                          0021000
1
sFILE = "'"||sLIB||"'"                                                   0022000
1
x = listdsi(sFILE)                                                       0023000
1
select                                                                   0024000
1
   when sysdsorg = 'PO' then call pdsfile                                0025000
1
   when sysdsorg = 'PS' then call seqfile                                0026000
1
   otherwise                                                             0027000
1
     msg = 'invalid DSORG ' sysdsorg                                     0028000
1
     x = setmsg(msg)                                                     0029000
1
     exit                                                                0030000
1
   end                                                                   0031000
1
exit                                                                     0032000
1
/*******/                                                                0033000
1
SEQFILE:                                                                 0034000
1
/*******/                                                                0035000
1
"REPLACE " sFILE " .ZFIRST .ZLAST"                                       0036000
1
if rc = 0 then                                                           0037000
1
    do                                                                   0038000
1
    msg = 'Dataset 'sfile' replaced'                                     0039000
1
    x = setmsg(msg)                                                      0040000
1
    end                                                                  0041000
1
else do                                                                  0042000
1
    Address ispexec "GETMSG MSG("ZERRMSG") SHORTMSG(msg)"                0043000
1
    x = setmsg(msg)                                                      0044000
1
    end                                                                  0045000
1
return                                                                   0046000
1
/*******/                                                                0047000
1
PDSFILE:                                                                 0048000
1
/*******/                                                                0049000
1
if iMEMBER = '' then                                                     0050000
1
    do                                                                   0051000
1
    "(iMEMBER) = MEMBER"                                                 0052000
1
    sSetStats = 'YES'                                                    0053000
1
    call GetStats                                                        0054000
1
    end                                                                  0055000
1
else do                                                                  0056000
1
    upper iMEMBER                                                        0057000
1
    "(sLIB,sJUNK,sJUNK1) = DATASET"                                      0058000
1
    sSetStats = 'NO'                                                     0059000
1
    if SYSDSN("'"sLIB"("iMEMBER")'") = "OK" then                         0060000
1
      do                                                                 0061000
1
      msg = 'Member 'iMEMBER' already exists - not REPLACEd'             0062000
1
        x = setmsg(msg)                                                  0063000
1
        exit                                                             0064000
1
      end                                                                0065000
1
    end                                                                  0066000
1
"REPLACE " iMEMBER ".ZFIRST .ZLAST"                                      0067000
1
if rc = 0 then                                                           0068000
1
    do                                                                   0069000
1
    msg = 'Member 'iMEMBER' replaced'                                    0070000
1
    x = setmsg(msg)                                                      0071000
1
    if sSetStats = 'YES' then call SetStats                              0072000
1
    end                                                                  0073000
1
else do                                                                  0074000
1
    Address ispexec "GETMSG MSG("ZERRMSG") SHORTMSG(msg)"                0075000
1
    x = setmsg(msg)                                                      0076000
1
    end                                                                  0077000
1
return                                                                   0078000
1
/**************************/                                             0079000
1
GetStats:                                                                0080000
1
/**************************/                                             0081000
1
                            address ispexec "lminit dataid(s1) dataset("s0082000
1
address ispexec "lmopen   dataid("s1") OPTION(INPUT)"                    0083000
1
address ispexec "lmmfind dataid("s1") MEMBER("iMember") STATS(YES)"      0084000
1
address ispexec "lmclose dataid("s1")"                                   0085000
1
 kMOD   = ZLMOD                                                          0086000
1
 if DATATYPE(kMOD) ¬= 'NUM' then                                         0087000
1
     do                                                                  0088000
1
     sSetStats = 'NO'                                                    0089000
1
     return                                                              0090000
1
     end                                                                 0091000
1
 if kMOD < 99 THEN kMOD   = kMOD + 1                                     0092000
1
 kCDATE = ZLCDATE                                                        0093000
1
 kINORC = ZLINORC                                                        0094000
1
return                                                                   0095000
1
/********/                                                               0096000
1
SetStats:                                                                0097000
1
/********/                                                               0098000
1
address ispexec "lmmstats dataid("s1") MEMBER("iMember") ,               0099000
1
version("kVERS") MODLEVEL("kMOD") CREATED("kCDATE") INITSIZE("kINORC")"  0100000
1
address ispexec "lmfree   dataid("s1")"                                  0101000
1
exit                                                                     0102000
1
MEMBER NAME   BATCHK##
/* Rexx - BATCHK##  ************************************************************

 * Batch Performance Rename Check Procedure

 * Purpose   1 - Check that the actual RENAME process worked

 * Parms   : n/a

 * Updates follow :

 * ver 0.1 - KB 20170126 - initial write

 *

  ******************************************************************************
/
Clear

Get_Source_Name:

   Parse SOURCE . . exec_name .

   Parse Upper Arg opt

   ver = "0.1"



   Say

   Say "Starting "exec_name" version "ver" on "Date(W) Date()" at " Time()

   Say



Initialise:

   erc = 0



Read_REPORT:

   "execio * diskR REPORT (stem rep. finis)"

   "free fi(REPORT)"



Extract:

   Say " Errors extracted from REPORT are listed below"

   Do a = 1 to rep.0

     If Pos("DATA SET '",rep.a) > 0 Then Do

       Say " "rep.a

       erc = 8

     End

   End

   If erc = 0 Then Say " No errors found"



Exit:

   Say

   Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at " Time()

   Say

   Exit erc

MEMBER NAME   BATH
/* REXX   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */   0001002
5
/*                                                                  */   0001102
5
/*     NAME       -   VSAM ANALYSIS                                 */   0001112
5
/*     WRITTEN    -   JULY 94                                       */   0001122
5
/*     AUTHOR     -   D. BUTT                                       */   0001132
5
/*     ENVIRON    -   BATCH REXX                                    */   0001142
5
/*     FUNCTION   -   ANALYZES INFO FROM LISTCATS AND REPORTS ON    */   0001152
5
/*                    CERTAIN CRITERIA.                             */   0001162
5
/*     INPUT      -   READS A FILE FROM DDNAME 'LISTCAT'. THIS      */   0001172
5
/*                    FILE MUST CONTAIN THE SYSPRINT OUTPUT FROM    */   0001182
5
/*                    AN IDCAMS 'LISTC LEVEL(...) RUN.              */   0001192
5
/*     OUTPUT     -   WRITES A FILE TO DDNAME 'SYSPUNCH'.           */   0001202
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0001342
5
                                                                         0001402
5
                                                                         0001502
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0001512
5
/* READ THE INPUT FILE INTO A STEM.                                 */   0001602
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0001702
5
   'EXECIO * DISKR LISTCAT (STEM LISTC. FINIS'

                                                                         0003002
5
                                                                         0003102
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0003202
5
/* INITIALISE THE LOGIC SWITCH.                                     */   0003302
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0003402
5
   Z = 0                                                                 0004000
4
   CISFOUND = 0

   CASFOUND = 0

   EXTFOUND = 0

                                                                         0004102
5
                                                                         0004202
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0004302
5
/* PROCESS THE INPUT FILE IN STEM 'LISTC.'. SEARCH FOR THE DATA     */   0004402
5
/* LINE NAME FIRST. WHEN ONE IS FOUND THEN SEARCH FOR THE LINE      */   0004412
5
/* CONTAINING THE 'EXTENTS CI-SPLITS & CA-SPLITS.                   */   0004422
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0004502
5
                                                                         0004602
5
                                                                         0004702
5
   DO   N = 1  TO  LISTC.0                                               0005000
2
                                                                         0004702
5
                                                                         0005102
5
          LISTC.N = SUBSTR(LISTC.N,2)

          TEMP    = SUBSTR(LISTC.N,1,4)

                                                                         0005402
                                                                         0005502
           IF Z = 0 & TEMP ¬= 'DATA' THEN ITERATE

           IF Z = 0 & TEMP = 'DATA' & POS('BATH',LISTC.N) <> 0 THEN DO

           Z=1                                                           0008000
4
           BASE=WORD(LISTC.N,3)

           ITERATE

           END

                                                                         0011202
5
/*   CHECK FOR CI-SPLITS                                              */



         IF Z = 1 & POS('SPLITS-CI',LISTC.N)<>0 THEN DO

              CIS = WORD(LISTC.N,2)

              CIS = RIGHT(CIS,3)

              CIS = STRIP(CIS,B,'-')

           CISFOUND = '1'

           END

           ELSE NOP



         IF CIS > '29' & CISFOUND = '1' THEN DO

           CISVAR = BASE 'HAS' CIS 'CI-SPLITS'

           CISFOUND = '0'

           PUSH CISVAR

           "EXECIO 1 DISKW DDCIS (FINIS"

         END

           ELSE NOP

                                                                         0011202
5
/*   CHECK FOR CA-SPLITS                                              */



         IF Z = 1 & POS('SPLITS-CA',LISTC.N)<>0 THEN DO

           CAS = WORD(LISTC.N,2)

           CAS = RIGHT(CAS,3)

           CAS = STRIP(CAS,B,'-')

           CASFOUND = '1'

        END

        ELSE NOP



       IF   CAS > '1' & CASFOUND = '1' THEN DO

           CASVAR = BASE 'HAS' CAS 'CA-SPLITS'

           CASFOUND = '0'

           PUSH CASVAR                                                   0017101
5
           "EXECIO 1 DISKW DDCAS (FINIS"

       END

           ELSE NOP

                                                                         0011202
5
/*   CHECK FOR GREATER THAN 1  EXTENTS                                */





        IF Z = 1 & POS('EXTENTS',LISTC.N)<>0 THEN DO

           Z = 0

           EXT = RIGHT(LISTC.N,2)

           EXT = RIGHT(EXT,3)

           EXT = STRIP(EXT,B,'-')

           EXTFOUND = '1'

        END

        ELSE NOP





        IF EXT > '1' & EXTFOUND = '1' THEN DO

           EXTVAR = BASE 'HAS GONE TO' EXT 'EXTENTS'

           EXTFOUND = '0'

           PUSH EXTVAR

           "EXECIO 1 DISKW DDEXT (FINIS"

           END

           ELSE NOP



     END





                                                                         0021002
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0022002
5
/* ALL INPUT PROCESSED. WRITE STATISTICS MESSAGES TO THE STACK.     */   0022102
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0022202
5
           DAVEB = 'BATH DATASETS EXCEEDING 29 CI-SPLITS'

           PUSH DAVEB                                                       0025
1
           "EXECIO 1 DISKW DDCIS (FINIS"



           DAVEB = 'BATH DATASETS EXCEEDING 1 CA-SPLIT'

           PUSH DAVEB                                                       0025
1
           "EXECIO 1 DISKW DDCAS (FINIS"



           DAVEB = 'BATH DATASETS EXCEEDING 1 EXTENT'

           PUSH DAVEB                                                       0025
1
           "EXECIO 1 DISKW DDEXT (FINIS"



                                                                         0028002
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0029002
5
/* E N D     O F    P R O G R A M                                   */   0030002
5
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */    0031002
5
MEMBER NAME   BATREN##
/* Rexx - BATREN##  ************************************************************

 * Batch Performance Rename Build Procedure

 * Purpose   1 - Check if new files exist

 *               If (1) is yes and INITIAL issue message and RC=1

 *           2 - Check if old files exist

 *               If (2) is no, issue message and continue with next file

 *               If (2) is yes, proceed to (3)

 *           3 - Get attributes of old files

 *           4 - Build gdg base statements for new files if INITIAL mode only

 *           5 - Build Hrecall statements for old files if migrated and INITIAL

 *           6 - Build Rename statements for old files to new files

 * Parms   : opt 'INITIAL' or 'BATCH'

 * Updates follow :

 * ver 0.3 - KB 20170407 - added code to avoid multi-renames for multi-volumes

 * ver 0.2 - KB 20170406 - fix to ignore invalid suffixed ## files

 * ver 0.1 - KB 20170126 - initial write

 *

  ******************************************************************************
/
Clear

Get_Source_Name:

   Parse SOURCE . . exec_name .

   Parse Upper Arg opt

   ver = "0.3"



   Say

   Say "Starting "exec_name" version "ver" on "Date(W) Date()" at " Time()

   Say

   Say " '"opt"' mode selected"



Initialise:

   mode = Sysvar(sysenv)

   If mode = 'FORE' Then Signal Exit

   erc = 0

   fcnt = 0

   ercnt = 0



   filelist = " "

   /*exclude_list = " "*/

   gdgbasecnt = 0

   hrecallcnt = 0

   renamecnt  = 0

   renamelist = " "



Read_INLIST:

   "execio * diskR INLIST (stem inlist. finis)"

   If rc <> 0 Then Do

     Say " "

     Say " Error - Reading INLIST file. Routine stopped."

     Exit 12

   End

   "free fi(INLIST)"

   If inlist.0 = 0 Then Do

     Say " Error - no records on the INLIST file. Routine stopped."

     Exit 12

   End

/*

Read_EXCLUDE:

   "execio * diskR EXCLUDE (stem exclude. finis)"

   "free fi(EXCLUDE)"



Build_Exclude_List:

   Do ex = 1 to exclude.0

     exclude_list = exclude_list" "Strip(exclude.ex)

   End

*/

Extract:

   Do a = 1 to inlist.0

     oldfile = Word(inlist.a,1)

     dotPSpos = Length(oldfile)-2

     newfile = Overlay(".##",oldfile,dotPSpos)

     newbase = newfile



     /*If Pos(oldfile,exclude_list) > 0 Then Iterate a*/



     sline1 = " "oldfile

     sline1 = Overlay(newfile,sline1,50)



     Call Check_File(newfile)

     If lrc = 0 Then Do

       If opt = "INITIAL" Then Do

         ercnt = ercnt + 1

         error.ercnt = " NEW FILE ALREADY EXISTS - "newfile

         erc = 1

       End

     End



     Call Check_File(oldfile)

     If lrc <> 0 Then Do

       ercnt = ercnt + 1

       error.ercnt = " OLD FILE GV00 MISSING   - "oldfile

       erc = 2

     End

     Call Get_Old_File_Attributes



   End



Display_ERROR_Messages:

   Say

   Say " ERROR MESSAGES"

   If ercnt = 0 Then Say "   No errors found"

   Else Do

     Say "   There were "ercnt" errors encountered. See ERRORS sysout"

   End



Display_GDGBASE_Define_Statements:

   If opt = "INITIAL" Then Do

     Say

     Say " GDG BASE DEFINE STATEMENTS"

     Do z = 1 to gdgbasecnt

       Say Right(z,4," ")"    "gdgbase.z

     End

     Drop z

   End



Display_HRECALL_Statements:

   Say

   If opt = "INITIAL" Then Say " HRECALL STATEMENTS"

   Else Say " HRECALL STATEMENTS (reference only - HRECALL DD not populated)"

   If hrecallcnt = 0 Then Say "   No files were found to be migrated"

   Do z = 1 to hrecallcnt

     Say Right(z,4," ")"    "hrecall.z

   End

   Drop z



Display_RENAME_Statements:

   Say

   Say " RENAME STATEMENTS"

   If renamecnt = 0 Then Say "   No files were found to be renamed"

   Do z = 1 to renamecnt

     Say Right(z,4," ")"    "rename.z

   End

   Drop z

   Say



Write_Statements:

   "execio "renamecnt"  diskW RENAME  (stem rename.  finis)"

   "execio "ercnt"      diskW ERRORS  (stem error.   finis)"

   If opt = "INITIAL" Then Do

     "execio "hrecallcnt" diskW HRECALL (stem hrecall. finis)"

     "execio "gdgbasecnt" diskW GDGBASE (stem gdgbase. finis)"

   End



Exit:

   Say

   Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at " Time()

   Say

   Exit erc



Check_File:

   Arg filetype

   trapit = OutTrap(listc1.)

   "LISTC ENT('" || filetype || "') ALL"

   lrc = rc

   trapit = OutTrap(Off)



   Return



Get_Old_File_Attributes:

   renamelist = " "

   Do l = 1 to listc1.0

     If Pos("GDG BASE",listc1.l) > 0 Then gdg = "Y"

     If Pos(" LIMIT--",listc1.l) > 0 Then Do

       xline = Translate(listc1.l," ","-")

       gdg_limit    = Word(xline,2)

       gdg_scratch  = Word(xline,3)

       gdg_noempty  = Word(xline,4)

       If gdg = "Y" Then Do

         gdgxyz = "     LIMIT("gdg_limit")" gdg_scratch gdg_noempty")"

         gdgbasecnt = gdgbasecnt + 1

         gdgbase.gdgbasecnt = " DEF GDG (NAME('"newfile"') - "

         gdgbasecnt = gdgbasecnt + 1

         gdgbase.gdgbasecnt = gdgxyz

       End

     End

     If Pos("NONVSAM ---- ",listc1.l) > 0 Then Do

       xline = Translate(listc1.l," ","-")

       gdg_file = Word(xline,2)

     End

     If Pos("VOLSER----",listc1.l) > 0 Then Do

       If Pos(gdg_file,renamelist) > 0 Then Iterate l

       xline = Translate(listc1.l," ","-")

       volser = Word(xline,2)

       If volser = "MIGRAT" Then Do

         hrecallcnt = hrecallcnt + 1

         hrecall.hrecallcnt = " HRECALL '"gdg_file"'"

         hrecall.hrecallcnt = Overlay("WAIT",hrecall.hrecallcnt,60)

       End



       renamecnt = renamecnt + 1

       rename.renamecnt = " ALTER   '"gdg_file"'"

       rename.renamecnt = Overlay("-",rename.renamecnt,60)



       checkfile = Left(gdg_file,Length(gdg_file)-9) /* PS base name */



       Call Get_##_GV00



       renamecnt = renamecnt + 1

       rename.renamecnt = " NEWNAME('"Overlay(newfile,gdg_file,1)"')"

       renamelist = renamelist" "gdg_file

     End

   End



   Drop listc1.



   Return



Get_##_GV00:

   newfile_length = Length(newfile) - 9

   temp_newfile = newfile



   If checkfile = temp_temp_checkfile Then Do /* same base different GV00 */

     ##GV00num = ##GV00num + 1

     If ##GV00num = 10000 Then ##GV00num = 1

     ##GV00num = Right(##GV00num,4,'0')

     ##GV00    = "G"##GV00num"V00"

     newfile   = newbase"."##GV00

     Return 0

   End



   listc_trap = OutTrap(listc2.)

   Address TSO "listcat lvl('"temp_newfile"')" /* check for GV00 under ## */

   l2rc = rc

   If l2rc <> 0 Then Return 0 /* ## GV00 not found so rename as like */

   listc_trap = OutTrap(Off)



   listc_cnt = listc2.0 - 1



   ##GV00dsn = Word(listc2.listc_cnt,3)

   If Right(##GV00dsn,3) <> "V00" Then Return 0 /* not a valid GV00 */

   ##GV00num = Right(##GV00dsn,8)

   ##GV00num = SubStr(##GV00num,2,4)

   ##GV00num = ##GV00num + 1

   If ##GV00num = 10000 Then ##GV00num = 1

   ##GV00num = Right(##GV00num,4,'0')

   ##GV00    = "G"##GV00num"V00"



   temp_temp_checkfile = checkfile

   newfile = temp_newfile"."##GV00



   Drop listc2.



   Return 0



MEMBER NAME   BATREN#O
/* Rexx - BATREN##  ************************************************************

 * Batch Performance Rename Build Procedure

 * Purpose   1 - Check if new files exist

 *               If (1) is yes and INITIAL issue message and RC=1

 *           2 - Check if old files exist

 *               If (2) is no, issue message and continue with next file

 *               If (2) is yes, proceed to (3)

 *           3 - Get attributes of old files

 *           4 - Build gdg base statements for new files if INITIAL mode only

 *           5 - Build Hrecall statements for old files if migrated and INITIAL

 *           6 - Build Rename statements for old files to new files

 * Parms   : opt 'INITIAL' or 'BATCH'

 * Updates follow :

 * ver 0.1 - KB 20170126 - initial write

 *

  ******************************************************************************
/
Clear

Get_Source_Name:

   Parse SOURCE . . exec_name .

   Parse Upper Arg opt

   ver = "0.1"



   Say

   Say "Starting "exec_name" version "ver" on "Date(W) Date()" at " Time()

   Say

   Say " '"opt"' mode selected"



Initialise:

   mode = Sysvar(sysenv)

   If mode = 'FORE' Then Signal Exit

   erc = 0

   fcnt = 0

   ercnt = 0



   filelist = " "

   /*exclude_list = " "*/

   gdgbasecnt = 0

   hrecallcnt = 0

   renamecnt  = 0



Read_INLIST:

   "execio * diskR INLIST (stem inlist. finis)"

   If rc <> 0 Then Do

     Say " "

     Say " Error - Reading INLIST file. Routine stopped."

     Exit 12

   End

   "free fi(INLIST)"

   If inlist.0 = 0 Then Do

     Say " Error - no records on the INLIST file. Routine stopped."

     Exit 12

   End

/*

Read_EXCLUDE:

   "execio * diskR EXCLUDE (stem exclude. finis)"

   "free fi(EXCLUDE)"



Build_Exclude_List:

   Do ex = 1 to exclude.0

     exclude_list = exclude_list" "Strip(exclude.ex)

   End

*/

Extract:

   Do a = 1 to inlist.0

     oldfile = Word(inlist.a,1)

     dotPSpos = Length(oldfile)-2

     newfile = Overlay(".##",oldfile,dotPSpos)



     /*If Pos(oldfile,exclude_list) > 0 Then Iterate a*/



     sline1 = " "oldfile

     sline1 = Overlay(newfile,sline1,50)



     Call Check_File(newfile)

     If lrc = 0 Then Do

       If opt = "INITIAL" Then Do

         ercnt = ercnt + 1

         error.ercnt = " NEW FILE ALREADY EXISTS - "newfile

         erc = 1

       End

     End



     Call Check_File(oldfile)

     If lrc <> 0 Then Do

       ercnt = ercnt + 1

       error.ercnt = " OLD FILE GV00 MISSING   - "oldfile

       erc = 2

     End

     Call Get_Old_File_Attributes



   End



Display_ERROR_Messages:

     Say

     Say " ERROR MESSAGES"

     If ercnt = 0 Then Say "   No errors found"

     Else Do

       Say "   There were "ercnt" errors encountered. See ERRORS sysout"

     End



Display_GDGBASE_Define_Statements:

   If opt = "INITIAL" Then Do

     Say

     Say " GDG BASE DEFINE STATEMENTS"

     Do z = 1 to gdgbasecnt

       Say Right(z,4," ")"    "gdgbase.z

     End

     Drop z

   End



Display_HRECALL_Statements:

   Say

   If opt = "INITIAL" Then Say " HRECALL STATEMENTS"

   Else Say " HRECALL STATEMENTS (reference only - HRECALL DD not populated)"

   If hrecallcnt = 0 Then Say "   No files were found to be migrated"

   Do z = 1 to hrecallcnt

     Say Right(z,4," ")"    "hrecall.z

   End

   Drop z



Display_RENAME_Statements:

   Say

   Say " RENAME STATEMENTS"

   Do z = 1 to renamecnt

     Say Right(z,4," ")"    "rename.z

   End

   Drop z

   Say



Write_Statements:



   "execio "renamecnt"  diskW RENAME  (stem rename.  finis)"

   "execio "ercnt"      diskW ERRORS  (stem error.   finis)"

   If opt = "INITIAL" Then Do

     "execio "hrecallcnt" diskW HRECALL (stem hrecall. finis)"

     "execio "gdgbasecnt" diskW GDGBASE (stem gdgbase. finis)"

   End



Exit:

   Say

   Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at " Time()

   Say

   Exit erc



Check_File:

   Arg filetype

   trapit = OutTrap(listc1.)

   "LISTC ENT('" || filetype || "') ALL"

   lrc = rc

   trapit = OutTrap(Off)



   Return



Get_Old_File_Attributes:

   Do l = 1 to listc1.0

     If Pos("GDG BASE",listc1.l) > 0 Then gdg = "Y"

     If Pos(" LIMIT--",listc1.l) > 0 Then Do

       xline = Translate(listc1.l," ","-")

       gdg_limit    = Word(xline,2)

       gdg_scratch  = Word(xline,3)

       gdg_noempty  = Word(xline,4)

       If gdg = "Y" Then Do

         gdgxyz = "     LIMIT("gdg_limit")" gdg_scratch gdg_noempty")"

         gdgbasecnt = gdgbasecnt + 1

         gdgbase.gdgbasecnt = " DEF GDG (NAME('"newfile"') - "

         gdgbasecnt = gdgbasecnt + 1

         gdgbase.gdgbasecnt = gdgxyz

       End

     End

     If Pos("NONVSAM ---- ",listc1.l) > 0 Then Do

       xline = Translate(listc1.l," ","-")

       gdg_file = Word(xline,2)

     End

     If Pos("VOLSER----",listc1.l) > 0 Then Do

       xline = Translate(listc1.l," ","-")

       volser = Word(xline,2)

       If volser = "MIGRAT" Then Do

         hrecallcnt = hrecallcnt + 1

         hrecall.hrecallcnt = " HRECALL '"gdg_file"'"

         hrecall.hrecallcnt = Overlay("WAIT",hrecall.hrecallcnt,60)

       End



       renamecnt = renamecnt + 1

       rename.renamecnt = " ALTER   '"gdg_file"'"

       rename.renamecnt = Overlay("-",rename.renamecnt,60)



       checkfile = Left(gdg_file,Length(gdg_file)-9)



       Call Get_##_GV00



       renamecnt = renamecnt + 1

       rename.renamecnt = " NEWNAME('"Overlay(newfile,gdg_file,1)"')"

     End

   End



   Drop listc1.



   Return



Get_##_GV00:

   pluscnt = 0

   newfile_length = Length(newfile) - 9

   temp_newfile = SubStr(newfile,1,newfile_length)

   temp_newfile = newfile



   If checkfile = temp_temp_checkfile Then pluscnt = pluscnt + 1

   Else pluscnt = 1



   listc_trap = OutTrap(listc2.)

   Address TSO "listcat lvl('"temp_newfile"')"

   If rc <> 0 Then Return 0

   listc_trap = OutTrap(Off)



   listc_cnt = listc2.0 - 1

   ##GV00dsn = Word(listc2.listc_cnt,3)

   ##GV00num = Right(##GV00dsn,8)

   ##GV00num = SubStr(##GV00num,2,4)

   ##GV00num = ##GV00num + pluscnt

   If ##GV00num = 10000 Then ##GV00num = 1

   ##GV00num = Right(##GV00num,4,'0')

   ##GV00    = "G"##GV00num"V00"



   temp_temp_checkfile = checkfile

   newfile = temp_newfile"."##GV00



   Drop listc2.



   Return 0



MEMBER NAME   CA7BUILD
/* Language            : Rexx

 * Program Name        : CA7BUILD

 * Description         : To build CA7 control cards from BTI output.

 * Input Parameters    : cmr

 * Output Parameters   : none

 * Panel Names         : none

 * Table Names         : none

 * Skeleton Names      : none

 * Macro Names         : none

 * Rexx Names          : none

 * Program Names       : none

 * Message Names       : Internal ZEDxMSG's

 * Execution Mode      : TSO or Batch

 * Procedure           : none

 * Batch Job Name      : none

 * Restrictions        : JOC userids

 * User                : JCL Management

 * Author              : KEN BALNAVE

 * Department          : JCL MANAGEMENT

 * Owner               : KEN BALNAVE - JCL MANAGEMENT

 * Created             : 16th February 2006

 * Status              : Test/Live

 * Modified as below   : Latest modification on top.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 8th February 2018 - ver 4.1.0

 * 1: Updated calendar scheduling for issues with month calendars.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 5th October 2016 - ver 4.0.0

 * 1: Updated to cater for FDI1 CCI ssct change from UCT7 to CA71

 * 2: Added Cross Scheduling AGENT parameter pick up

 * 3: Changed '###' comments to 'DBM' to avoid errors in output report

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 14th April 2015 - ver 3.9

 * 1: Updated to cater for FDI1 CCI Node.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 10th March 2015 - ver 3.8

 * 1: Updated RESTART section to cater for RESTART=N

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 9th December 2014 - ver 3.7

 * 1: Changed CONDCODE/RELOPR setting to cater for #SCC cards

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 15th August 2014 - ver 3.6.5

 * 1: Updated WEEKLY scheduling for specific days to include missing comma.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 14th June 2013 - ver 3.6.4

 * 1: Added 'DONT SCHEDULE' info.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 28th March 2013 - ver 3.6.3

 * 1: Added bypass of JOBCARD if we only want the BTI section.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 10th March 2013 - ver 3.6.2

 * 1: Correct USR REQ's by removing check for duplicates.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 26th February 2013 - ver 3.6.1

 * 1: Added a date parm to the jobcard to identify when routine was run.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 21th February 2013 - ver 3.6

 * 1: Added check for HOLD=Y.

 * 2: Hardcoded SMFID parms for machine recognition.

 * 3: Moved REQUIREMENT write back to be after SUCCESSOR write and added extra

 *     check for duplicates.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 20th February 2013 - ver 3.5.3

 * 1: Updated node parm to be picked up from ENV before its picked up from CCI

 * 2: Update USR section to cater for ONLY option and length of requirement

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 15th February 2013 - ver 3.5.2

 * 1: Updated USR requirement section if report was split by '1LJOB,' to

 *     enable getting the SCHID from the next page.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 14th February 2013 - ver 3.5.1

 * 1: Updated TRIGGER section to pick up qtime & ldtime from ca7 rather than

 *     hardcoded 0010,0010.

 * 2: Corrected issue with checking SUCCESS jobs via CCI by adding node parm.

 * 3: Moved REQUIREMENT write to be before SUCCESSOR write.

 * 4: Moved DSN adds to be before DSN triggers.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 7th February 2013 - ver 3.4

 * 1: Added GDG=N for SIGNET specific dataset triggering.

 * 2: Added OWNER=JOCP000 if *NONE* is found (blank owner in CA7).

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 6th February 2013 - ver 3.3

 * 1: Added SCHID & TRGID to DSN triggered section

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 2nd January 2013 - ver 3.2

 * 1: Updated to check for LEADTM on SUCCESSOR fields

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 17th October 2012

 * 1: Commented out some SAY statements.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 24th August 2009

 * 1: Updated DTRG to be on 2 lines.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 28th July 2009

 * 1: Updated RESOLVE statement to display resolved dates.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 29th June 2009 (pre-backup CA7BLD24)

 * 1: Added REPEAT scheduling check.

 * 2: Added GDG variable.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 18th February 2009

 * 1: Re-added the SUCCESSOR write

 * 2: Added MAINT section.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 28th May 2008

 * 1: Updated looping in REQUIREMENTS section.

 * 2: Corrected system_name variables.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 5th October 2006

 * 1: Added setting of default cond_code and rel_oper statements.

 * 2: Change ZSYSID to MVSVAR setting as ZSYSID wasn't working ?

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 21st September 2006

 * 1: Removed the SUCCESSOR write as these variables will have been extracted

 *     from the REQUIREMENTS section, thus stopping duplicates.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 29th August 2006

 * 1: Added YEAR to CALENDAR scheduling.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 28th April 2006

 * 1: Added USER REQUIREMENT setup to reqjobs section.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 20th April 2006

 * 1: Changed JOB1 collection point to allow for XYZ* job listings.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 29th March 2006

 * 1: Corrected SCHEDULE section.

 * 2: Changed WEEK to drop leading zero's.

 * 3: Added TRGID section.

  *-----------------------------------------------------------------------------

 * KEN BALNAVE - 16th February 2006

 * 1: Rewrite - taken from CA7BUILD - ver 1.3, created by Stuart Dolman.

  *-----------------------------------------------------------------------------

  ******************************************************************************
/


Issue_Message:

   Say 'CA7BUILD ver 4.1.0 - 'Date('W') Substr(Date('U'),4,2) Date('M'),

                            Left(Date('S'),4)



Collect_Variables:

   Parse Arg cmr

   If cmr = '' then Exit 12



OverRide_If_TSO_Mode:

   mode = Sysvar(sysenv)

   If mode = 'FORE' then Do

     "alloc fi(DDIN)  da('T.JOCS083.CA7BTI.LIST') SHR "

     if rc /= 0 then exit 4

     "alloc fi(DDOUT) da('T.JOCS083.CA7BTI') shr "

     if rc /= 0 then exit 4

   End



Get_System_ID:

   If MVSVAR(SYSSMFID) = 'IND2' Then node = 'IND2'

   If MVSVAR(SYSSMFID) = 'INP2' Then node = 'INP2'



Initialise:

   dte             = "D."Date('S')

   node_found      = 'N'

   jcl_id          = '020'

   system_name     = 'XXXXXXXX'

   jobnet_name     = 'XX'

   cond_code       = '0000'

   rel_oper        = 'LT'

   neg_dep_list    = ' '

   neg_done_list   = ' '

   trig_done_list  = ' '

   vrm_done_list   = ' '

   job1            = ' '

   job_list        = ' '

   line_check      = ' '

   suc_line_check  = ' '

   #type1          = ' '

   vrm_list        = 'ASX CRQ EXC RCT SHR'

   acnt            = 0 /* add jobframe count       DBM JOB       */

   adsncnt         = 0 /* add dsn count            DBM DSN       */

   ccnt            = 0 /* calendar count           built once    */

   jcnt            = 0 /* jcl count                jcl list      */

   ncnt            = 0 /* negative count           DBM JOBCONN   */

   rcnt            = 0 /* requirement count        DBM JOBCONN   */

   scnt            = 0 /* successor count          DBM JOBCONN   */

   tbdcnt          = 0 /* triggered by dsn count   DBM SCHD,DTRG */

   tbjcnt          = 0 /* trigger by job count     DBM SCHD,JTRG */

   tcnt            = 0 /* triggered jobs count     DBM SCHD,JTRG */

   ucnt            = 0 /* user req count                         */

   vcnt            = 0 /* vrm count                              */

   jlcnt           = 0 /* jobloop count                          */

   ocnt            = 0 /* final output count                     */



   a1cnt           = 0 /* annual count                                         *
/
   dowcnt          = 0 /* day-of-week count used with MONTHLY                  *
/
   wcnt            = 0 /* week count used with WEEKLY                          *
/
   w1cnt           = 0 /* week count used with MONTHLY                         *
/
   rdaycnt         = 0 /* relative day count used with MONTHLY                 *
/
   ndaycnt         = 0 /* non-day count used with MONTHLY                      *
/
   nrdaycnt        = 0 /* non-relative day count used with MONTHLY             *
/


Build_Reverse_JCL_Statements:

   If cmr <> "NOJCL" Then Do

    jcnt = jcnt + 1

    jcline.jcnt = "//RC"cmr" JOB (ACCOUNT),'"dte"',CLASS=A,MSGCLASS=9,"

    jcnt = jcnt + 1

    jcline.jcnt = "//         NOTIFY=&SYSUID"

    jcnt = jcnt + 1

    jcline.jcnt = "//*"

    jcnt = jcnt + 1

    jcline.jcnt =   "//STP0010  EXEC PGM=CAL2X2WB,"

    If MVSVAR(SYSSMFID) = 'INP2' Then Do

      jcnt = jcnt + 1

      jcline.jcnt = "//         PARM='CCIINP2,UC07,,,OUTDD' ## INP2"

    End

    If MVSVAR(SYSSMFID) = 'IND2' Then Do

      jcnt = jcnt + 1

      jcline.jcnt = "//         PARM='CCIIND2,UC07,,,OUTDD' ## IND2"

    End

    jcnt = jcnt + 1

    jcline.jcnt = "//SYSPRINT DD SYSOUT=*"

    jcnt = jcnt + 1

    jcline.jcnt = "//ERRORS   DD SYSOUT=*"

    jcnt = jcnt + 1

    jcline.jcnt = "//OUTDD    DD SYSOUT=*"

    jcnt = jcnt + 1

    jcline.jcnt = "//SYSIN    DD *"

   End

   jcnt = jcnt + 1

   jcline.jcnt = "/LOGON"



Read_LJOB_List_File:

   "Execio * Diskr DDIN (Stem in. Finis)"

   "free fi(DDIN)"

   Say

   Say " ===> "in.0" records read from CA7 list routine"

   Say



Extract:

   Do linenum = 1 to in.0

     If Pos("NODE: CCI",in.linenum) > 0 & node_found = 'N' Then Do

       node = SubStr(in.linenum,90,6)

       Say " Running for node "node

       node_found = 'Y'

     End

     If Pos('.',linenum/1000) = 0 Then Say "A++++ at record "linenum

     If Pos('SLIA-02',in.linenum) > 0 &,

        Pos('NOT FOUND',in.linenum) > 0 then Do

          nfjob = Strip(Substr(in.linenum,14,8))

          Say "+++ "nfjob "not found. Routine continues +++"

          Iterate

     End

     If Substr(in.linenum,36,4)  = "JOB="    Then Do

       job_prefix = Substr(in.linenum,40,8)

       job_prefix = Translate(job_prefix," ","*")

       job_prefix = Word(job_prefix,1)

       Say " "

       Say " Looking for all jobs starting with "job_prefix

       Say " "

     End

     If Substr(in.linenum,2,4)  = "JOB="    Then Do

       job1_count = linenum+5

       jlcnt = jlcnt + 1

       Say " +++++ Calling JobLoop number "jlcnt

       Call Jobloop

     End

     If Substr(in.linenum,21,7) = "/LOGOFF" Then Signal Merge_Contents

   End



Merge_Contents:

   /* 1st - jcl lines */

   Do m1 = 1 to jcnt

     ocnt = ocnt + 1

     oline.ocnt = jcline.m1

   End

   /* 2nd - add job lines */

   Do m2 = 1 to acnt

     ocnt = ocnt + 1

     oline.ocnt = addline.m2

   End



   /* remove extra DBM JOB statements for tidyness */

   t0ocnt = ocnt ; t1ocnt = ocnt - 1 ; t2ocnt = ocnt - 2

   If oline.t2ocnt = "DBM" & oline.t1ocnt = "JOB" Then ocnt = ocnt - 3

   If oline.t1ocnt = "DBM" & oline.t0ocnt = "JOB" Then ocnt = ocnt - 2



   /* 3rd - calendar lines */

   Do m3 = 1 to ccnt

     If m3 = 1 & ccnt > 0 then Do

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DBM   CALENDARS"

     End

     ocnt = ocnt + 1

     oline.ocnt = cal_oline.m3

   End

   /* 5th - trigger by lines */

   Do m5 = 1 to tbjcnt

     If m5 = 1 & tbjcnt > 0 then Do

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DBM   JOBS TRIGGERED BY (2ND JOB TRIGGERED BY 1ST JOB)"

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "SCHD,JTRG"

     End

     ocnt = ocnt + 1

     oline.ocnt = tbjline.m5

   End

   /* 6th - trigger lines */

   Do m6 = 1 to tcnt

     If m6 = 1 & tcnt > 0 then Do

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DBM   JOB TRIGGERS (1ST JOB TRIGGERS 2ND JOB)"

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "SCHD,JTRG"

     End

     ocnt = ocnt + 1

     oline.ocnt = trigline.m6

   End

   /* 4th - add dsn lines */

   Do m4 = 1 to adsncnt

     If m4 = 1 & adsncnt > 0 then Do

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DBM   DSN'S"

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DSN"

     End

     ocnt = ocnt + 1

     oline.ocnt = adsnline.m4

   End

   /* 7th - trigger by dsn lines */

   Do m7 = 1 to tbdcnt

     If m7 = 1 & tbdcnt > 0 then Do

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DBM   DSN TRIGGERS"

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "SCHD,DTRG"

     End

     ocnt = ocnt + 1

     oline.ocnt = tbdline.m7

   End

   /* 8th - successor lines */

   Do m8 = 1 to scnt

     If Pos(sline.m8,line_check) > 0 then Do

       nxm8 = m8 + 1

       If Pos('SCHID=',sline.nxm8) > 0 then Do

         m8 = m8 + 1

       End

       Iterate m8

     End

     If m8 = 1 & scnt > 0 then Do

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DBM   JOB SUCCESSORS (1ST JOB RUNS AFTER 2ND JOB)"

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "JOBCONN"

     End

     ocnt = ocnt + 1

     oline.ocnt = sline.m8

     line_check = line_check ' ' sline.m8

     suc_line_check = suc_line_check ' ' sline.m8

   End

   /* 9th - requirement lines */

   Do m9 = 1 to rcnt

     If Pos(rline.m9,suc_line_check) > 0 then Do

       nxm9 = m9 + 1

       If Pos('SCHID=',rline.nxm9) > 0 then Do

         m9 = m9 + 1

       End

       Iterate m9

     End

     If m9 = 1 & rcnt > 0 then Do

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DBM   JOB REQUIREMENTS (1ST JOB WAITS FOR 2ND JOB)"

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "JOBCONN"

     End

     ocnt = ocnt + 1

     oline.ocnt = rline.m9

     line_check = line_check ' ' rline.m9

   End

   /* 10th - negative dep lines */

   Do m10 = 1 to ncnt

     If Pos(nline.m10,line_check) > 0 then Iterate m10

     If m10 = 1 & ncnt > 0 then Do

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DBM   NEGATIVE DEPENDANCIES"

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "JOBCONN"

     End

     ocnt = ocnt + 1

     oline.ocnt = nline.m10

     line_check = line_check ' ' nline.m10

   End

   /* 11th - user requirements */

   Do m11 = 1 to ucnt

     /*If Pos(usrline.m11,line_check) > 0 then Iterate m11*/

     If m11 = 1 & ucnt > 0 then Do

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DBM   USER REQUIREMENTS"

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "JOBCONN,USR"

     End

     ocnt = ocnt + 1

     oline.ocnt = usrline.m11

     /*line_check = line_check ' ' usrline.m11*/

   End

   /* 12th - virtual resouce lines */

   Do m12 = 1 to vcnt

     /*If Pos(vrmline.m12,line_check) > 0 then Iterate m12*/

     If m12 = 1 & vcnt > 0 then Do

       ocnt = ocnt + 1

       oline.ocnt = "DBM"

       ocnt = ocnt + 1

       oline.ocnt = "DBM   VRM'S"

       ocnt = ocnt + 1

       oline.ocnt = "RM.1"

     End

     ocnt = ocnt + 1

     oline.ocnt = vrmline.m12

     /*line_check = line_check ' ' vrmline.m12*/

   End



Getout:                           /* All CA7 cards have been established */

   ocnt = ocnt + 1

   oline.ocnt = '/LOGOFF'

   ocnt = ocnt + 1

   oline.ocnt = '//*'

   If ocnt > 13 then Do

     "Execio "ocnt" Diskw DDOUT (stem oline. Finis)"

     Say 'CA7BUILD complete.'

   End

   Else Do

     Say 'CA7BUILD complete, but no BACKOUT records have been extracted.'

   End

   If mode = 'FORE' then "free fi(DDOUT)"



   Address TSO "delstack"



Exit: exit 0



Jobloop:                             /* read input and call relevant section */

   job1 = Strip(Substr(in.job1_count,2,8))

   Say '  Building CA7 cards for 'job1

   job_list = job_list' 'job1

   #type1 = ' '

   /*  say 'JOB LIST = 'job_list  */

   Do Forever

     cal_start = 'N'

     linenum = linenum + 1

     If Pos('.',linenum/1000) = 0 Then Say "B++++ at record "linenum

     /* new start */

     If Substr(in.linenum,75,1) = '/' Then Do

       If Substr(in.linenum,71,4) /= 'DATE' Then Do

         job1_count = linenum

         /*say in.linenum*/

         jobx = Strip(Substr(in.linenum,2,8))

         If WordPos(jobx,job_list) > 0 then NOP

         Else Signal Jobloop

       End

     /* new end */

     End

     linenum_1 = linenum - 1

     If Word(in.linenum_1,1) = job1 Then Do

       Call system_name

       /*Say "     System name statement built"*/

     End

     If Pos('-- JOB INFORMATION --',in.linenum) > 0 Then Do

       plus1_linenum = linenum + 1

       unix_job = "N"

       If Pos("LOAD STEP TO BE EXECUTED",in.plus1_linenum) = 0 Then Do

         unix_job = "Y"

       End

     End

     If Pos('JOB SET FOR EXEC ON MAIN',in.linenum) > 0 Then Do

       Call exec_job

       /*Say "     Exec statement built"*/

     End

     If Pos('JOB MARKED AS MAINT ONLY',in.linenum) > 0 Then Do

       Call maint_job

       /*Say "     MAINT statement built"*/

     End

     If Pos('JOB SET FOR HOLD IN REQQ',in.linenum) > 0 Then Do

       Call hold_job

       /*Say "     HOLD statement built"*/

     End

     If Pos('AUTO-GENERATION OF 7 RMS',in.linenum) > 0 Then Do

       Call restart_job

       /*Say "     RESTART statement built"*/

     End

     If Pos('OWNER=',in.linenum) > 0 Then Do

       prmlib = ""

       Call get_owner

       /*Say "     Owner statement built"*/

     End

     If Pos('MSGCLASS=',in.linenum) > 0 & Pos('PRTY',in.linenum) > 0 Then Do

       Call get_others

       /*Say "     Msgclass statements built"*/

     End

     If Pos('JOBNET=',in.linenum) > 0 Then Do

      Call jobnet

       /*Say "     Jobnet statement built"*/

     End

     If Pos('DONT SCHEDULE ',in.linenum) > 0 Then Do

       Call dont_schedule

       /*Say "     Dont Schedule statement built" */

     End

     If Pos('CONSIDER ABNORMAL END IF',in.linenum) > 0 Then Do

       Call cond_code

       /*Say "     Cond Code statement built"*/

     End

     If Pos('# OF TIMES LATE',in.linenum) > 0 Then Do

       If unix_job = "N" Then Call Add_Job

       /*Say "     Add statement built"*/

     End

     If Pos('- AGENT INFORMATION ',in.linenum) > 0 Then Do

       Call unixjob

       Call Add_UNIX_Job

       /*Say "     UNIX statements built"*/

     End

     If Pos('- SCHEDULES ',in.linenum) > 0 Then Do

       Call schedules

       /*Say "     Schedule statements built"*/

     End

     If Pos('- TRIGGERED BY ',in.linenum) > 0 Then Do

       tlinenum = linenum + 1

       Call triggerby

       /*Say "     Triggered by statements built"*/

     End

     If Pos('- TRIGGERED JOBS -',in.linenum) > 0 Then Do

       Call trigger

       /*Say "     Trigger statements built"*/

     End

     If Pos('- SUCCESSOR JOBS -',in.linenum) > 0 Then Do

       Call success

       /*Say "     Successor statements built"*/

     End

     If Pos('- REQUIREMENTS AND',in.linenum) > 0 Then Do

       Call reqjobs

       /*Say "     Requirement statements built"*/

     End

     If Pos('- VIRTUAL RESOURCE ',in.linenum) > 0 Then Do

       Call vrm

       /*Say "     VRM statements built"*/

     End

     If Pos(' REQUEST COMPLETED ',in.linenum) > 0 Then Do

       /*Say "     Starting to build Negative Dependencies"*/

       Call negjobs

       /*Say "     ALL Negative Dependency statements built"*/

       Return

     End

   End

   Return



system_name:

   jcl_id      = Strip(Substr(in.linenum_1,11,3))

   member_name = Strip(Substr(in.linenum_1,15,8))

   system      = Strip(Substr(in.linenum_1,24,8))

   uid         = Strip(Substr(in.linenum_1,33,3))

   mainid      = Strip(Substr(in.linenum_1,37,3))

   Tclass      = '6'

   Tmsgclass   = '0'

   Tjobnet     = 'XXXXXXXX'

   lrtime      = Strip(Substr(in.linenum_1,70,10))

   If lrtime <> '          ' Then lrt = '* LAST RUN DATE/TIME = ' lrtime' *'

   Return



exec_job:

   exec_id = Substr(in.linenum,44,1)

   Return



maint_job:

   maint_id = Substr(in.linenum,44,1)

   Return



hold_job:

   hold_id = Substr(in.linenum,44,1)

   If hold_id = "Y" Then hold_id = "HOLD=Y,"

   Else hold_id = ""

   Return



restart_job:

   restart_id = Substr(in.linenum,9,1)

   If restart_id = "Y" Then restart_id = "RESTART=Y"

   Else restart_id = "RESTART=N"

   Return



get_owner:

   owner = Strip(Substr(in.linenum,17,8))

   If Pos("PRMLIB=",in.linenum) > 0 Then prmlib = SubStr(in.linenum,33,3)

   If owner = "*NONE*" Then owner = "JOCP000"

   Return



get_others:

   class    = Substr(in.linenum,17,1)

   If class = ',' then class = Tclass

   msgclass = Substr(in.linenum,28,1)

   If msgclass = ',' then msgclass = Tmsgclass

   prty_pos = Pos('PRTY=',in.linenum) + 5

   prty     = Substr(in.linenum,prty_pos,3)

   Return



jobnet:

   jobnet_line = Translate(in.linenum,' ','=')

   jobnet_wpos = WordPos('JOBNET ',jobnet_line) + 1

   jobnet_name = Word(jobnet_line,jobnet_wpos)

   Return



dont_schedule:

   sched_words = Words(in.linenum)

   Select

     When sched_words = 5 Then Do

       #type1 = Word(in.linenum,4)

       #date1 = Word(in.linenum,5)

       #line = Left(#type1,1)"DATE="#date1

     End

     When sched_words = 7 Then Do

       #type1 = Word(in.linenum,4)

       #date1 = Word(in.linenum,5)

       #time1 = Word(in.linenum,7)

       #line = Left(#type1,1)"DATE="#date1","Left(#type1,1)"TIME="#time1

     End

     When sched_words = 10 Then Do

       #type1 = Word(in.linenum,4)

       #date1 = Word(in.linenum,5)

       #time1 = Word(in.linenum,7)

       #type2 = Word(in.linenum,9)

       #date2 = Word(in.linenum,10)

       #line = Left(#type1,1)"DATE="#date1","Left(#type1,1)"TIME="#time1","||,

               Left(#type2,1)"DATE="#date2

     End

     When sched_words = 12 Then Do

       #type1 = Word(in.linenum,4)

       #date1 = Word(in.linenum,5)

       #time1 = Word(in.linenum,7)

       #type2 = Word(in.linenum,9)

       #date2 = Word(in.linenum,10)

       #time2 = Word(in.linenum,12)

       #line = Left(#type1,1)"DATE="#date1","Left(#type1,1)"TIME="#time1","||,

               Left(#type2,1)"DATE="#date2","Left(#type2,1)"TIME="#time2

     End

     OtherWise NOP

   End

   Return



cond_code:

   cond_code = Word(in.linenum,6)

   rel_oper  = Word(in.linenum,8)

   Return



Add_Job:      /* got all the ADD variables - so ADD job */

   If acnt = 0 then Do

     acnt = acnt + 1

     addline.acnt = 'DBM'

     acnt = acnt + 1

     addline.acnt = 'JOB'

   End

   acnt = acnt + 1

   addline.acnt = 'ADD,'job1',OWNER='owner',CLASS='class',JCLID='jcl_id||,

                ',EXEC='exec_id','hold_id

   acnt = acnt + 1

   addline.acnt = 'SYSTEM='system',USERID='uid',MSGCLASS='msgclass||,

                ',PRTY='prty',MAINID='mainid','

   acnt = acnt + 1

   If cond_code = "JOB" & rel_oper = "ANY" Then Do

     addline.acnt = 'JOBNET='jobnet_name||,

                    ',RELOPR=#S'||,

                    ',MAINT='maint_id||,

                    ','restart_id

   End

   Else Do

     addline.acnt = 'JOBNET='jobnet_name||,

                    ',CONDCODE='cond_code||,

                    ',RELOPR='rel_oper||,

                    ',MAINT='maint_id||,

                    ','restart_id

   End



   If #type1 <> "" Then Do

     addline.acnt = addline.acnt","

     acnt = acnt + 1

     addline.acnt = #line

   End

   Return



unixjob:

   linenum2 = linenum + 1

   Do Until Substr(in.linenum2,9,9) = '---------'

     If Pos('Job Type:',in.linenum2) > 0 Then Do

       jobtype = Strip(SubStr(in.linenum2,19,10))

     End

     If Pos('Agent: ',in.linenum2) > 0 Then Do

       agentid = Strip(SubStr(in.linenum2,17,40))

     End

     linenum2 = linenum2 + 1

     If Pos('Userid:',in.linenum2) > 0 Then Return

   End

   Return



Add_UNIX_Job:      /* got all the ADD variables - so ADD unix job */

   acnt = acnt + 1

   addline.acnt = 'DBM'

   acnt = acnt + 1

   addline.acnt = 'AGJOB'

   acnt = acnt + 1

   addline.acnt = 'ADD,'job1',SYSTEM='system',USERID='uid',AGJOBTYP='jobtype','

   acnt = acnt + 1

   addline.acnt = 'AGENT='agentid',PRMLIB='prmlib',EXEC='exec_id||,

                ',PRTY='prty

   /* extra lines below to reset back to normal job add's */

   acnt = acnt + 1

   addline.acnt = 'DBM'

   acnt = acnt + 1

   addline.acnt = 'JOB'

   Return



schedules:

   type = ' '

   cal_schid = ' '

   dowline = ' '

   new_id_found = n

   linenum1 = linenum

   linenum2 = linenum + 1

   Do Until Substr(in.linenum2,9,9) = '---------'

     If Pos('LIST=ALL',in.linenum) > 0 |,

        Pos('LIST=NODD',in.linenum) > 0 |,

        Pos('---JCL---',in.linenum) > 0 |,

        Pos('STP DDS RUNS',in.linenum) > 0 Then Iterate

     linenum1 = linenum1+1

     If Pos('LAST RESOLV',in.linenum1) > 0 Then Iterate

     linenum2 = linenum1+1

     If Pos('SLIA',in.linenum1) > 0 Then Return

     If Substr(in.linenum1,26,8) = "CALENDAR" Then Do

       cal_start = 'Y'

       scal = Right(Word(in.linenum1,2),2)

       cal_year = Substr(Word(in.linenum1,2),5,2)

       ccnt = ccnt + 1

       cal_oline.ccnt = "SCHD"

       ccnt = ccnt + 1

       cal_oline.ccnt = "JOB"

       ccnt = ccnt + 1

       cal_oline.ccnt = "EDIT"

       Iterate

     End

     If Substr(in.linenum1,8,4) = " ID=" Then Do

       cal_schid  = Substr(in.linenum1,12,3)

       roll_opt   = Substr(in.linenum1,23,1)

       index_opt  = Substr(in.linenum1,32,4)

       dowline = ' '

       Iterate

     End

     If Substr(in.linenum1,8,6) = " SCAL=" Then Do

       dotm_pos   = Pos('DOTM=',in.linenum1) + 5

       cal_dotm   = Substr(in.linenum1,dotm_pos,4)

       leadtm_pos = Pos('LEADTM=',in.linenum1) + 7

       cal_leadtm = Substr(in.linenum1,leadtm_pos,4)

       subtm_pos  = Pos('SUBTM=',in.linenum1) + 6

       cal_subtm  = Substr(in.linenum1,subtm_pos,4)

       start_pos  = Pos('STARTM=',in.linenum1) + 7

       cal_start  = Substr(in.linenum1,start_pos,4)

       If subtm_pos = 6 Then time_line = "TIME=("cal_dotm","cal_leadtm")"

       Else time_line = "TIME=("cal_dotm","cal_leadtm","cal_subtm")"

       Iterate

     End

     If Substr(in.linenum1,8,7) = " REPEAT" Then Do

       repeat_found = y

       /*Say "       Repetative job found - building variables"*/

       repeat_temp = Translate(in.linenum1,' ','=')

       Rinterval = Word(repeat_temp,3)

       Rtype     = Word(repeat_temp,5)

       Rcount    = Word(repeat_temp,7)

       Rstop     = Word(repeat_temp,9)

       repeat_line = "INTERVAL="Rinterval",TYPE="Rtype",COUNT="Rcount",STOP="||,

                     Rstop","

       Iterate

     End



     ccnt = ccnt + 1

     cal_oline.ccnt = "ADD,SCHID="cal_schid","||,

                      "ROLL="roll_opt","||,

                      "INDEX="index_opt","||,

                       time_line","

     If repeat_found = y Then Do

       ccnt = ccnt + 1

       cal_oline.ccnt =  repeat_line

       repeat_found = n

       repeat_line = " "

     End

                      /*"SCAL="scal","||,*/

     new_id_found = y



     linenum3 = linenum1

     Do Until Substr(in.linenum3,8,4) = " ID="

       If Substr(in.linenum3,9,9) = '---------' |,

          Pos(' REQUEST COMPLETED ',in.linenum3) > 0 Then,

             Signal ReBuild_All_Variables

       If Substr(in.linenum3,9,9) = '---------' |,

          Pos(' REQUEST COMPLETED ',in.linenum3) > 0 Then Return

       linenum3 = linenum3 + 1

       If Pos('SLIA',in.linenum1) > 0 Then Leave

       If Pos('LIST=ALL',in.linenum1) > 0 |,

          Pos('LIST=NODD',in.linenum1) > 0 |,

          Pos('---JCL---',in.linenum1) > 0 |,

          Pos('STP DDS RUNS',in.linenum1) > 0 Then Do

           linenum1 = linenum1 + 1

           Iterate

       End

       prev_type = type

       type = Word(in.linenum1,1)

       If type = 'DAILY'  Then Do

         ccnt = ccnt + 1

         cal_oline.ccnt = "DAILY=Y,"

       End

       If type = 'WEEKLY' Then Do

         day_pos = Pos(' DAY=',in.linenum1) + 5

         days = Strip(Substr(in.linenum1,day_pos,40))

         days = Translate(days,' ',',')

         day_words  = Words(days)

         If Pos('SUN',days) > 0 then day1 = 'X,'

         Else day1 = ','

         If Pos('MON',days) > 0 then day2 = 'X,'

         Else day2 = ','

         If Pos('TUE',days) > 0 then day3 = 'X,'

         Else day3 = ','

         If Pos('WED',days) > 0 then day4 = 'X,'

         Else day4 = ','

         If Pos('THU',days) > 0 then day5 = 'X,'

         Else day5 = ','

         If Pos('FRI',days) > 0 then day6 = 'X,'

         Else day6 = ','

         If Pos('SAT',days) > 0 then day7 = 'X'

         Else day7 = ','

         day_list = "DAYS=("day1||day2||day3||day4||day5||day6||day7")"

         wcnt = wcnt + 1

         ccnt = ccnt + 1

         cal_oline.ccnt = "WEEKLY=Y,"day_list","

       End

       If type = 'MONTHLY' Then Do

         /*trace i*/

         if cal_schid = '110' then NOP

         day_pos   = Pos(' DAY=',in.linenum1)   + 5

         rday_pos  = Pos(' RDAY=',in.linenum1)  + 6

         nday_pos  = Pos(' NDAY=',in.linenum1)  + 6

         nrday_pos = Pos(' NRDAY=',in.linenum1) + 7

         week_pos  = Pos(' WEEK=',in.linenum1)  + 6

         month_pos = Pos(' MONTH=',in.linenum1) + 7



         If day_pos > 5 then Do

           dow = Substr(in.linenum1,day_pos,40)

           blank_pos = Pos(' ',dow)

           dow = Strip(Substr(dow,1,blank_pos))

           If Pos(dow,dowline) = 0 then Do

             dowcnt = dowcnt + 1

             dow_line.dowcnt = dow

           End

           dowline = dowline dow

         End

         If nday_pos > 6 then Do

           dow = Substr(in.linenum1,nday_pos,40)

           blank_pos = Pos(' ',dow)

           dow = Strip(Substr(dow,1,blank_pos))

           If Pos(dow,dowline) = 0 then Do

             dowcnt = dowcnt + 1

             dow_line.dowcnt = dow

           End

           dowline = dowline dow

         End

         If week_pos > 6 then Do

           week = Substr(in.linenum1,week_pos,40)

           blank_pos = Pos(' ',week)

           week = Strip(Substr(week,1,blank_pos))

           week = Strip(week,L,0)

           w1cnt = w1cnt + 1

           week_line.w1cnt = "/"week

           If day_pos > 5 then week_line.w1cnt = week

         End

         If nday_pos > 6 then Do

           nday_found = y

           nday = Substr(in.linenum1,nday_pos,40)

           blank_pos = Pos(' ',nday)

           nday = Strip(Substr(nday,1,blank_pos))

           ndaycnt = ndaycnt + 1

           nday_line.ndaycnt = "/"nday

         End

         If rday_pos > 6 then Do

           rday_found = y

           rday = Strip(Substr(in.linenum1,rday_pos,3))

           rdaycnt = rdaycnt + 1

           rday_line.rdaycnt = rday

         End

         If nrday_pos > 7 then Do

           If Pos('NRDAY=08',in.linenum1) > 0 then NOP

           nrday_found = y

           nrday = Substr(in.linenum1,nrday_pos,40)

           blank_pos = Pos(' ',nrday)

           nrday = Strip(Substr(nrday,1,blank_pos))

           nrdaycnt = nrdaycnt + 1

           nrday_line.nrdaycnt = "/"nrday

         End

         months = Strip(Substr(in.linenum1,month_pos,40))

         months = Translate(months,' ',',')

         month_words = Words(months)

         month_found = y

         If Pos('JAN',months) > 0 | WordPos('1',months) > 0 then m1 = 'X'

         Else m1 = ''

         If Pos('FEB',months) > 0 | WordPos('2',months) > 0 then m2 = 'X'

         Else m2 = ''

         If Pos('MAR',months) > 0 | WordPos('3',months) > 0 then m3 = 'X'

         Else m3 = ''

         If Pos('APR',months) > 0 | WordPos('4',months) > 0 then m4 = 'X'

         Else m4 = ''

         If Pos('MAY',months) > 0 | WordPos('5',months) > 0 then m5 = 'X'

         Else m5 = ''

         If Pos('JUN',months) > 0 | WordPos('6',months) > 0 then m6 = 'X'

         Else m6 = ''

         If Pos('JUL',months) > 0 | WordPos('7',months) > 0 then m7 = 'X'

         Else m7 = ''

         If Pos('AUG',months) > 0 | WordPos('8',months) > 0 then m8 = 'X'

         Else m8 = ''

         If Pos('SEP',months) > 0 | WordPos('9',months) > 0 then m9 = 'X'

         Else m9 = ''

         If Pos('OCT',months) > 0 | WordPos('10',months) > 0 then m10 = 'X'

         Else m10= ''

         If Pos('NOV',months) > 0 | WordPos('11',months) > 0 then m11 = 'X'

         Else m11= ''

         If Pos('DEC',months) > 0 | WordPos('12',months) > 0 then m12 = 'X'

         Else m12= ''

         If Pos('ALL',months) > 0 then Do

           month_list = ""

           month_list = "MONTHS=(X,X,X,X,X,X,X,X,X,X,X,X),"

         End

         Else Do

           month_list = "MONTHS=("m1","m2","m3","m4","m5","m6","||,

                                  m7","m8","m9","m10","m11","m12"),"

         End

         If month_found = y then Do

           If new_id_found = y then Do

             ccnt = ccnt + 1

             cal_oline.ccnt = "MONTHLY=Y,"||month_list

             new_id_found = n

           End

           month_found = n

         End

       End

       If type = 'ANNUAL'  Then Do

         day_pos   = Pos(' DAY=',in.linenum1)   + 5

         nday_pos  = Pos(' NDAY=',in.linenum1)  + 6



         If day_pos > 6 then Do

           annday = Substr(in.linenum1,day_pos,40)

           blank_pos = Pos(' ',annday)

           annday = Strip(Substr(annday,1,blank_pos))

           a1cnt = a1cnt + 1

           annual_line.a1cnt = annday

         End

         If nday_pos > 6 then Do

           annday = Substr(in.linenum1,nday_pos,40)

           blank_pos = Pos(' ',annday)

           annday = Strip(Substr(annday,1,blank_pos))

           a1cnt = a1cnt + 1

           annual_line.a1cnt = "/"annday

         End

         ccnt = ccnt + 1

         cal_oline.ccnt = "ANNUAL=Y,"

       End

       linenum1 = linenum1 + 1

     End



     /* next ID found */

     month_found = n

     If dowcnt > 0 then Do

       NOP

       Do s1 = 1 to dowcnt

         ccnt = ccnt + 1

         cal_oline.ccnt = "DOW="dow_line.s1","

       End

     End

     If rdaycnt > 0 then Do

       Do s2 = 1 to rdaycnt

         If s2 = 1 then Do

           new_rday_line = "RDAYS="rday_line.s2

           If rdaycnt = 1 then Do

             ccnt = ccnt + 1

             cal_oline.ccnt = new_rday_line","

             Leave s2

           End

           Iterate s2

         End

         new_rday_line = new_rday_line rday_line.s2

         If s2 = rdaycnt then Do

           ccnt = ccnt + 1

           cal_oline.ccnt = new_rday_line","

         End

       End

     End

     If w1cnt > 0 then Do

       Do s3 = 1 to w1cnt

         If s3 = 1 then Do

           new_nday_line = "WEEKS="week_line.s3

           If w1cnt = 1 then Do

             ccnt = ccnt + 1

             cal_oline.ccnt = new_nday_line","

             Leave s3

           End

           Iterate s3

         End

         new_nday_line = new_nday_line week_line.s3

         If s3 = w1cnt then Do

           ccnt = ccnt + 1

           cal_oline.ccnt = new_nday_line","

         End

       End

     End

     If nrdaycnt > 0 then Do

       Do s4 = 1 to nrdaycnt

         If s4 = 1 then Do

           new_nrday_line = "RDAYS="nrday_line.s4

           If nrdaycnt = 1 then Do

             ccnt = ccnt + 1

             cal_oline.ccnt = new_nrday_line","

             Leave s4

           End

           Iterate s4

         End

         new_nrday_line = new_nrday_line nrday_line.s4

         If s4 = nrdaycnt then Do

           ccnt = ccnt + 1

           cal_oline.ccnt = new_nrday_line","

         End

       End

     End

     If a1cnt > 0 then Do

       Do s5 = 1 to a1cnt

         If s5 = 1 then Do

           new_annual_line = "ANNDAYS="annual_line.s5

           If a1cnt = 1 then Do

             ccnt = ccnt + 1

             cal_oline.ccnt = new_annual_line","

             Leave s5

           End

           Iterate s5

         End

         new_annual_line = new_annual_line annual_line.s5

         If s5 = s1cnt then Do

           ccnt = ccnt + 1

           cal_oline.ccnt = new_annual_line","

         End

       End

     End



     dowcnt = 0

     wcnt = 0

     w1cnt = 0

     rdaycnt = 0

     ndaycnt = 0

     nrdaycnt = 0



     cal_oline.ccnt = Substr(cal_oline.ccnt,1,(Length(cal_oline.ccnt)-1))



     linenum1 = linenum1 - 1

   End



   Return



ReBuild_All_Variables:

   /* next ID found */

   month_found = n

   If dowcnt > 0 then Do

     NOP

     Do s1 = 1 to dowcnt

       ccnt = ccnt + 1

       cal_oline.ccnt = "DOW="dow_line.s1","

     End

   End

   If rdaycnt > 0 then Do

     Do s2 = 1 to rdaycnt

       If s2 = 1 then Do

         new_rday_line = "RDAYS="rday_line.s2

         If rdaycnt = 1 then Do

           ccnt = ccnt + 1

           cal_oline.ccnt = new_rday_line","

           Leave s2

         End

         Iterate s2

       End

       new_rday_line = new_rday_line rday_line.s2

       If s2 = rdaycnt then Do

         ccnt = ccnt + 1

         cal_oline.ccnt = new_rday_line","

       End

     End

   End

   If w1cnt > 0 then Do

     Do s3 = 1 to w1cnt

       If s3 = 1 then Do

         new_nday_line = "WEEKS="week_line.s3

         If w1cnt = 1 then Do

           ccnt = ccnt + 1

           cal_oline.ccnt = new_nday_line","

           Leave s3

         End

         Iterate s3

       End

       new_nday_line = new_nday_line week_line.s3

       If s3 = w1cnt then Do

         ccnt = ccnt + 1

         cal_oline.ccnt = new_nday_line","

       End

     End

   End

   If nrdaycnt > 0 then Do

     Do s4 = 1 to nrdaycnt

       If s4 = 1 then Do

         new_nrday_line = "RDAYS="nrday_line.s4

         If nrdaycnt = 1 then Do

           ccnt = ccnt + 1

           cal_oline.ccnt = new_nrday_line","

           Leave s4

         End

         Iterate s4

       End

       new_nrday_line = new_nrday_line nrday_line.s4

       If s4 = nrdaycnt then Do

         ccnt = ccnt + 1

         cal_oline.ccnt = new_nrday_line","

       End

     End

   End



   dowcnt = 0

   wcnt = 0

   w1cnt = 0

   rdaycnt = 0

   ndaycnt = 0

   nrdaycnt = 0



   cal_oline.ccnt = Substr(cal_oline.ccnt,1,(Length(cal_oline.ccnt)-1))



   /* build resolve statements */

       ccnt = ccnt + 1

       cal_oline.ccnt = "SAVE"

       ccnt = ccnt + 1

       cal_oline.ccnt = "SAVE,JOB="job1",SCAL="scal

       ccnt = ccnt + 1

       cal_oline.ccnt = "DBM"

       ccnt = ccnt + 1

       cal_oline.ccnt = "RESOLV,SCAL="scal",TEST=NO,JOB="job1",OLDYR=*,"||,

                        "YEAR="cal_year",PRINT=YES"



   linenum1 = linenum1 - 1



   /* last line found and about to leave the SCHDEDULES section */

   Return 0



triggerby:

   linenum1 = linenum

   linenum2 = linenum + 1

   linenum3 = linenum + 1

   Do Until Substr(in.linenum2,9,9) = '---------'

     If Pos('LIST=ALL',in.linenum) > 0 |,

        Pos('LIST=NODD',in.linenum) > 0 |,

        Pos('---JCL---',in.linenum) > 0 |,

        Pos('STP DDS RUNS',in.linenum) > 0 then iterate

     linenum1 = linenum1+1

     linenum2 = linenum2+1

     If Pos('SLIA',in.linenum1) > 0 Then Return

     If Substr(in.linenum1,12,4) = "JOB=" Then Do

       trigid   = '999' ; subtime  = '9999'

       trgjob1     = Strip(Substr(in.linenum1,16,8))

       schid_pos   = Pos(" SCHID=",in.linenum1) + 7

       blank_pos   = Pos(" ",in.linenum1,schid_pos)

       schids      = Substr(in.linenum1,schid_pos,(blank_pos-schid_pos))

       schid_list  = Translate(schids," ","/")

       schid_words =  Words(schid_list)

       If schid_words = 1 then schid = schid_list

       Else Do

         schid = Word(schid_list,1)

         trigid = Word(schid_list,2)

       End

       qtime     = Strip(Substr(in.linenum1,44,4))

       ldtime    = Strip(Substr(in.linenum1,56,4))

       subtime   = Strip(Substr(in.linenum1,68,4))

       test_trig = trgjob1'->'job1'->'schid

       If Pos(test_trig,trig_done_list) > 0 then Iterate

       trig_done_list = trig_done_list' 'trgjob1'->'job1'->'schids

       tbjcnt = tbjcnt + 1

       tbjline.tbjcnt = "UPD,JTRG,JOB="trgjob1",OPT=A,TJOB="job1||,

                        ",QTM="qtime",LEADTM="ldtime","

       tbjcnt = tbjcnt + 1

       tbjline.tbjcnt = "SCHID="schid

       If trigid /= '999' then tbjline.tbjcnt = tbjline.tbjcnt",TRGID="trigid

       If subtime /= '9999' & subtime /= '0000' then,

          tbjline.tbjcnt = tbjline.tbjcnt",SBTM="subtime

     End

     If Substr(in.linenum1,12,4) = "DSN=" Then Do

       gdg_req = 'Y'

       tran_dsn_line = Translate(in.linenum1,' ','(')

       tran_dsn_line = Translate(tran_dsn_line,' ',')')

       trgdsn1       = Word(tran_dsn_line,2)

       If Words(tran_dsn_line) = 3 Then Do

         gdg_req = 'N'

         trgdsn1 = trgdsn1'('Word(tran_dsn_line,3)')'

       End

       tlinenum1     = linenum1 + 1



       /* ken 2013-02-06 15:45 start */

       dschid_pos   = Pos(" SCHID=",in.tlinenum1) + 7

       dblank_pos   = Pos(" ",in.tlinenum1,dschid_pos)

       dschids      = Substr(in.tlinenum1,dschid_pos,(dblank_pos-dschid_pos))

       dschid_list  = Translate(dschids," ","/")

       dschid_words =  Words(dschid_list)

       If dschid_words = 1 then Do

         dschid = dschid_list

         dtrgExtra = ",SCHID="dschid

       End

       If dschid_words > 1 then Do

         dschid  = Word(dschid_list,1)

         dtrigid = Word(dschid_list,2)

         dtrgExtra = ",SCHID="dschid",TRGID="dtrigid

       End

       /* ken 2013-02-06 15:45 end   */



       /* ken 2013-02-06 15:45 start */

       If Pos("SIGNET.",trgdsn1) > 0 Then gdg_req = "N"

       /* ken 2013-02-06 15:45 end   */



       qtime         = Strip(Substr(in.tlinenum1,44,4))

       adsncnt = adsncnt + 1

       adsnline.adsncnt = "ADD,DSN="trgdsn1",TYPE=NORM,SMF=Y,GDG="gdg_req

       tbdcnt = tbdcnt + 1

       tbdline.tbdcnt = "UPD,DTRG,DSN="trgdsn1",OPT=A,"

       tbdcnt = tbdcnt + 1

       tbdline.tbdcnt = "TJOB="job1",QTM="qtime



       /* ken 2013-02-06 15:45 start */

       tbdline.tbdcnt = tbdline.tbdcnt||dtrgExtra

       /* ken 2013-02-06 15:45 end   */



       If Substr(in.linenum3,9,9) = '---------' then Return

     End

   End

   Return



trigger:

   linenum1 = linenum

   linenum2 = linenum + 1

   Do Until Substr(in.linenum2,9,9) = '---------'

     If Pos('LIST=ALL',in.linenum) > 0 |,

        Pos('LIST=NODD',in.linenum) > 0 |,

        Pos('---JCL---',in.linenum) > 0 |,

        Pos('STP DDS RUNS',in.linenum) > 0 then iterate

     linenum1 = linenum1+1

     linenum2 = linenum2+1

     If Pos('SLIA',in.linenum1) > 0 Then Return

     If Substr(in.linenum1,12,4) = "JOB=" Then Do

       trigid   = '999' ; subtime  = '9999'

       trgjob1 = Strip(Substr(in.linenum1,16,8))

       schid_pos   = Pos(" SCHID=",in.linenum1) + 7

       blank_pos   = Pos(" ",in.linenum1,schid_pos)

       schids      = Substr(in.linenum1,schid_pos,(blank_pos-schid_pos))

       schid_list  = Translate(schids," ","/")

       schid_words =  Words(schid_list)

       If schid_words = 1 then schid = schid_list

       Else Do

         schid = Word(schid_list,1)

         trigid = Word(schid_list,2)

       End

       qtime     = Strip(Substr(in.linenum1,44,4))

       ldtime    = Strip(Substr(in.linenum1,56,4))

       subtime   = Strip(Substr(in.linenum1,68,4))

       test_trig = job1'->'trgjob1'->'schid

       If Pos(test_trig,trig_done_list) > 0 then Iterate

       trig_done_list = trig_done_list' 'job1'->'trgjob1'->'schids

       tcnt = tcnt + 1

       trigline.tcnt = "UPD,JTRG,JOB="job1",OPT=A,TJOB="trgjob1||,

                       ",QTM="qtime",LEADTM="ldtime","

       /* ken test     ",QTM=0010,LEADTM=0010,"     */

       tcnt = tcnt + 1

       trigline.tcnt = "SCHID="schid

       If trigid /= '999' then trigline.tcnt = trigline.tcnt",TRGID="trigid

       If subtime /= '9999' & subtime /= '0000' then,

          trigline.tcnt = trigline.tcnt",SBTM="subtime

     End

   End

   Return



success:

   linenum1 = linenum

   linenum2 = linenum + 1

   Do Until Substr(in.linenum2,9,9) = '---------'

     linenum1 = linenum1+1

     linenum2 = linenum2+1

     If Pos('SLIA',in.linenum1) > 0 Then Return

     If Substr(in.linenum1,12,4) = 'JOB=' Then Do

       sucjob1 = Strip(Substr(in.linenum1,16,9))

       schid   = Strip(Substr(in.linenum1,31,5))

       If Substr(sucjob1,1,1) = '/' Then Do

         sucjob1a    = Translate(sucjob1,' ','/')

         neg_dep_job = Translate(job1,' ','/')

         neg_dep_job = Strip(neg_dep_job)

         neg_list = sucjob1a'/'neg_dep_job

         If Pos(neg_list,neg_dep_list) = 0 then Do

           neg_dep_list = neg_dep_list' 'sucjob1a'/'neg_dep_job

         End

       End

       Else Do

         ldtime2 = ''

         Call Extract_From_Ca72 node "LJOB,LIST=RQJOB,JOB="sucjob1

         Do sx = 1 to list2.0

           Parse Pull InLine2

           If SubStr(InLine2,9,12) = "JOB="job1 Then Do

             ldtime2 = Word(InLine2,4)

             ldtime2_hh = Strip(SubStr(ldtime2,8,4))

             If ldtime2_hh = "" Then ldtime2_hh = "00"

             /*If Length(ldtime2_hh) < 4 Then ldtime2 = Right(ldtime2_hh,4,'0')*
/
             If ldtime2_hh = "00" then ldtime2 = ""

             Else ldtime2 = ",LEADTM="ldtime2_hh

             Address TSO "delstack"

             Leave sx

           End

         End

         scnt = scnt + 1

         sline.scnt = "UPD,JOB,"sucjob1",OPT=A,PRED="job1||ldtime2

         If schid = '000' then Iterate

         sline.scnt = sline.scnt',SCHID='schid

       End

     End

   End

   Return



vrm:

   linenum1 = linenum

   linenum2 = linenum + 1

   Do Until Substr(in.linenum2,9,9) = '---------'

     If Pos('LIST=ALL',in.linenum) > 0 |,

        Pos('LIST=NODD',in.linenum) > 0 |,

        Pos('---JCL---',in.linenum) > 0 |,

        Pos('STP DDS RUNS',in.linenum) > 0 then iterate

     linenum1 = linenum1+1

     linenum2 = linenum2+1

     If Pos('SLIA',in.linenum1) > 0 Then Return

     vrm_type = Substr(in.linenum1,9,3)

     If WordPos(vrm_type,vrm_list) > 0 Then Do

       vrm_name = Strip(Substr(in.linenum1,13,40))

       schid    = Strip(Substr(in.linenum2,35,5))

       free_id  = Substr(in.linenum2,46,1)

       test_vrm = job1'->'vrm_type'->'vrm_name'->'schid

       If Pos(test_vrm,vrm_done_list) > 0 then Iterate

       vrm_done_list = vrm_done_list' 'job1'->'vrm_type'->'vrm_name'->'schid

       vcnt = vcnt + 1

       vrmline.vcnt = "UPD,RM.1,JOB="job1",OPT=A"||,

                      ",TYPE="vrm_type",FREE="free_id",SCHID="schid","

       vcnt = vcnt + 1

       vrmline.vcnt = "RSRC="vrm_name

     End

   End

   Return



reqjobs:

   linenum1 = linenum

   Do Until Pos('SLIA',in.linenum1) > 0

     linenum1 = linenum1 + 1

     If Substr(in.linenum1,2,Length(job_prefix)) = job_prefix Then Return 0

     If Substr(in.linenum1,9,4) = 'JOB=' &,

        Pos('SCHID',in.linenum1) > 0 Then Do

       req_words = Words(in.linenum1)

       If req_words = 4 then ldtime = ','Word(in.linenum1,4)

       Else ldtime = ''

       reqjob1 = Strip(Substr(in.linenum1,13,9))

       schid   = Strip(Substr(in.linenum1,35,5))

       If Substr(reqjob1,1,1) = '/' Then Do

         job1a       = Translate(job1,' ','/')

         neg_dep_job = Translate(reqjob1,' ','/')

         neg_dep_job = Strip(neg_dep_job)

         neg_list = job1a'/'neg_dep_job

         If Pos(neg_list,neg_dep_list) = 0 then Do

           neg_dep_list = neg_dep_list' 'job1a'/'neg_dep_job

         End

       End

       Else Do

         rcnt = rcnt + 1

         rline.rcnt = "UPD,JOB,"job1",OPT=A,PRED="reqjob1||ldtime

         If schid = '000' then Iterate

         rline.rcnt = rline.rcnt',SCHID='schid

       End

     End

     If Substr(in.linenum1,9,4) = 'USR=' then Do

       nxlinenum = linenum1 + 1

       If Left(in.nxlinenum,6) = '1LJOB,' Then nxlinenum = nxlinenum + 6

       user_req = Strip(Substr(in.linenum1,13,59))

       schid    = Strip(Substr(in.nxlinenum,35,5))

       If Strip(SubStr(in.linenum1,72,7)) = "(ONLY)" Then nxrun = "ONLY"

       Else nxrun = "YES"

       ucnt = ucnt + 1

       usrline.ucnt = "UPD,USR,"job1",OPT=C,USR="user_req","

       If Length(usrline.ucnt) < 55 | Length(usrline.ucnt) = 55 Then Do

         usrline.ucnt = usrline.ucnt||"NEXTRUN="nxrun

       End

       Else Do

         ucnt = ucnt + 1

         usrline.ucnt = "NEXTRUN="nxrun

       End

       If schid = '000' then Iterate

       usrline.ucnt = usrline.ucnt','

       ucnt = ucnt + 1

       usrline.ucnt = "SCHID="schid

     End

   End

   Return



negjobs:

   Do n = 1 to Words(neg_dep_list)

     jobs = Word(neg_dep_list,n)

     jobs = Translate(jobs,' ','/')

     negjob1 = Word(jobs,1)

     negjob2 = Word(jobs,2)

     neg_check1 = negjob1'/'negjob2

     neg_check2 = negjob2'/'negjob1

     If Pos(neg_check1,neg_done_list) > 0 |,

        Pos(neg_check2,neg_done_list) > 0 then Iterate n

     ncnt = ncnt + 1

     nline.ncnt = "UPD,JOB,"negjob1",OPT=A,PRED=/"negjob2

     ncnt = ncnt + 1

     nline.ncnt = "UPD,JOB,"negjob2",OPT=A,PRED=/"negjob1

     neg_done_list = neg_done_list neg_check1 neg_check2

   End

   Return



Extract_From_CA72:

   Parse UPPER Arg node command



Execute_CA72:

   rslt = cal2x2wa()

   Select

     When Right(node,2) = "D2" Then Do

       ca7_node = "CCIIND2"

       ca7_ssct = "CA71"

       uid_pass = "UCC701,U7SVC01}"

     End

     When Right(node,2) = "P2" Then Do

       ca7_node = "CCIINP2"

       ca7_ssct = "CA71"

       uid_pass = "UCC701,U7SVC01}"

     End

     OtherWise NOP

   End



   ca7_debug = "N}  "



   Address CA7 "/LOGON  "uid_pass||Command



Queue_Results2:

   Drop LIST2.

   LIST2.0 = Queued()



   Return



MEMBER NAME   CHCKDTA4
/*==================================   REXX  ==================================*
/
/*     Name          -   CHCKDTA4                                              *
/
/*     Author        -   David Jones                                           *
/
/*     Written       -   30th June 2011                                        *
/
/*     Environment   -   Batch                                                 *
/
/*     Version       -   1.0                                                   *
/
/*     Modified by   -                                                         *
/
/*     Modified Date -                                                         *
/
/*     Function      -   To identify if dsn is a null file by returning RC=04  *
/
/*     Parm          -   None                                                  *
/
/*==================================   REXX  ==================================*
/
Say 'CHCKDTA4 - Version 1.0 30/06/2011'

   "EXECIO 3 DISKR INFILE (STEM REC. FINIS"



   IF REC.0 <= 2 THEN

DO

   say '##########################################################'

   say '#                                                        #'

   say '#  Input file is empty or only contains header/trailer   #'

   say '#                                                        #'

   say '##########################################################'

      exit 4

      END

   ELSE

      exit 0

MEMBER NAME   CHECKDT1
/*=============================   REXX  ==============================*/

/*                                                                    */

/*     NAME          -   CHECKDT1                                     */

/*     AUTHOR        -   MARK ROUNCE                                  */

/*     WRITTEN       -   27TH APRIL 2004                              */

/*     ENVIRON       -   Batch                                        */

/*     VERSION       -   1                                            */

/*     MODIFIED BY   -                                                */

/*     MODIFIED DATE -                                                */

/*     FUNCTION      -   TO IDENTIFY IF DSN IS 1 OR LESS RECORDS      */

/*     PARM          -   None                                         */

/*                                                                    */

/*===================================================================*/

   "EXECIO * DISKR INFILE (STEM REC. FINIS"



   IF REC.0 <= 1 THEN

DO

   say '##########################################################'

   say '#                                                        #'

   say '#    file contains no data transmission not triggered    #'

   say '#                                                        #'

   say '##########################################################'

      exit 1

      END

   ELSE

      exit 0

MEMBER NAME   CHECKDT4
/*=============================   REXX  ==============================*/

/*                                                                    */

/*     NAME          -   CHECKDT4                                     */

/*     AUTHOR        -   MARK ROUNCE                                  */

/*     WRITTEN       -   14TH JAN 2004                                */

/*     ENVIRON       -   Batch                                        */

/*     VERSION       -   1                                            */

/*     MODIFIED BY   -                                                */

/*     MODIFIED DATE -                                                */

/*     FUNCTION      -   TO IDENTIFY IF DSN IS 5 OR LESS RECORDS      */

/*     PARM          -   None                                         */

/*                                                                    */

/*===================================================================*/

   "EXECIO * DISKR INFILE (STEM REC. FINIS"



   IF REC.0 <= 5 THEN

DO

   say '##########################################################'

   say '#                                                        #'

   say '#    file contains no data transmission not triggered    #'

   say '#                                                        #'

   say '##########################################################'

      exit 1

      END

   ELSE

      exit 0

MEMBER NAME   FALCOUNT
Parse SOURCE . . exec_name .

ver = "0.1"

Say

Say "Starting "exec_name" version "ver" on "Date(W) Date()" at "Time()

Say

parse arg count



If datatype(count) <> 'NUM' Then

   Do

     say

     say '     Error:'

     say '     Non numeric parm passed to exec'

     say

     exit 4

   End



If words(count) <> 1 Then

   Do

     say

     say '     Error:'

     say '     incorrect amount of parms passed to exec there should only '

     say '     be 1 parm passed. This should be the number of records that '

     say '     contistute the file being null.'

     say

     exit 4

   End





"Execio 4 Diskr INPUT (stem REC. finis"



   If REC.0 <= count Then

Do

   say '    count does not meet criteria transmission not triggered'

   Say

   Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at "Time()

   Say

    exit 1

End

   ELSE

     say '    count meets criteria transmission triggered'

     Say

     Say

     Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at "Time()

     Say

     Exit 0

MEMBER NAME   GREG2JUL
/*=============================   REXX  ==============================*/

/*                                                                    */

/*     NAME          -   GREG2JUL                                     */

/*     AUTHOR        -   Stuart Dolman                                */

/*     WRITTEN       -   21st July 1996                               */

/*     ENVIRON       -   Called by REXX SWNDMUP1                      */

/*     VERSION       -   1                                            */

/*     MODIFIED BY   -   Stuart Dolman                                */

/*     MODIFIED DATE -   1st March 2000                               */

/*     FUNCTION      -   To convert gregorian date to julian          */

/*                                                                    */

/*===================================================================*/



arg day month year



if month = '01' then tot = day



if month = '02' then tot = day + 31



if month = '03' then tot = day + 59



if month = '04' then tot = day + 90



if month = '05' then tot = day + 120



if month = '06' then tot = day + 151



if month = '07' then tot = day + 181



if month = '08' then tot = day + 212



if month = '09' then tot = day + 243



if month = '10' then tot = day + 273



if month = '11' then tot = day + 304



if month = '12' then tot = day + 334



if tot > 59 & month > 2 then rem = year//4



if rem = 0 then tot = tot + 1



tot = right(tot,3,'0')



b = year||tot



return b

MEMBER NAME   LRUNTASK
/* rexx */

clear

Initialise_Version:

   ver = "0.1"



Issue_Message:

   Say

   Say "Starting LRUNTASK version "ver" on "Date(W) Date()" at "Time()

   Say



Get_DataSetNames_From_Invoking_Jcl:

   x = Listdsi(INPUT FILE)

   InDsn = SysDsname



   x = Listdsi(CURRGEN FILE)

   CurrGen =  SysDsname



If_Error:

   If Right(CurrGen,3) <> "V00" Then Do

     Say "  Error in supplied file name "CurrGen

     Exit 12

   End



Initialise_Variables:

   GV00 = SubStr(CurrGen,(Length(CurrGen)-7),8)



   old_gen_num = SubStr(GV00,2,4)

   new_gen_num = old_gen_num + 1

   new_gen_num = Right(new_gen_num,4,'0')



   next_gen = "G"new_gen_num"V00"



   OutDsn = SubStr(CurrGen,1,(Length(CurrGen)-9))"."next_gen



   "Rename '"InDsn"' '"OutDsn"'"

   If rc <> 0 Then Do

     Say "  Return Code " rc " from Rename"

     Exit rc

   End

   Else Do

     Say "  Rename successfull "

     Say "    Original file name       "InDsn

     Say "    Renamed file name        "OutDsn

   End



Exit:

   Say

   Say "Ending   LRUNTASK version "ver" on "Date(W) Date()" at "Time()

   Say

   Exit 0

MEMBER NAME   PFILREXX
/* Rexx */

/*                                                                             *
/
/* Function:                                                                   *
/
/* Determine FILENAME, SNODE or IP ADDRESS, and pass details to Integrity      *
/
/* check program DZD040.                                                       *
/
/* Abend if any issues encountered.                                            *
/
/*                                                                             *
/
/* Key Steps:                                                                  *
/
/* Establish if Connect Direct, FTP or SFTP is being used, and invoke          *
/
/* specific check routines accordingly.                                        *
/
/*                                                                             *
/
/* Common Checks                                                               *
/
/* Check if ´non gdg´ file is being checked - continue but hilight issue       *
/
/*                                                                             *
/
/* Connect Direct (CD) Process - specific checks                               *
/
/* Interogate CDIRECT.PARMS (member passsed from jcl) to find CD Process Name  *
/
/* Interogate CDIRECT.BASE (Process Name) to find SNODE name and SEND type     *
/
/* Interogate CDIRECT.PARMS (member passsed from jcl) to find File Name        *
/
/* Check that both INFILE and PARM file are the same                           *
/
/* Write values to OUTPUT1, passed as ATCC to program DZD040                   *
/
/*                                                                             *
/
/* Secure File Transfer Protocol (SFTP) Process - specific checks              *
/
/* Interogate FTP.PARMS (member passsed from jcl) to find IP address           *
/
/* Interogate FTP.PARMS to check that process name = passed process name       *
/
/* Reformat IP Address to 15 characters (pad with leading zero's)              *
/
/* Write values to OUTPUT1, passed as ATCC to program DZD040                   *
/
/*                                                                             *
/
/******************************************************************************
/
/* Updated : v0.3 Thursday   20th October 2016 - Ken Balnave                   *
/
/*    Added SFTP check process.                                                *
/
/*    Changed the MSGID's and Exit rc's.                                       *
/
/******************************************************************************
/
/* Updated : v0.2 Tuesday 3rd May 2016 - Ken Balnave                           *
/
/*    Added BYPASS process to ignore checking of PARM members (CD only).       *
/
/******************************************************************************
/
/* Updated : v0.1 Tuesday 23rd Feb 2016 - Ken Balnave                          *
/
/*    Initial write.                                                           *
/
/******************************************************************************
/


   ver = "v0.3"

   Say ; Say " Starting PFILREXX "ver" on "Date(w) Date()" at "Time() ; Say



Collect_PROCESS_TYPE_BYPASS_Parms:

   Parse Upper Arg process type bypass

   If process = "" | process = "&PROCESS" Then Do

     wtomsg1 = "++"

     wtomsg2 = "++  MSGID 10 - INVALID OR MISSING PROCESS FIELD ENTERED"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     Say "   Missing or invalid PROCESS field entered" ; Say

     Exit 10

   End

   If type /= "CD" & type /= "FTP" & type /= "SFTP" Then Do

     wtomsg1 = "++"

     wtomsg2 = "++  MSGID 11 - INVALID OR MISSING TYPE FIELD ENTERED"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     Say "   Missing or invalid TYPE field entered" ; Say

     Exit 11

   End

   If bypass /= "N" & bypass /= "Y" Then Do

     wtomsg1 = "++"

     wtomsg2 = "++  MSGID 13 - INVALID BYPASS FIELD ENTERED"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     Say "   Invalid BYPASS field entered" ; Say

     Exit 13

   End



Collect_Allocated_Files:

   st_trap = outtrap(var.)

   "LISTA ST"

   st_trap = outtrap(off)



Initialise_File_Names:

   Do i = 1 to var.0

     Parse var var.i v1 v2 v3 v4

     prev = i - 1

     If Pos("INFILE",v1) > 0 Then Do

       line = Strip(var.prev)

       line = Translate(line,' ','(')

       chkdsn = Word(line,1)

       If Right(chkdsn,3) = "V00" Then Do

         chkdsn = SubStr(chkdsn,1,(Length(chkdsn)-9))

         Leave i

       End

       Else Do

         wtomsg1 = "++"

         wtomsg2 = "++  MSGID 07 - "chkdsn" is not a GDG file  +++"

         "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

         "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"

         "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

         Say "   File being checked is NOT A GDG file"

         Say "     "chkdsn  ; Say

         /*Exit 07*/

       End

     End

   End



Initiliase:

   proc_found = n

   sftp_found = n

   parm_line  = " "

   Select

     When MVSVAR(SYSSMFID) = 'IND2' Then Do

       In_Parm = "CDIRECT.TEST.PARMS"

       In_Base = "CDIRECT.TEST.BASE"

       In_FTP  = "FTP.TEST.PARMS"

     End

     When MVSVAR(SYSSMFID) = 'INP2' Then Do

       In_Parm = "CDIRECT.PARMS"

       In_Base = "CDIRECT.BASE"

       In_FTP  = "FTP.PARMS"

     End

   End



   If type = "FTP"  Then Signal FTP_Section

   If type = "SFTP" Then Signal SFTP_Section



CD_Section:

   CD_parm_lib = In_Parm"("Strip(process)")"



Allocate_Read_Free_Parm:

   Drop parm.

   "alloc fi(INPARM) da('"CD_parm_lib"') shr "

   "execio * diskR INPARM (stem parm. finis)"

   "free fi(INPARM)"



Read_Parm_Get_Values:

   Do a = 1 to parm.0

     parm_line = parm_line" "Strip(parm.a)

     If Pos("PROC=",parm.a) > 0 Then Do

       proc_found = y

       Parse Var parm.a start "PROC=" proc_name remain

       base_lib = In_Base"("Strip(proc_name)")"

     End

   End

   If proc_found = n Then Do

     wtomsg1 = "++"

     wtomsg2 = "++  MSGID 14 - PROC STATEMENT NOT FOUND IN "CD_parm_lib

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     Say "   PROC statement not found in "CD_parm_lib ; Say

     Exit 14

   End



Allocate_Read_Free_Base:

   Drop base.

   "alloc fi(INBASE) da('"base_lib"') shr "

   "execio * diskR INBASE (stem base. finis)"

   "free fi(INBASE)"



Read_Base:

   chkF = n

   Do b = 1 to base.0

     If Pos(" PROCESS ",base.b) > 0 & Pos(" SNODE=",base.b) > 0 Then Do

       Parse Var base.b start "SNODE=" snode

       snode = Word(snode,1)

     End

     If Pos("FROM",base.b) > 0 & Pos("DSN=",base.b) > 0 Then Do

       If Pos(",DISP",base.b) > 0 Then Do

         Parse Var base.b start "DSN=" stype "," remain

       End

       Else Do

         Parse Var base.b start "DSN=" stype remain

       End

       chkF = y

       Leave b

     End

   End

   If chkF = n Then Do

     wtomsg1 = "++"

     wtomsg2 = "++  MSGID 15 - INVALID LAYOUT DETECTED IN "base_lib

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     Say "   INVALID layout detected in "base_lib ; Say

     Exit 15

   End



Find_Sending_DataSetName:

   parm_line = Translate(parm_line," ","=")

   wpos = WordPos(stype,parm_line) + 1

   sdsn = Word(parm_line,wpos)

   sdsn = Translate(sdsn," ","(")

   sdsn = Word(sdsn,1)



   If bypass = "Y" Then Do

     Say "   BYPASS mode in effect. PARMLIB dataset not verified."

     Say "   Check dataset passed      = "chkdsn

     Say "   Encrypted PARMLIB dataset = "sdsn ; Say

     sdsn = chkdsn

     Signal Create_CD_Line

   End



   If chkdsn <> sdsn Then Do

     wtomsg1 = "++"

     wtomsg2 = "++  MSGID 16 - SERIOUS ERROR - MISMATCH DETECTED"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     Say "   Serious error - mismatch in what is being checked in JCL",

         "and what is being sent in "CD_parm_lib

     Say "     Checking  -  "chkdsn

     Say "     Sending   -  "sdsn

     Say

     Exit 16

   End



Create_CD_Line:

   DummyLine = "SNODE"

   DummyLine = Overlay(stype,DummyLine,26)

   Say "   "DummyLine

   oline.1 = Translate(snode)

   oline.1 = Overlay(sdsn,oline.1,26)

   Say "   "oline.1"              <=== This line passed to DZD040"



   Signal Write_ATCC





FTP_Section:

   If type = "FTP" Then Do

     wtomsg1 = "++"

     wtomsg2 = "++  MSGID 99 - FTP SECTION NOT VALID YET"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     Say "   FTP process not created yet" ; Say

     Exit 99

   End



   Signal Write_ATCC





SFTP_Section:

   INprocess = Overlay("IN",process,1)

   SFTP_parm_lib = In_FTP"("Strip(INprocess)")"



Allocate_Read_Free_Parm:

   Drop parm.

   "alloc fi(INPARM) da('"SFTP_parm_lib"') shr "

   "execio * diskR INPARM (stem parm. finis)"

   "free fi(INPARM)"



Read_Parm_Get_Values:

   Do a = 1 to parm.0

     parm_line = parm_line" "Strip(parm.a)

     If Pos("sftp ",parm.a) > 0 | Pos("SFTP ",parm.a) > 0 Then Do

       sftp_found = y

       Parse Var parm.a start "-b " proc_name middle "@" ip_address remain

       If Pos("/",proc_name) > 0 Then Do

         proc_name = Translate(proc_name," ","/")

         wpn = Words(proc_name)

         proc_name = Word(proc_name,wpn)

       End

     End

   End

   If sftp_found = n Then Do

     wtomsg1 = "++"

     wtomsg2 = "++  MSGID 17 - SFTP STATEMENT NOT FOUND IN "SFTP_parm_lib

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     Say "   SFTP statement not found in "SFTP_parm_lib ; Say

     Exit 17

   End



   If process <> proc_name Then Do

     wtomsg1 = "++"

     wtomsg2 = "++  MSGID 18 - MISMATCH DETECTED IN PROCESS NAME"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg2"'"

     "CALL 'SYS1.LOADLIB(WTOPARM)' '"wtomsg1"'"

     Say "   Mismatch between passed process name "process" and 'IN' member",

         "process name "proc_name

     Exit 18

   End



Pad_IP_Address:

   temp_ip_address = Translate(ip_address," ",".")

   new_ip_address = ""

   Do ip = 1 to 4

     new_ip_add = Right(Word(temp_ip_address,ip),3,"0")"."

     new_ip_address = new_ip_address||new_ip_add

   End

   new_ip_address = SubStr(new_ip_address,1,15)



Create_SFTP_Line:

   DummyLine = "IP-ADDRESS"

   DummyLine = Overlay("DSN",DummyLine,26)

   Say "   "DummyLine

   oline.1 = new_ip_address

   oline.1 = Overlay(chkdsn,oline.1,26)

   Say "   "oline.1"              <=== This line passed to DZD040"



   Signal Write_ATCC



Write_ATCC:

   "execio 1 diskW output1 (stem oline. finis"

   "free fi(output1)"



   Say ; Say " Ending PFILREXX "ver" on "Date(w) Date()" at "Time() ; Say



Exit: exit 0

MEMBER NAME   RUNTASK
   If REC.0 <= count Then

Do

   say '    count does not meet criteria transmission not triggered'

   Say

   Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at "Time()

   Say

    exit 1

End

   ELSE

     say '    count meets criteria transmission triggered'

     Say

     Say

     Say "Ending   "exec_name" version "ver" on "Date(W) Date()" at "Time()

     Say

     Exit 0

/* rexx */

clear

Initialise_Version:

   ver = "0.1"



Issue_Message:

   Say

   Say "Starting LRUNTASK version "ver" on "Date(W) Date()" at "Time()

   Say



Get_DataSetNames_From_Invoking_Jcl:

   x = Listdsi(INPUT FILE)

   InDsn = SysDsname



   x = Listdsi(CURRGEN FILE)

   CurrGen =  SysDsname



If_Error:

   If Right(CurrGen,3) <> "V00" Then Do

     Say "  Error in supplied file name "CurrGen

     Exit 12

   End



Initialise_Variables:

   GV00 = SubStr(CurrGen,(Length(CurrGen)-7),8)



   old_gen_num = SubStr(GV00,2,4)

   new_gen_num = old_gen_num + 1

   new_gen_num = Right(new_gen_num,4,'0')



   next_gen = "G"new_gen_num"V00"



   OutDsn = SubStr(CurrGen,1,(Length(CurrGen)-9))"."next_gen



   "Rename '"InDsn"' '"OutDsn"'"

   If rc <> 0 Then Do

     Say "  Return Code " rc " from Rename"

     Exit rc

   End

   Else Do

     Say "  Rename successfull "

     Say "    Original file name       "InDsn

     Say "    Renamed file name        "OutDsn

   End



Exit:

   Say

   Say "Ending   LRUNTASK version "ver" on "Date(W) Date()" at "Time()

   Say

   Exit 0

MEMBER NAME   TEMP
/* rexx */

x = MVSVAR(SYSSMFID)

SAY X

MEMBER NAME   TRANCHCK
/* Language            : Rexx

 * Program Name        : TRANCHCK

 * Description         : Record the outgoing GV00 number and check if it has

 *                     : already been sent out. If it has, issue RC=20 to run

 *                     : WTOR to inform Service Desk.

 *                     : Purge history records older than 40 days.

  ******************************************************************************
/


   Say

   Say "Starting TRANCHCK v1.0 on "Date()" at " Time()

   Say



Collect_Allocated_Files:

   st_trap = outtrap(var.)

   "LISTA ST"

   st_trap = outtrap(off)



Initialise:

   pCnt = 0

   pDate = Date('B')-180

   pfullDate = Date('N',pDate,'B')

   cDate = Date()

   cTime = Time()

   cDT   = Right(cDate,11," ") cTime



Initialise_File_Names:

   Do i = 1 to var.0

     Parse var var.i v1 v2 v3 v4

     prev = i - 1

     If Pos("TRANDSN",v1) > 0 Then Do

       line = Strip(var.prev)

       line = Translate(line,' ','(')

       dsn = Word(line,1)

     End

     If Pos("HISTORY",v1) > 0 Then Do

       line = Strip(var.prev)

       line = Translate(line,' ','(')

       pds = Word(line,1)

     End

     If Pos(".JOB",v1) > 0 Then Do

       line = Translate(v1,' ','.')

       jobname = Word(line,2)

       Leave i

     End

   End



ReadCheckWrite:

   pdsmemb = pds"("jobname")"

   "free fi(HISTORY)"

   "alloc fi(HISTORY) da('"pdsmemb"') shr "

   testIT = SysDsn("'"pdsmemb"'")

   If testIT = "OK" then Do

     "execio * diskR HISTORY (stem hist. finis)"

     Say " "hist.0" record/s read from HISTORY member into stack"

     Call Check

     oLine.1 = Left(dsn,58," ")

     oLine.1 = Overlay(cDT,oline.1,60)

     Say " 1 New Record added => "oLine.1

     oCnt = 1

     Do w = 1 to hist.0

       bypass = n

       checkDate = Strip(SubStr(hist.w,60,11))

       Call Purge_History

       If bypass = y Then Iterate w

       oCnt = oCnt + 1

       oLine.oCnt = hist.w

     End

     "execio "oCnt" diskW HISTORY (stem oLine. finis)"

     Say " "oCnt" record/s written to HISTORY member from updated stack"

   End

   Else Do

     oLine.1 = Left(dsn,58," ")

     oLine.1 = Overlay(cDT,oline.1,60)

     "execio 1 diskW HISTORY (stem oLine. finis)"

     Say " First Time Record added => "oLine.1

   End



Display_Purged_Records:

   If pCnt > 0 Then Do

     Say " "pCnt" record/s deleted from HISTORY member that are older than",

         "purge date '"pfullDate"' are listed below"

     Say

     Do p = 1 to pCnt

       Say " "purhist.p

     End

   End



Exit:

   Say

   Say "Ending   TRANCHCK RC=0 on "Date()" at "Time()

   Say

   Exit 0



Check:

   Do c = 1 to hist.0

     If Word(hist.c,1) = dsn Then Do

       Say " "dsn" has already been recorded as sent out on "SubStr(hist.c,60,20
)
       Say " Please investigate as a matter of urgency"

       Say

       Say "Ending   TRANCHCK RC=20 on "Date()" at " Time()

       Say

       Exit 20

     End

   End



   Return 0



Purge_History:

   inDate = Date('B',checkDate)

   If inDate < pDate Then Do

     pCnt = pCnt + 1

     purhist.pcnt = hist.w

     bypass = y

   End



   Return 0



MEMBER NAME   TRANEDIT
/*================================   Rexx  ====================================*
/
/*     Name          - TRANEDIT                                                *
/
/*     Author        - Stuart Dolman                                           *
/
/*     Written       - December 2005                                           *
/
/*     Environment   - TSO/Batch (IKJEFT01)                                    *
/
/*     Version       - 1.4                                                     *
/
/*     Function      - Update date,time or sequence number in file             *
/
/*     Modified      - February 2006                                           *
/
/*     Modified by   - Stuart Dolman                                           *
/
/*     Modification  - Add Date sequence number reset on new day               *
/
/*     Modified      - March 2006                                              *
/
/*     Modified by   - Stuart Dolman                                           *
/
/*     Modification  - Add Date copy date                                      *
/
/*     Modified      - August 2006                                             *
/
/*     Modified by   - Stuart Dolman                                           *
/
/*     Modification  - Add Sequence number from Ctlcard                        *
/
/*     Modified      - October 2006                                            *
/
/*     Modified by   - Stuart Dolman                                           *
/
/*     Modification  - Add insert date                                         *
/
/*===============================   Variables =================================*
/
/*     KEYWORD       - Word to be searched for in JCL. stem   ( from EXEC )    *
/
/*     OFFSET        - Offset where overlay is to take place  ( from EXEC )    *
/
/*     DATEFRMT      - format of the date that is to be used  ( from EXEC )    *
/
/*     COUNT         - Counter for export routine                              *
/
/*     hh            - hours                                                   *
/
/*     mi            - minutes                                                 *
/
/*     ss            - seconds                                                 *
/
/*     yyyy          - 4 digit year                                            *
/
/*     dd            - day of the month (numeric)                              *
/
/*     mmm           - First three characters of Month (Alpha)                 *
/
/*     mm            - month (numeric)                                         *
/
/*     yy            - year (numeric)                                          *
/
/*     yp            - century (numeric)                                       *
/
/*     jjjjj         - 5 digit julian date                                     *
/
/*     jjj           - 3 digit julian date                                     *
/
/*     day           - day of the week (Alpha)                                 *
/
/*     dy3           - First three charachters of DOW (Upper Alpha)            *
/
/*     #             - day of week (numeric start with Monday)                 *
/
/*============================================================================*
/
/*trace i*/

Say 'TRANEDIT - Version 1.4  25/10/2006'



Parse SOURCE . . exec_name .

Parse ARG ARGS

If Words(ARGS) ¬= 3 Then

   Do

     Say exec_name' - ERROR - not enough parms passed to exec '

     Exit 5

   End



Parse VAR ARGS KEYWORD OFFSET DATEFRMT



/*============================ Variable Setup  ================================*
/
/*                         Set up variables for editing                        *
/
/*============================================================================*
/
COUNT = 0

    hh = Substr(Time(),1,2)

    mi = Substr(Time(),4,2)

    ss = Substr(Time(),7,2)

 yyyy = Substr(Date(S),1,4)

    dd = Substr(Date(E),1,2)

   mmm = Substr(Date(M),1,3)

    mm = Substr(Date(E),4,2)

    yy = Substr(Date(E),7,2)

    yp = Substr(yyyy,1,2)

jjjjj = Date(J)

   jjj = Substr(jjjjj,3)

   day = Date(W)

   bdt = date(b)

   M1 = substr(DATE('S',bdt - 15,'B'),1,6)

   M2 = substr(DATE('S',bdt - 45,'B'),1,6)

   dy3 = Translate(Substr(Date(W),1,3))

Select

   When Substr(day,1,3) = 'Mon' Then # = '1'

   When Substr(day,1,3) = 'Tue' Then # = '2'

   When Substr(day,1,3) = 'Wed' Then # = '3'

   When Substr(day,1,3) = 'Thu' Then # = '4'

   When Substr(day,1,3) = 'Fri' Then # = '5'

Otherwise Nop

End



/*============================ Read in File  ==================================*
/
/*              Read file to be edited into stem variable JCL.                 *
/
/*============================================================================*
/
DSNINFO = Listdsi(EDITFILE FILE)



"Execio * Diskr EDITFILE (Stem JCL. Finis"

 If RC ¬= 0 Then

    Do

      Say exec_name' - ERROR - Unable to allocate 'SYSDSNAME

      Say exec_name' - ERROR - or member not Found'

      Exit 10 + RC

    End

/*===================== Read Date from CTLDATES V+  ===========================*
/
/* If DATEFRMT is prefixed with Upper Case VCTL this section will read the     *
/
/* date in from DD CTLDATES. After the VCTL prefix the next three digits are   *
/
/* the Org Number that will be looked for in the CTLDATES file.                *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,4) = 'VCTL' Then

   Do

     Org_Num     = Substr(DATEFRMT,5,3)

     Date_Format = Substr(DATEFRMT,8)

     Call Get_VCtldate

     Call Conv_Date_Var Date_Format

     Call Date_Update

     Call EXP_File

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*========================== Sequence Number Update  ==========================*
/
/* If the edit is to update a sequnce number this will read in the DATEFRMT    *
/
/* variable feed from the exec parm. The number suffixed on the end of SEQNUM  *
/
/* will detemine how long the sequence number will be padded out to            *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,6) = 'SEQNUM' Then

   Do

     SEQPAD = Substr(DATEFRMT,7)

     If Datatype(SEQPAD) ¬= 'NUM' Then

       Do

         Say exec_name' - ERROR - Invalid Parameter passed for Seqential'

         Say exec_name' - ERROR - Number update'

         Exit 15

       End

      Call Seq_Update

      Call EXP_File

      Call Seq_Exit

    End



/*======================= Read Date from DATEFILE  ============================*
/
/* If DATEFRMT is prefixed with UpperCase PASTE the date will be supplied      *
/
/* directly after PASTE.                                                       *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,5) = 'PASTE' Then

   Do

     Date_var = Substr(DATEFRMT,6)

     Call Date_Update

     Call EXP_File

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*======================= Read Date from DATEFILE  ============================*
/
/* If DATEFRMT is prefixed with Upper Case COPY the date format supplied will  *
/
/* be as follows after COPY the next two characters are the input offset the   *
/
/* next set of charaters upto the ¢ symbol will be the input keyword. The      *
/
/* date fornat supplied after that will be read to ascertain the length of     *
/
/* the date to be read in.                                                     *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,4) = 'COPY' Then

   Do

     Read_Offset = Substr(DATEFRMT,5,2)

     Read_Keyword = Substr(DATEFRMT,7,Index(DATEFRMT,'¢',)-7)

     Date_Format = Substr(DATEFRMT,Index(DATEFRMT,'¢',)+1)

     Call Get_date

     Call Date_Update

     Call EXP_File

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*======================= Read Date from CTLDATES  ============================*
/
/* If DATEFRMT is prefixed with Upper Case CTL this section will read the      *
/
/* date in from DD CTLDATES. Then the date will be passed to Conv_Date_Var     *
/
/* to format the date for editing.                                             *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,3) = 'CTL' Then

   Do

     Date_Format = Substr(DATEFRMT,4)

     Call Get_Ctldate

     Call Conv_Date_Var Date_Format

     Call Date_Update

     Call EXP_File

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*===================Date and Sequence Number  Update==========================*
/
/* If DATEFRMT is prefixed with Uppercase DSEQ this section will read the      *
/
/* fifth of DATEFRMT as the sequence number padding and the rest as the date   *
/
/* format. The date will be read in from the output file and if the date is    *
/
/* the same as todays date then 1 will be added to the sequence number, if     *
/
/* the dates differ the sequence number will be reset to 1.                    *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,4) = 'DSEQ' Then

   Do

     Date_Format = Substr(DATEFRMT,6)

     Date_Length = Length(Date_Format)

     SeqPad      = Substr(DATEFRMT,5,1)

     Call Conv_Date_Var Date_Format

     Call Get_File_Date_and_Seq

     seqnum = File_Seq

     If date_var = file_date then seqnum = seqnum + 1

     else

     seqnum = '1'

     seqnum = right(Seqnum,SeqPad,'0')

     Date_var = Date_var||seqnum

     Call Date_Update

     Call EXP_File

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*===================Date and Sequence Number  Update==========================*
/
/* If DATEFRMT is prefixed with Uppercase SEQD this section will read the      *
/
/* sixth of DATEFRMT as the sequence number padding and the rest as the date   *
/
/* format. The date will be read in from the output file and if the date is    *
/
/* the same as todays date then 1 will be added to the sequence number, if     *
/
/* the dates differ the sequence number will be reset to 1.                    *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,4) = 'SEQD' Then

   Do

     Date_Format = Substr(DATEFRMT,6)

     Date_Length = Length(Date_Format)

     SeqPad      = Substr(DATEFRMT,5,1)

     Call Conv_Date_Var Date_Format

     Call Get_Seq_and_File_Date

     seqnum = File_Seq

     If date_var = file_date then seqnum = seqnum + 1

     else

     seqnum = '1'

     seqnum = right(Seqnum,SeqPad,'0')

     Date_var = seqnum||Date_var

     Call Date_Update

     Call EXP_File

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*===================Date and Sequence Number  Update==========================*
/
/* If DATEFRMT is prefixed with Uppercase DSQQ this section will read the      *
/
/* fifth of DATEFRMT as the sequence number padding and the rest as the date   *
/
/* format.                                                                     *
/
/*                                                                             *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,4) = 'DSQQ' Then

   Do

     Date_Format = Substr(DATEFRMT,6)

     Date_Length = Length(Date_Format)

     SeqPad      = Substr(DATEFRMT,5,1)

     Call Conv_Date_Var Date_Format

     Call Get_SeqNum

     seqnum = File_Seq

     seqnum = seqnum + 1

     seqnum = right(Seqnum,SeqPad,'0')

     Date_var = Date_var||seqnum

     Call Date_Update

     Call EXP_File

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*==================Date and Sequence CTL Number  Update=======================*
/
/* If DATEFRMT is prefixed with Uppercase DSCQ this section will read the      *
/
/* fifth of DATEFRMT as the sequence number padding and the rest as the date   *
/
/* format. The Sequence number is read in from DD SEQNFILE.                    *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,4) = 'DSCQ' Then

   Do

     Date_Format = Substr(DATEFRMT,6)

     Date_Length = Length(Date_Format)

     SeqPad      = Substr(DATEFRMT,5,1)

     Call Conv_Date_Var Date_Format

     Call Get_Ctl_SeqNum

     seqnum = seqnum + 1

     seqnum = right(Seqnum,SeqPad,'0')

     Date_var = Date_var||seqnum

     Call Date_Update

     Call EXP_File

     seqnum.1 = seqnum

     Call Update_Seq_Ctl

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*==================Date and Sequence CTL Number  Update=======================*
/
/* If DATEFRMT is prefixed with Uppercase DSCR this section will read the      *
/
/* fifth of DATEFRMT as the sequence number padding and the rest as the date   *
/
/* format. The Sequence number is read in from DD SEQNFILE. Reset sequence     *
/
/* number if ctl date does not equal today.                                    *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,4) = 'DSCR' Then

   Do

     Date_Format = Substr(DATEFRMT,6)

     Date_Length = Length(Date_Format)

     SeqPad      = Substr(DATEFRMT,5,1)

     Call Conv_Date_Var Date_Format

     Call Get_Ctl_Date_and_Seq

     If date_var = file_date then seqnum = seqnum + 1

     else

     seqnum = '1'

     seqnum = right(Seqnum,SeqPad,'0')

     seqnum.1 = seqnum||' '||Date_var

     Date_var = Date_var||seqnum

     Call Date_Update

     Call EXP_File

     Call Update_Seq_Ctl

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*===================== Sequence CTL Number Update  ===========================*
/
/* If DATEFRMT is prefixed with Uppercase SEQC this section will read the      *
/
/* fifth of DATEFRMT as the sequence number padding and the rest as the date   *
/
/* format. The Sequence number is read in from DD SEQNFILE. Reset sequence     *
/
/* number if ctl date does not equal today.                                    *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,4) = 'SEQC' Then

   Do

     Date_Format = Substr(DATEFRMT,6)

     Date_Length = Length(Date_Format)

     SeqPad      = Substr(DATEFRMT,5,1)

     Call Conv_Date_Var Date_Format

     Call Get_Ctl_Date_and_Seq

     If date_var = file_date then seqnum = seqnum + 1

     else

     seqnum = '1'

     seqnum = right(Seqnum,SeqPad,'0')

     seqnum.1 = seqnum||' '||Date_var

     Date_var = seqnum

     Call Date_Update

     Call EXP_File

     Call Update_Seq_Ctl

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*==============Date Time and Sequence Number Update for  MCI==================*
/
/* If DATEFRMT is prefixed with Uppercase MCIU this section will read the      *
/
/* fifth of DATEFRMT as the sequence number padding and the rest as the date   *
/
/* format. The date will be read in from the output file and if the date is    *
/
/* the same as todays date then 1 will be added to the sequence number, if     *
/
/* the dates differ the sequence number will be reset to 1. This is for MCI    *
/
/* files only.                                                                 *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,4) = 'MCIU' Then

   Do

     Date_Format = Substr(DATEFRMT,6)

     Date_Length = Length(Date_Format)

     SeqPad      = Substr(DATEFRMT,5,1)

     Call Conv_Date_Var Date_Format

     Call Get_File_Date_and_Seq

     seqnum = File_Seq

     date_part = Substr(date_var,1,Pos('.',date_var))

     date_file = Substr(file_date,1,Pos('.',file_date))

     If date_part = date_file then seqnum = seqnum + 1

     else

     seqnum = '1'

     seqnum = right(Seqnum,SeqPad,'0')

     Date_var = Date_var||seqnum

     Call Date_Update

     Call EXP_File

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*============================================================================*
/
If Substr(DATEFRMT,1,4) = 'PAGO' Then

   Do

     Date_Format = Substr(DATEFRMT,6)

     Date_Length = Length(Date_Format)

     SeqPad      = Substr(DATEFRMT,5,1)

     Call Conv_Date_Var Date_Format

     Call Get_File_Date_and_Seq

     seqnum = File_Seq

     date_part = Substr(date_var,1,Pos('_',date_var))

     date_file = Substr(file_date,1,Pos('_',file_date))

     If date_part = date_file then seqnum = seqnum + 1

     else

     seqnum = '1'

     seqnum = right(Seqnum,SeqPad,'0')

     Date_var = Date_var||seqnum

     Call Date_Update

     Call EXP_File

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*============================= Instert Date  =================================*
/
/* If DATEFRMT is prefixed with INS this section will take the 4th character   *
/
/* from DATEFRMT as the ending string of the date. Any thing after the 4th     *
/
/* character is the new date format. The date will be overriden in the         *
/
/* ctlcard with all characters after it replaced.                              *
/
/*============================================================================*
/
If Substr(DATEFRMT,1,3) = 'INS' Then

   Do

     Date_Format = Substr(DATEFRMT,5)

     Ending_Char  = Substr(DATEFRMT,4,1)

     Call Conv_Date_Var Date_Format

     Call Date_Update_Ins

     Call EXP_File

     Say exec_name' - Rexx Routine Completed Cond Code 0'

     Say exec_name' - Date Format used 'DATEFRMT' converted to 'Date_Var

     Exit

   End



/*================================ Catch All  =================================*
/
/* This section will perfrom the edit if not a sequence number or reading the  *
/
/* date from CTLDATES. This will use the dates from the variables set at the   *
/
/* start of the Rexx.                                                          *
/
/*============================================================================*
/
Call Conv_Date_Var DATEFRMT

Call Date_Update

Call EXP_File



Say exec_name' - Rexx Routine Completed Cond Code 0'

Say exec_name '- Date Format used 'DATEFRMT' converted to 'Date_Var



Exit



Date_Update:

/*============================= Date_Update  ==================================*
/
/* This routine will read in stem JCL. and overlay variable date_var on the    *
/
/* line that contains the KEYWORD variable. The overlay takes place at the     *
/
/* starting pint of the KEYWORD + the OFFSET supplied by the exec parm.        *
/
/*============================================================================*
/
Do A=1 to JCL.0 by 1

     O = Index(JCL.A,Keyword)

     If O > 0 Then

     Do

       X = O + Offset

       JCL.A = Overlay(date_var,JCL.A,X)

       B = 0

     End

End

Return



Date_Update_Ins:

/*============================= Date_Update  ==================================*
/
/* This routine will read in stem JCL. and overlay variable date_var on the    *
/
/* line that contains the KEYWORD variable. The overlay takes place at the     *
/
/* starting pint of the KEYWORD + the OFFSET supplied by the exec parm.        *
/
/*============================================================================*
/
Do A=1 to JCL.0 by 1

     O = Index(JCL.A,Keyword)

     If O > 0 Then

     Do

       X = O + Offset

       Y = Index(JCL.A,Ending_Char,X)

       End_of_Line = Substr(JCL.A,Y)

       date_var = date_var||End_of_Line

       JCL.A = Overlay(date_var,JCL.A,X)

       JCL.A = Substr(JCL.A,1,80)

       B = 0

     End

End

Return



Get_date:

/*============================== Get_Ctldate  =================================*
/
/* This routine will read the date in from DD CTLDATES and will Call GREG2JUL  *
/
/* to convert this date into Julian fomat if required.                         *
/
/*============================================================================*
/
"Execio * Diskr DATEFILE (Stem INDATE. Finis"

   If RC ¬= 0 Then

   Do

     SAY exec_name' - ERROR -  Unable to Allocate DD DATEFILE File'

     Delstack

     Exit RC + 10

   End



Do D = 1 to INDATE.0

   O = Index(INDATE.D,Read_Keyword)

   If O > 0 Then date_Var = Substr(INDATE.D,O+Read_Offset,Length(Date_Format))

End



Return



Get_Ctldate:

/*============================== Get_Ctldate  =================================*
/
/* This routine will read the date in from DD CTLDATES and will Call GREG2JUL  *
/
/* to convert this date into Julian fomat if required.                         *
/
/*============================================================================*
/
"Execio 1 Diskr DATEFILE (Stem CTLDATES. Finis"

   If RC ¬= 0 Then

   Do

     SAY exec_name' - ERROR -  Unable to Allocate CTLDATES File'

     Delstack

     Exit RC + 10

   End





CTLDATE = Substr(CTLDATES.1,17,8)



Parse VAR CTLDATE mm '/' dd '/' yy



Call GREG2JUL dd mm yy



JJJJJ = RESULT

JJJ = Substr(RESULT,3)



Return



SEQ_Update:

/*=============================== SEQ_Update  =================================*
/
/* This routine will read in stem JCL. and read in the old sequence number     *
/
/* the line containing the KEYWORD. It will then add one to the sequence       *
/
/* number read in then overlay the original sequnce number.                    *
/
/*============================================================================*
/
   B = 1



    Do A=1 to JCL.0 by 1

        O = Index(JCL.A,KEYWORD)

        If O > 0 Then

        Do

          X = O + OFFSET

          FILENUM = Substr(JCL.A,X,SEQPAD)

          FILENUM = FILENUM + 1

          FILENUM = Right(FILENUM,SEQPAD,0)

          JCL.A = Overlay(FILENUM,JCL.A,X)

          B = 0

        End

    End



 If B = 1 Then

    Do

      Say exec_name' - ERROR -  No Matching Characters Found'

      Say exec_name' - ERROR -  Sequential Numbering not updated'

      Exit 30 + RC

    End



Return



Conv_Date_Var:

/*=========================== Conv_Date_Var  ==================================*
/
/* This routine will take in the DATEFRMT variable and will replace the date   *
/
/* and time fields in variable date_var ready for editing.                     *
/
/*============================================================================*
/
Arg date_var

If Index(date_var,'YYYY') > 0 Then

date_var = Overlay(YYYY,date_var,Index(date_var,'YYYY'))

If Index(date_var,'HH') > 0 Then

date_var = Overlay(HH,date_var,Index(date_var,'HH'))

If Index(date_var,'MI') > 0 Then

date_var = Overlay(MI,date_var,Index(date_var,'MI'))

If Index(date_var,'SS') > 0 Then

date_var = Overlay(SS,date_var,Index(date_var,'SS'))

If Index(date_var,'DD') > 0 Then

date_var = Overlay(DD,date_var,Index(date_var,'DD'))

If Index(date_var,'MMM') > 0 Then

date_var = Overlay(MMM,date_var,Index(date_var,'MMM'))

If Index(date_var,'MM') > 0 Then

date_var = Overlay(MM,date_var,Index(date_var,'MM'))

If Index(date_var,'YY') > 0 Then

date_var = Overlay(YY,date_var,Index(date_var,'YY'))

If Index(date_var,'YP') > 0 Then

date_var = Overlay(YP,date_var,Index(date_var,'YP'))

If Index(date_var,'JJJJJ') > 0 Then

date_var = Overlay(JJJJJ,date_var,Index(date_var,'JJJJJ'))

If Index(date_var,'JJJ') > 0 Then

date_var = Overlay(JJJ,date_var,Index(date_var,'JJJ'))

If Index(date_var,'DAY') > 0 Then

date_var = Overlay(DAY,date_var,Index(date_var,'DAY'))

If Index(date_var,'DY3') > 0 Then

date_var = Overlay(DY3,date_var,Index(date_var,'DY3'))

If Index(date_var,'M1') > 0 Then

date_var = Overlay(M1,date_var,Index(date_var,'M1'))

If Index(date_var,'M2') > 0 Then

date_var = Overlay(M2,date_var,Index(date_var,'M2'))

If Index(date_var,'N') > 0 Then

date_var = Overlay(N,date_var,Index(date_var,'N'))

Return date_var



EXP_FILE:

/*================================ EXP_FILE  ==================================*
/
/* This routine will write the stem JCL. back to the file that is to be        *
/
/* updated. If the return code of the Execio is not 0 the routine will wait    *
/
/* 2 second and try again, it will try this upto 5 times and fail.             *
/
/*============================================================================*
/
   "Execio "JCL.0" Diskw "EDITFILE" (Stem JCL. Finis"



    Select

      When RC ¬= 0 & COUNT < 5 Then

        Do

          RET = RC + 20

          COUNT = COUNT + 1

          "Call *(OPSWAIT) '2'"

          Signal EXP_FILE

        End



      When RC ¬= 0 & COUNT >= 5 Then

        Do

          Say exec_name' - ERROR - Unable to allocate 'SYSDSNAME

          Say exec_name' - ERROR - or member not Found'

          Exit RET

        End



    Otherwise

    Nop

    End



"Free F("EDITFILE")"

"Delstack"



Return



Get_SeqNum:



Do A = 1 to JCL.0

   O = Index(JCL.A,KEYWORD)

   NOFF = OFFSET+Date_Length

   If O > 0 Then

     Do

       File_Seq  = Substr(JCL.A,NOFF+O,SeqPad)

     End

End



Return File_Date File_Seq



Get_File_Date_and_Seq:



Do A = 1 to JCL.0

   O = Index(JCL.A,KEYWORD)

   If O > 0 Then

     Do

       File_Date = Substr(JCL.A,OFFSET+O,Date_Length)

       File_Seq  = Substr(JCL.A,OFFSET+O+Date_Length,SeqPad)

     End

End



Return File_Date File_Seq



Get_SEQ_and_File_Date:



Do A = 1 to JCL.0

   O = Index(JCL.A,KEYWORD)

   If O > 0 Then

     Do

       File_Date = Substr(JCL.A,OFFSET+O+Seqpad,Date_Length)

       File_Seq  = Substr(JCL.A,OFFSET+O,SeqPad)

     End

End



Return File_Date File_Seq



Seq_Exit:

      Say exec_name' - Rexx Routine Completed Cond Code 0'

      Say exec_name' - File sequence number updated to 'FILENUM



 Exit



Get_Ctl_SeqNum:



"Execio 1 Diskr SEQNFILE ( Finis"

   If RC ¬= 0 Then

     Do

       Say exec_name' -  Unable to Allocate SEQNFILE File'

       Delstack

       Exit RC + 10

     End



   Pull Seqnum



Return Seqnum



Get_Ctl_Date_and_Seq:



"Execio 1 Diskr SEQNFILE ( Finis"

   If RC ¬= 0 Then

     Do

       Say exec_name' -  Unable to Allocate SEQNFILE File'

       Delstack

       Exit RC + 10

     End



   Pull Line



   Seqnum = word(line,1)

   File_Date = word(line,2)



Return File_Date Seqnum



Update_Seq_Ctl:



"Execio 1 Diskw SEQNFILE (Stem seqnum. Finis"

   If RC ¬= 0 Then

     Do

       Say exec_name' -  Unable to Allocate SEQNFILE File'

       Delstack

       Exit RC + 15

     End



Return



Get_VCtldate:

/*============================== Get_Ctldate  =================================*
/
/* This routine will read the date in from DD CTLDATES and will Call GREG2JUL  *
/
/* to convert this date into Julian fomat if required.                         *
/
/*============================================================================*
/
"Execio * Diskr DATEFILE (Stem CTLDATES. Finis"

   If RC ¬= 0 Then

   Do

     SAY exec_name' - ERROR -  Unable to Allocate CTLDATES File'

     Delstack

     Exit RC + 10

   End



Do A = 1 to CTLDATES.0

   If Substr(CTLDATES.A,3,4) = ' '||Org_Num Then

     Do

       CTLDATE = Substr(CTLDATES.A,45,8)

       Leave

     End

End



If CTLDATE = 'CTLDATE' Then

   Do

     Say exec_name' - Error - ORG 'Org_Num' not found in File'

     Exit RC + 20

   End



Parse VAR CTLDATE dd '/' mm '/' yy

yyyy = '20'||yy



Call GREG2JUL dd mm yy



JJJJJ = RESULT

JJJ = Substr(RESULT,3)



Return

